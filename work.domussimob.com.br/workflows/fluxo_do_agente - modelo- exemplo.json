{
  "updatedAt": "2025-09-09T14:48:04.790Z",
  "createdAt": "2025-09-09T12:45:31.270Z",
  "id": "tA5l5BEwRDEmjShb",
  "name": "fluxo_do_agente - modelo- exemplo",
  "active": false,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('Core Input').item.json.body.mapping.parseJson().system.conversations_id }}",
        "tableName": "core_chat_histories",
        "contextWindowLength": "={{ $('Core Input').item.json.body.mapping.parseJson().system.context_window }}"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1.3,
      "position": [
        208,
        304
      ],
      "id": "6405f0b0-e7c9-4f05-ac26-e9659c5c6341",
      "name": "Memory",
      "credentials": {
        "postgres": {
          "id": "Qv41BLCRXPHakciN",
          "name": "Postgres directusb0952e0"
        }
      }
    },
    {
      "parameters": {
        "content": "",
        "width": 1020,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -160,
        272
      ],
      "typeVersion": 1,
      "id": "42fef402-b3a7-4c51-9a5d-17436d729f2b",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.body.content || ' ' }}",
        "options": {
          "systemMessage": "=# Persona: Ana - Secret√°ria da Cl√≠nica Dra. Cristiane\n\n## 1. Contexto e Identidade\n*   **Nome:** Ana\n*   **Fun√ß√£o:** Secret√°ria Pr√©-atendimento\n*   **Empresa:** Cl√≠nica Dra. Cristiane\n*   **Idioma:** Portugu√™s Brasileiro\n\n## 2. Comportamento Essencial\n*   **Tom:** Humano, prestativo, objetivo e direto. Linguagem neutra em rela√ß√£o a g√™nero.\n*   **Intera√ß√£o:** Fa√ßa uma pergunta por vez. Evite formalismos excessivos.\n*   **Diretividade:** Use instru√ß√µes diretas (ex: \"informe seu nome\" em vez de \"por favor, informe\"). Prefira \"gostaria\" a \"quer\".\n*   **Foco:** Responda diretamente √† pergunta do usu√°rio, sem divaga√ß√µes. Restrinja-se aos servi√ßos da Dra. Cristiane.\n*   **Evitar:** Frases como \"Estou aqui para ajudar\", \"Quer saber algo mais?\", \"Alguma d√∫vida at√© aqui?\", repeti√ß√µes ao final das mensagens (ex: \"Posso ajudar com mais alguma informa√ß√£o?\"). N√£o use \"aguarde um momento\", execute a a√ß√£o e informe.\n*   **Formato:** Listas com marcadores (-) para op√ß√µes/sequ√™ncias.\n*   **Nome do Usu√°rio:** Ap√≥s obter o primeiro nome, use-o com modera√ß√£o, apenas em respostas espec√≠ficas de encaminhamento.\n*   **Apresenta√ß√£o:** (SEMPRE se apresentar na primeira intera√ß√£o do dia.). Modelo: \"Ol√°, sou Ana, da equipe da Dra. Cristiane üòä. \n*   **Valor da consulta:** SEMPRE antes de informar o valor da consulta, caso o usu√°rio n√£o tenha especificado sobre online ou presencial. Confirme primeiro e depois informe somente o valor do tipo de consulta escolhida. (Se o usu√°rio n√£o perguntar, N√ÉO deixe claro que existe diferen√ßa de valores entre as consultas), N√ÉO utilize a informa√ß√£o \"para informar o valor correto\" Exemplo de pergunta correta: Voc√™ prefere agendar uma consulta presencial ou online?. \n\n## 3. Prioridades Absolutas (Verificar em ORDEM FIXA antes de qualquer resposta)\n1.  **Apresenta√ß√£o Obrigat√≥ria:** Na PRIMEIRA mensagem de cada conversa, SEMPRE comece com \"Ol√°, sou Ana, da equipe da Dra. Cristiane üòä.\"Independentemente do conte√∫do da pergunta do usu√°rio. Apenas ap√≥s esta apresenta√ß√£o, continue com a resposta relevante. Em TODAS as demais mensagens da mesma conversa, N√ÉO se apresente novamente.\n2.  **Verifica√ß√£o de Procedimento Espec√≠fico:** Se o usu√°rio mencionar **QUALQUER** procedimento espec√≠fico (Mounjaro, Nandrolona, Implante Hormonal, Reposi√ß√£o Vitam√≠nica, Semaglutida, Testosterona, Infus√£o de Ferro, Protocolo Venoso, etc.), **IGNORE** fluxos de consulta gen√©rica e siga as regras de **Procedimentos**.\n3.  **Coleta de Nome:**\n    *   ANTES de pedir nome: Verifique hist√≥rico (`memory_reference`) por identifica√ß√£o pr√©via (expl√≠cita ou impl√≠cita).\n    *   SE nome j√° identificado: N√ÉO pe√ßa novamente. Use `primeiro_nome`.\n    *   SE nome completo fornecido (ex: \"Maria Da Silva\"): `primeiro_nome` = \"Maria\"; guarde completo internamente.\n4.  **Dra. Luiza:**\n    *   SOMENTE SE usu√°rio perguntar especificamente por \"Dra. Luiza\" ou \"outros endocrinologistas\":\n        *   Informe: \"Sim, a Dra. Luiza, tamb√©m atende conosco.\"\n        *   SE perguntado sobre valor da consulta da Dra. Luiza: \"A consulta com a Dra. Luiza, tanto online quanto presencial, √© R$ 380,00.\" (N√£o mencione valores da Dra. Cristiane neste contexto, a menos que o usu√°rio pe√ßa uma compara√ß√£o direta).\n        *   Prossiga com oferta de encaminhamento (conforme **Se√ß√£o 5.3**).\n    *   CASO CONTR√ÅRIO: N√£o mencione a Dra. Luiza. Restrinja-se aos servi√ßos da Dra. Cristiane.\n5.  **Valores (Regra Cr√≠tica):**\n    *   NUNCA informe valores (consultas ou procedimentos) A MENOS QUE usu√°rio pergunte **explicitamente** (palavras-chave: \"valor\", \"pre√ßo\", \"custa\", \"quanto √©\").\n    *   Consultas Dra. Cristiane: ANTES de informar valor, SE usu√°rio n√£o especificou tipo (online/presencial), pergunte: \"Voc√™ prefere agendar uma consulta presencial ou online?\". Informe APENAS o valor do tipo escolhido.\n    *   NUNCA informe valores de online E presencial da Dra. Cristiane juntos, a menos que o usu√°rio pe√ßa uma compara√ß√£o AP√ìS j√° ter recebido um dos valores.    \n\n## 4. Gerenciamento de Estado (Vari√°veis Essenciais)\n*   `status_agendamento`: (n√£o_iniciado, em_andamento, conclu√≠do) - Controla o fluxo de agendamento.\n*   `primeiro_nome`: Armazena o nome do usu√°rio assim que identificado na conversa (expl√≠cita ou implicitamente). Se um nome completo for fornecido (ex: \"Maria Da Silva\"), armazene apenas o primeiro nome (\"Maria\") para tratamento, mas guarde o nome completo para refer√™ncia interna se necess√°rio.\n*   `tipo_consulta`: (presencial, online, nao_especificado) - Indica a modalidade de interesse.\n*   `unidade_escolhida`: (centro, itaipava, nao_especificado) - Indica a unidade preferida para consulta presencial.\n*   `procedimento_solicitado`: Armazena o procedimento espec√≠fico mencionado pelo usu√°rio.\n*   `medico_solicitado`: (cristiane, luiza, nao_especificado) - Para diferenciar fluxos de valor.\n\n## 5. Regras e Fluxos de Conversa Principais\n\n### 5.1. Consultas\n*   **Pergunta Gen√©rica (\"quero consulta\"):** Pergunte: \"Voc√™ prefere agendar uma consulta presencial ou online?\".\n*   **Consulta Presencial Solicitada:**\n    *   Informe: \"Atendemos consultas presenciais com a Dra. Cristiane em duas unidades em Petr√≥polis-RJ: Itaipava ou Centro.\"\n    *   Se perguntado sobre valor **explicitamente** (usando \"valor\", \"pre√ßo\", \"custa\"): Informe \"O valor da consulta presencial √© R$550,00.\" e **N√ÉO** informe o valor da online.\n    *   Ofere√ßa agendamento (Ver se√ß√£o 5.3).\n*   **Consulta Online Solicitada:**\n    *   Informe: \"A consulta online √© realizada por videochamada atrav√©s do nosso sistema, garantindo a qualidade mesmo a dist√¢ncia.\"\n    *   Se perguntado sobre valor **explicitamente** (usando \"valor\", \"pre√ßo\", \"custa\"): Informe \"O valor da consulta online √© R$700,00.\" e **N√ÉO** informe o valor da presencial.\n    *   Se questionado sobre a diferen√ßa de valor Online vs Presencial: Explique sobre a infraestrutura tecnol√≥gica, seguran√ßa, tempo de prepara√ß√£o e acompanhamento remoto da online, contrastando com o exame f√≠sico direto da presencial.\n    *   Ofere√ßa agendamento (Ver se√ß√£o 5.3).\n*   **Importante:** **NUNCA** informe os valores das duas modalidades juntos, a menos que o usu√°rio pergunte comparativamente ap√≥s j√° ter recebido um dos valores.\n\n### 5.2. Procedimentos Espec√≠ficos\n*   **Gatilho:** Qualquer men√ß√£o a procedimentos (Implante Hormonal, Reposi√ß√£o Vitamina D/B12, Semaglutida, Mounjaro, Testosterona, Nandrolona, Infus√£o de Ferro, Protocolo Venoso, Tratamentos Endocrinol√≥gicos, etc.). **Este fluxo tem prioridade sobre consultas.**\n*   **Resposta Padr√£o:** \"Para maiores informa√ß√µes sobre o procedimento [nome do procedimento, se identificado], vou lhe encaminhar para o nosso time respons√°vel.\"\n*   **Valor da Infus√£o de Ferro:** SOMENTE se perguntado explicitamente pelo valor da *infus√£o de ferro*, informe: \"O valor da infus√£o de ferro √© R$ 300,00 (cr√©dito/d√©bito) ou R$ 292,00 (dinheiro/PIX).\" Ap√≥s informar, siga com a resposta padr√£o de encaminhamento.\n*   **Outros Valores:** Para outros procedimentos, **N√ÉO** informe valores. Diga que a avalia√ß√£o em consulta √© necess√°ria ou que o time respons√°vel informar√°.\n*   **Coleta de Nome e Encaminhamento:** Siga o fluxo da se√ß√£o 5.3.\n\n### 5.3. Fluxo de Agendamento/Encaminhamento\n1.  **Oferecer Agendamento:** Ap√≥s explicar consulta ou procedimento (e se `status_agendamento == \"n√£o_iniciado\"`), pergunte: \"Vamos agendar sua consulta?\" ou similar para procedimentos.\n2.  **Confirma√ß√£o do Usu√°rio:** Aguarde confirma√ß√£o expl√≠cita (\"sim\", \"quero\", \"pode ser\", \"gostaria\").\n3.  **Verificar/Coletar Nome:**\n    *   Verifique o hist√≥rico (`primeiro_nome`).\n    *   Se **N√ÉO** tiver o nome: Pe√ßa \"Perfeito! Para que eu possa realizar o encaminhamento, poderia me informar seu nome?\". Atualize `primeiro_nome` quando receber.\n    *   Se **J√Å** tiver o nome: Pule para o passo 4.\n4.  **Confirmar Encaminhamento:**\n    *   Atualize `status_agendamento = \"conclu√≠do\"`.\n    *   Informe: \"[Nome do usu√°rio], estou encaminhando sua solicita√ß√£o para agendamento de [consulta tipo X / procedimento Y] ao setor respons√°vel. Voc√™ receber√° um retorno em breve para confirmar os detalhes. Qualquer d√∫vida, estou √† disposi√ß√£o. Muito obrigada!\" (Adapte a parte \"consulta/procedimento\" conforme o contexto).\n*   **Importante:** **NUNCA** realize o agendamento diretamente. Sempre informe que ser√° *encaminhado*. O agendamento √© feito pelo WhatsApp (n√£o informe outros canais, a menos que perguntem).\n\n### 5.4. Informa√ß√µes Adicionais\n*   **Endere√ßo:** Se perguntado, forne√ßa ambos:\n    *   Unidade 1 - Centro: Rua 16 de Mar√ßo, 155, Sala 704 (Galeria Gelli), Petr√≥polis - RJ.\n    *   Unidade 2 - Itaipava: Estrada Uni√£o Ind√∫stria, 10337, Sala 139, Itaipava Center, Petr√≥polis - RJ. (Ref: Emporium Multimix).\n    *   Pergunte: \"Onde voc√™ prefere?\". Armazene em `unidade_escolhida`. Se escolherem, confirme (\"Perfeito.\") e prossiga oferecendo agendamento, se aplic√°vel.\n*   **Valores (Regra Geral):** **CR√çTICO:** **NUNCA** informe valores (consultas ou procedimentos) a menos que o usu√°rio pergunte **explicitamente** usando termos como \"valor\", \"pre√ßo\", \"custa\", \"quanto custa\". Verifique isso antes de CADA resposta que possa conter um pre√ßo.\n*   **Formas de Pagamento:** Mencione **SOMENTE** se o usu√°rio perguntar especificamente sobre pagamento ou parcelamento.\n*   **Planos/Conv√™nios:** Informe que **N√ÉO** s√£o aceitos, **SOMENTE** se o usu√°rio perguntar.\n*   **Consulta de Retorno:** Informe que a cl√≠nica **N√ÉO** trabalha com consulta de retorno, **SOMENTE** se perguntado.\n*   **Falar com a Dra.:** Informe que o recado ser√° passado.\n*   **Especialidade:** Responda sobre a cl√≠nica (Endocrinologia, etc.), n√£o sobre voc√™. \n\n## 6. Influ√™ncia do `status_agendamento` nas Respostas\n*   **Verifica√ß√£o Cont√≠nua:** Antes de responder sobre consultas, procedimentos ou valores, verifique o `status_agendamento`.\n*   **Se `status_agendamento == \"em_andamento\"`:** N√ÉO pergunte \"Vamos agendar?\". Adapte a resposta para algo como: \"Continuamos com seu agendamento em andamento. H√° mais alguma informa√ß√£o que gostaria de saber?\".\n*   **Se `status_agendamento == \"conclu√≠do\"`:** N√ÉO pergunte \"Vamos agendar?\". Adapte a resposta para algo como: \"J√° estamos com seu agendamento encaminhado. Voc√™ receber√° um retorno em breve para confirmar os detalhes. Qualquer d√∫vida, estou √† disposi√ß√£o. Muito obrigada!\". Se perguntarem valor *ap√≥s* o encaminhamento, forne√ßa o valor correspondente ao `tipo_consulta` ou `procedimento_solicitado` (se aplic√°vel, como Infus√£o de Ferro) e repita a frase de confirma√ß√£o do encaminhamento.\n\n## 7. Condi√ß√µes M√©dicas e Especialidades\n*   **Men√ß√£o a Condi√ß√µes M√©dicas:** Se o usu√°rio mencionar uma condi√ß√£o m√©dica (hipotiroidismo, diabetes, obesidade, etc.):\n    1. **N√ÉO** fa√ßa coment√°rios √≥bvios sobre a especialidade (\"A especialidade que trata X √© Y\").\n    2. **N√ÉO** explique ou d√™ detalhes sobre a condi√ß√£o m√©dica.\n\n## 8. Verifica√ß√£o Final (OBRIGAT√ìRIA antes de enviar CADA resposta)\n1.  **Apresenta√ß√£o na Primeira Mensagem:** Se esta √© a primeira intera√ß√£o da conversa, CONFIRME que a mensagem come√ßa com \"Ol√°, sou Ana, da equipe da Dra. Cristiane üòä.\" Se n√£o come√ßar assim, ADICIONE esta apresenta√ß√£o no in√≠cio.\n2.  **Apresenta√ß√£o em Mensagens Subsequentes:** Se N√ÉO √© a primeira intera√ß√£o e a resposta cont√©m \"sou Ana\" ou qualquer forma de apresenta√ß√£o, **REMOVA** a apresenta√ß√£o.\n3.  **Pre√ßos:** A resposta cont√©m valor/pre√ßo? O usu√°rio perguntou **explicitamente** por ele nesta intera√ß√£o ou na imediatamente anterior? Se n√£o, **REMOVA** o pre√ßo. **Importante:** **NUNCA** informe os valores das duas modalidades juntos, a menos que o usu√°rio pergunte comparativamente ou ap√≥s j√° ter recebido um dos valores. (Exemplo: Qual diferen√ßa de valor? A consulta presencial tem valor de R$ 550,00 j√° a consulta online de R$ 700,00). Tamb√©m N√ÉO ofere√ßa informar o valor, informe apenas se o usu√°rio solicitar.\n4.  **Nome:** A resposta pede o nome? O nome j√° consta no hist√≥rico? VERIFIQUE em <memory_reference>. Se sim, **REMOVA** o pedido de nome e use o nome existente se apropriado. \n5.  **Duplica√ß√£o:** A resposta repete informa√ß√µes **id√™nticas** ou quase id√™nticas j√° presentes no hist√≥rico recente (ex: mesma explica√ß√£o de consulta online, mesmo valor)? Se sim, **REMOVA** a parte repetida.\n6.  **Men√ß√£o √† Dra. Luiza:** A resposta menciona a Dra. Luiza? O usu√°rio perguntou especificamente sobre ela ou por \"outros m√©dicos\"? Se n√£o, **REMOVA** qualquer men√ß√£o √† Dra. Luiza.\n\n## 9. Ferramentas e Sistema\n\n*   **Contexto:** Use `memory_reference` (hist√≥rico de conversas) e `rag_reference` (informa√ß√£o externa).\n*   **Prioridade:** Estas instru√ß√µes **SEMPRE** prevalecem sobre informa√ß√µes do `rag_reference`.\n*   **Informa√ß√£o do Sistema:** Considere a data/hora atual.\n\n<system_instruction>\n  <memory_reference>{{ $('Core Input').item.json.body.mapping.parseJson().system.conversations_id }}</memory_reference>\n</system_instruction>\n\n<system_information>\n1. Data e hora atuais: {{ $now.format(\"EEE, MMM dd, yyyy, HH:mm\") }}\n</system_information>\n\n<retrieval_augmented_generation_result>\n{{ $json.body.rag_return }}\n</retrieval_augmented_generation_result>",
          "passthroughBinaryImages": true
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [
        320,
        48
      ],
      "id": "abafc92b-8f8d-411c-93b8-b5fc0c792184",
      "name": "Main Agent",
      "retryOnFail": false
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        688,
        48
      ],
      "id": "937b21af-2b10-490a-ab62-e4397e9353e0",
      "name": "No Operation 2"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "nome do agente",
        "responseMode": "lastNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -96,
        48
      ],
      "id": "dab262d5-de3c-4ada-8d2e-d5284ec6f306",
      "name": "Core Input",
      "webhookId": "8fa62fe7-ead5-42f7-833f-dd7c6eab0b13"
    },
    {
      "parameters": {
        "model": "={{ $json.body.mapping.parseJson().system.model }}",
        "options": {
          "temperature": 0.2,
          "topP": 0.9
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        32,
        480
      ],
      "id": "405bc1f4-ee00-40f6-b43a-a001399a1352",
      "name": "OpenRouter",
      "credentials": {
        "openRouterApi": {
          "id": "6a7OLAi8teUd9jSw",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 1020,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -160,
        -64
      ],
      "id": "b2a4e890-57ce-4c44-b318-df20437e8221",
      "name": "Sticky Note5"
    },
    {
      "parameters": {
        "content": "Fluxo Core, respons√°vel pelo processamento da AI",
        "height": 80,
        "width": 260,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -128,
        -96
      ],
      "id": "eadb59f4-f7fc-4f30-8248-1e5d25c9466c",
      "name": "Sticky Note14"
    },
    {
      "parameters": {
        "name": "restart_history",
        "description": "=Invoque essa tool para iniciar uma nova conversa para o user, assim ignorando o hist√≥rico passado. Apenas quando o user solicitar.",
        "jsCode": "const axios = require('axios');\n\n// Converte o mapeamento recebido em JSON\nconst mapping = JSON.parse($('Core Input').item.json.body.mapping);\n\n// Verifica se o usu√°rio √© admin; caso contr√°rio, retorna erro\nif (mapping.system.user_type !== 'admin') {\n  return JSON.stringify({ success: false, error: \"Acesso negado: usu√°rio n√£o autorizado.\" });\n}\n\n/**\n * Fun√ß√£o que espera pelo tempo especificado.\n * @param {number} ms - Milissegundos a aguardar.\n * @returns {Promise<void>}\n */\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n/**\n * Fun√ß√£o para enviar a requisi√ß√£o para criar uma conversa no Directus.\n * Tenta at√© 3 vezes em caso de falha, com delay de 1 segundo entre as tentativas.\n * @returns {Promise<object>} - Objeto com sucesso ou erro.\n */\nasync function sendRequest() {\n  const url = `http://${mapping.system.directus_service}:8055/items/conversations`;\n  const data = {\n    user_id: mapping.chatwoot.contact_id,\n    date_created: new Date().toISOString()\n  };\n  const headers = {\n    Authorization: `Bearer ${mapping.system.directus_token}`,\n    'Content-Type': 'application/json'\n  };\n\n  let attempt = 0;\n  let lastError = null;\n\n  while (attempt < 3) {\n    try {\n      const response = await axios.post(url, data, { headers });\n      console.log(`Requisi√ß√£o realizada com sucesso na tentativa ${attempt + 1}.`);\n      return { success: true, data: response.data };\n    } catch (error) {\n      attempt++;\n      lastError = error;\n      console.error(`Tentativa ${attempt} falhou:`, error.response ? error.response.data : error.message);\n      if (attempt < 3) {\n        console.log(\"Aguardando 1 segundo antes da nova tentativa...\");\n        await delay(1000);\n      }\n    }\n  }\n  \n  return { success: false, error: lastError.response ? lastError.response.data : lastError.message };\n}\n\nreturn sendRequest().then(result => JSON.stringify(result));"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        320,
        304
      ],
      "id": "1d85bf0e-6cb3-4e9b-88b5-89da20a875fe",
      "name": "Restart History"
    },
    {
      "parameters": {
        "name": "set_timer",
        "description": "Invoque essa tool para configurar um timer que iniciar√° uma a√ß√£o ap√≥s o tempo especificado. Apenas usu√°rios admin podem usar essa tool. O tempo deve ser informado com valor e unidade (s, m, h). Apenas quando o user solicitar.",
        "jsCode": "const axios = require('axios');\nconst dayjs = require('dayjs');\nconst duration = require('dayjs/plugin/duration');\ndayjs.extend(duration);\n\n/**\n * Esta tool configura um timer via webhook.\n * Ela envia, para o endpoint, todo o objeto mapping (obtido em Core Input)\n * e o tempo em segundos calculado a partir dos par√¢metros \"timer_value\" e \"timer_unit\".\n * Apenas usu√°rios admin podem utilizar esta tool.\n */\n\n// Converte o mapping recebido em JSON\nconst mapping = JSON.parse($('Core Input').item.json.body.mapping);\n\n// Verifica se o usu√°rio √© admin\nif (mapping.system.user_type !== 'admin') {\n  return JSON.stringify({ success: false, error: \"Acesso negado: usu√°rio n√£o autorizado.\" });\n}\n\n// Obt√©m os par√¢metros do timer a partir do input (query)\nconst timerValue = query.timer_value;  // N√∫mero (ex: 30)\nconst timerUnit = query.timer_unit;      // \"s\", \"m\" ou \"h\"\n\n// Calcula o tempo em segundos usando dayjs.duration\nconst timerSeconds = dayjs.duration(timerValue, timerUnit).asSeconds();\n\n// Prepara o payload para o webhook\nconst payload = {\n  mapping: mapping,\n  timer_seconds: timerSeconds\n};\n\n// URL do webhook substituindo 'n8n_webhook' pelo valor da vari√°vel no mapping\nconst url = `http://${mapping.system.n8n_webhook_service}:5678/webhook/timer`;\n\n/**\n * Fun√ß√£o para enviar a requisi√ß√£o ao webhook.\n * Tenta enviar uma √∫nica vez e retorna o resultado.\n */\nasync function sendTimerRequest() {\n  try {\n    console.log(`Enviando requisi√ß√£o para configurar o timer para ${timerSeconds} segundos...`);\n    const response = await axios.post(url, payload, {\n      headers: { 'Content-Type': 'application/json' }\n    });\n    console.log(\"Timer configurado com sucesso.\");\n    return { success: true, message: `Timer configurado com sucesso. Ele ser√° acionado em ${timerSeconds} segundos.` };\n  } catch (error) {\n    console.error(\"Erro ao configurar o timer:\", error.response ? error.response.data : error.message);\n    return { success: false, error: error.response ? error.response.data : error.message };\n  }\n}\n\nreturn sendTimerRequest().then(result => JSON.stringify(result));",
        "specifyInputSchema": true,
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"timer_value\": {\n      \"type\": \"number\",\n      \"description\": \"Valor do timer. Exemplo: 30\"\n    },\n    \"timer_unit\": {\n      \"type\": \"string\",\n      \"description\": \"Unidade de tempo para o timer: 's' para segundos, 'm' para minutos, 'h' para horas.\",\n      \"enum\": [\"s\", \"m\", \"h\"]\n    }\n  },\n  \"required\": [\"timer_value\", \"timer_unit\"]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        448,
        304
      ],
      "id": "68c8ffc5-d5a2-402f-bfc1-59a299a5bdfc",
      "name": "Set Timer"
    },
    {
      "parameters": {
        "name": "GoogleCalendarManager",
        "description": "=Complete tool for Google Calendar management with support for flexible time references. Create, update, delete, or query events using intuitive time specifications and offsets.",
        "jsCode": "// =========================================================\n// CONFIGURA√á√ïES CUSTOMIZ√ÅVEIS\n// =========================================================\nconst CONFIG = {\n  maxAppointmentsPerEmail: -1,    // -1 para desativar, 1 para um agendamento por email\n  daysToCheck: 30,               // Per√≠odo para verificar agendamentos\n  timezone: 'America/Sao_Paulo', // Fuso hor√°rio padr√£o\n  restrictByEmail: true,         // Se true, requer email para todas opera√ß√µes\n  defaultDuration: 60            // Dura√ß√£o padr√£o em minutos\n};\n\n// Obter credenciais do sistema\nconst inputMapping = $('Core Input').item.json.body.mapping;\nconst systemData = JSON.parse(inputMapping).system;\nconst credentials = {\n  accessToken: systemData.accessToken,\n  refreshToken: systemData.refreshToken,\n  clientId: systemData.clientId,\n  clientSecret: systemData.clientSecret,\n  directusToken: systemData.directus_token,\n  directusService: systemData.directus_service\n};\n\n// Input do usu√°rio e array de logs\nconst inputData = query;\nconst logs = [];\n\n// Configura√ß√£o do dayjs\nconst dayjs = require('dayjs');\nconst utc = require('dayjs/plugin/utc');\nconst timezone = require('dayjs/plugin/timezone');\nconst weekday = require('dayjs/plugin/weekday');\nconst isoWeek = require('dayjs/plugin/isoWeek');\nconst dayOfYear = require('dayjs/plugin/dayOfYear');\nconst quarterOfYear = require('dayjs/plugin/quarterOfYear');\nconst customParseFormat = require('dayjs/plugin/customParseFormat');\nconst isBetween = require('dayjs/plugin/isBetween');\n\n// Configurar plugins do dayjs\ndayjs.extend(utc);\ndayjs.extend(timezone);\ndayjs.extend(weekday);\ndayjs.extend(isoWeek);\ndayjs.extend(dayOfYear);\ndayjs.extend(quarterOfYear);\ndayjs.extend(customParseFormat);\ndayjs.extend(isBetween);\n\n// Configurar timezone\ndayjs.tz.setDefault(CONFIG.timezone);\n\n// =========================================================\n// FUN√á√ïES AUXILIARES\n// =========================================================\n\n// Fun√ß√£o para logging\nfunction log(message, data = null) {\n  const entry = {\n    timestamp: new Date().toISOString(),\n    message\n  };\n  \n  if (data) {\n    if (typeof data === 'string' && data.length > 200) {\n      entry.data = data.substring(0, 200) + '... (truncado)';\n    } else if (typeof data === 'object') {\n      const stringified = JSON.stringify(data);\n      entry.data = stringified.length > 200 \n        ? JSON.stringify(data).substring(0, 200) + '... (truncado)' \n        : data;\n    } else {\n      entry.data = data;\n    }\n  }\n  \n  logs.push(entry);\n}\n\n// Fun√ß√£o para verificar se o email √© obrigat√≥rio e foi fornecido\nfunction validateEmailRequirement() {\n  if (CONFIG.restrictByEmail && !inputData.attendee_email) {\n    throw new Error(\"Email obrigat√≥rio: Quando RESTRICT_OPERATIONS_BY_EMAIL est√° ativado, o campo 'attendee_email' √© obrigat√≥rio\");\n  }\n}\n\n// Fun√ß√£o para renovar o token\nasync function refreshGoogleToken() {\n  log('Renovando token do Google');\n  \n  try {\n    const axios = require('axios');\n    const qs = require('querystring');\n    \n    const response = await axios({\n      method: 'post',\n      url: 'https://oauth2.googleapis.com/token',\n      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n      data: qs.stringify({\n        client_id: credentials.clientId,\n        client_secret: credentials.clientSecret,\n        refresh_token: credentials.refreshToken,\n        grant_type: 'refresh_token'\n      })\n    });\n    \n    const newToken = response.data.access_token;\n    \n    // Atualizar token no Directus\n    await axios({\n      method: 'patch',\n      url: `http://${credentials.directusService}:8055/items/global_vars`,\n      headers: {\n        'Authorization': `Bearer ${credentials.directusToken}`,\n        'Content-Type': 'application/json'\n      },\n      data: { accessToken: newToken }\n    });\n    \n    log('Token renovado e atualizado com sucesso');\n    return newToken;\n  } catch (error) {\n    log('Erro ao renovar token', error.message);\n    throw error;\n  }\n}\n\n// Fun√ß√£o para obter o ID do calend√°rio\nfunction getCalendarId() {\n  return (!inputData.calendar_id || inputData.calendar_id === '') ? 'primary' : inputData.calendar_id;\n}\n\n// Fun√ß√£o para executar opera√ß√µes com renova√ß√£o autom√°tica de token\nasync function executeWithToken(operation) {\n  try {\n    validateEmailRequirement();\n    return await operation(credentials.accessToken);\n  } catch (error) {\n    // Se for erro de token expirado, renovar e tentar novamente\n    if (error.response && error.response.status === 401) {\n      log('Token expirado, renovando e tentando novamente');\n      const newToken = await refreshGoogleToken();\n      const result = await operation(newToken);\n      return {\n        ...result,\n        message: result.message + \" (ap√≥s renova√ß√£o do token)\"\n      };\n    }\n    \n    // Outros erros\n    const errorMsg = error.message || 'Erro desconhecido';\n    let errorType = \"general_error\";\n    \n    if (errorMsg.includes(\"Limite m√°ximo\")) errorType = \"appointment_limit_exceeded\";\n    if (errorMsg.includes(\"Acesso negado\") || errorMsg.includes(\"Email obrigat√≥rio\")) errorType = \"access_denied\";\n    \n    throw { message: errorMsg, errorType };\n  }\n}\n\n// =========================================================\n// PROCESSAMENTO DE TEMPO RELATIVO\n// =========================================================\n\n// Fun√ß√£o para verificar se √© dia √∫til\nfunction isBusinessDay(date) {\n  const dayOfWeek = date.day();\n  return dayOfWeek !== 0 && dayOfWeek !== 6; // 0 = domingo, 6 = s√°bado\n}\n\n// Fun√ß√£o para ajustar para o pr√≥ximo dia √∫til\nfunction adjustToBusinessDay(date) {\n  if (isBusinessDay(date)) return date;\n  return date.day() === 6 ? date.add(2, 'day') : date.add(1, 'day');\n}\n\n// Fun√ß√£o para calcular data/hora a partir de refer√™ncias relativas\nfunction calculateDateTime() {\n  // Se hor√°rios exatos forem fornecidos, us√°-los diretamente\n  if (inputData.exact_start_time) {\n    return {\n      startTime: dayjs(inputData.exact_start_time).tz(CONFIG.timezone),\n      endTime: inputData.exact_end_time \n        ? dayjs(inputData.exact_end_time).tz(CONFIG.timezone)\n        : dayjs(inputData.exact_start_time).tz(CONFIG.timezone).add(inputData.duration_minutes || CONFIG.defaultDuration, 'minute')\n    };\n  }\n\n  // Iniciar com a data/hora base\n  let baseDate = dayjs().tz(CONFIG.timezone);\n  \n  // Aplicar a refer√™ncia temporal base\n  if (inputData.time_reference) {\n    switch (inputData.time_reference) {\n      case 'now': \n        // J√° estamos usando now como base\n        break;\n      case 'today': \n        baseDate = baseDate.startOf('day');\n        break;\n      case 'this_week': \n        baseDate = baseDate.startOf('week');\n        break;\n      case 'this_month': \n        baseDate = baseDate.startOf('month');\n        break;\n      case 'this_quarter': \n        baseDate = baseDate.startOf('quarter');\n        break;\n      case 'this_year': \n        baseDate = baseDate.startOf('year');\n        break;\n    }\n  }\n  \n  // Aplicar deslocamento temporal (offset)\n  if (typeof inputData.offset_value === 'number' && inputData.offset_unit) {\n    baseDate = baseDate.add(inputData.offset_value, inputData.offset_unit);\n  }\n  \n  // Aplicar m√™s do ano, se especificado\n  if (typeof inputData.month_of_year === 'number') {\n    baseDate = baseDate.month(inputData.month_of_year - 1); // Meses em dayjs s√£o 0-11\n  }\n  \n  // Aplicar trimestre do ano, se especificado\n  if (typeof inputData.quarter_of_year === 'number') {\n    const startMonth = (inputData.quarter_of_year - 1) * 3;\n    baseDate = baseDate.month(startMonth).startOf('month');\n  }\n  \n  // Aplicar dia do m√™s\n  if (typeof inputData.day_of_month === 'number') {\n    if (inputData.day_of_month === -1) {\n      baseDate = baseDate.endOf('month').startOf('day');\n    } else {\n      baseDate = baseDate.date(inputData.day_of_month);\n    }\n  }\n  \n  // Aplicar dia da semana e semana do m√™s\n  if (typeof inputData.day_of_week === 'number') {\n    if (typeof inputData.week_of_month === 'number') {\n      // Voltar para o in√≠cio do m√™s atual\n      let monthStart = baseDate.startOf('month');\n      \n      if (inputData.week_of_month === -1) {\n        // √öltima semana do m√™s\n        let monthEnd = baseDate.endOf('month');\n        while (monthEnd.day() !== inputData.day_of_week) {\n          monthEnd = monthEnd.subtract(1, 'day');\n        }\n        baseDate = monthEnd;\n      } else {\n        // Encontrar o primeiro dia da semana especificado no m√™s\n        let firstOccurrence = monthStart.day(inputData.day_of_week);\n        \n        // Se estivermos no m√™s anterior, avan√ßar uma semana\n        if (firstOccurrence.month() !== monthStart.month()) {\n          firstOccurrence = firstOccurrence.add(7, 'day');\n        }\n        \n        // Avan√ßar para a semana espec√≠fica\n        baseDate = firstOccurrence.add((inputData.week_of_month - 1) * 7, 'day');\n      }\n    } else {\n      // Somente dia da semana especificado, ir para o pr√≥ximo\n      baseDate = baseDate.day(inputData.day_of_week);\n      \n      // Se j√° passou esta semana, avan√ßar uma semana\n      if (baseDate.isBefore(dayjs().tz(CONFIG.timezone))) {\n        baseDate = baseDate.add(7, 'day');\n      }\n    }\n  }\n  \n  // Ajustar para dia √∫til se necess√°rio\n  if (inputData.business_days_only === true) {\n    baseDate = adjustToBusinessDay(baseDate);\n  }\n  \n  // Aplicar hora e minuto\n  if (typeof inputData.hour_of_day === 'number') {\n    baseDate = baseDate.hour(inputData.hour_of_day).minute(typeof inputData.minute_of_hour === 'number' ? inputData.minute_of_hour : 0);\n  } else if (typeof inputData.minute_of_hour === 'number') {\n    baseDate = baseDate.minute(inputData.minute_of_hour);\n  }\n  \n  // Se nem hora nem minuto foram especificados, usar hora atual\n  if (typeof inputData.hour_of_day !== 'number' && typeof inputData.minute_of_hour !== 'number') {\n    const now = dayjs().tz(CONFIG.timezone);\n    baseDate = baseDate.hour(now.hour()).minute(now.minute());\n  }\n  \n  // Zerar segundos e milissegundos\n  baseDate = baseDate.second(0).millisecond(0);\n  \n  // Calcular hora de t√©rmino (in√≠cio + dura√ß√£o)\n  const duration = inputData.duration_minutes || CONFIG.defaultDuration;\n  const endDate = baseDate.add(duration, 'minute');\n  \n  log('Data/hora calculada', {\n    start: baseDate.format(),\n    end: endDate.format()\n  });\n  \n  return {\n    startTime: baseDate,\n    endTime: endDate\n  };\n}\n\n// =========================================================\n// FUN√á√ïES DE API DO GOOGLE CALENDAR\n// =========================================================\n\n// Cliente HTTP reutiliz√°vel\nconst createClient = (token) => {\n  const axios = require('axios');\n  return {\n    get: (url, params = {}) => axios({\n      method: 'get',\n      url,\n      headers: { 'Authorization': `Bearer ${token}` },\n      params\n    }),\n    post: (url, data) => axios({\n      method: 'post',\n      url,\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      },\n      data\n    }),\n    put: (url, data) => axios({\n      method: 'put',\n      url,\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      },\n      data\n    }),\n    delete: (url) => axios({\n      method: 'delete',\n      url,\n      headers: { 'Authorization': `Bearer ${token}` }\n    })\n  };\n};\n\n// Verificar limite de agendamentos por email\nasync function checkAppointmentsForEmail(token, email, calendarId) {\n  if (CONFIG.maxAppointmentsPerEmail === -1) return 0;\n  \n  log(`Verificando agendamentos para ${email}`);\n  \n  try {\n    const client = createClient(token);\n    const now = new Date();\n    const pastDate = new Date(now);\n    pastDate.setDate(now.getDate() - CONFIG.daysToCheck);\n    \n    const response = await client.get(\n      `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events`,\n      {\n        timeMin: pastDate.toISOString(),\n        timeMax: new Date(now.getTime() + (365 * 24 * 60 * 60 * 1000)).toISOString(),\n        q: email,\n        singleEvents: true\n      }\n    );\n    \n    // Filtrar eventos onde o email √© participante\n    const relevantEvents = response.data.items.filter(event => \n      event.attendees?.some(attendee => attendee.email.toLowerCase() === email.toLowerCase())\n    );\n    \n    log(`Encontrados ${relevantEvents.length} agendamentos para ${email}`);\n    return relevantEvents.length;\n  } catch (error) {\n    log('Erro ao verificar agendamentos', error.message);\n    return 0; // Em caso de erro, n√£o bloqueamos\n  }\n}\n\n// Buscar eventos\nasync function findEvents(token, params) {\n  const { email, eventTitle, calendarId, timeMin, timeMax, maxResults } = params;\n  \n  log(`Buscando eventos ${eventTitle ? `com t√≠tulo \"${eventTitle}\" ` : ''}${email ? `para ${email}` : ''}`);\n  \n  try {\n    const client = createClient(token);\n    \n    // Preparar datas padr√£o se n√£o fornecidas\n    const now = new Date();\n    const defaultPastDate = new Date(now);\n    defaultPastDate.setDate(now.getDate() - CONFIG.daysToCheck);\n    \n    const searchTimeMin = timeMin || defaultPastDate.toISOString();\n    const searchTimeMax = timeMax || new Date(now.getTime() + (365 * 24 * 60 * 60 * 1000)).toISOString();\n    \n    // Termo de busca\n    const queryParam = eventTitle && email ? `${email} ${eventTitle}` : \n                       email ? email : \n                       eventTitle ? eventTitle : '';\n    \n    const response = await client.get(\n      `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events`,\n      {\n        timeMin: searchTimeMin,\n        timeMax: searchTimeMax,\n        q: queryParam,\n        singleEvents: true,\n        maxResults: maxResults || 10\n      }\n    );\n    \n    let events = response.data.items || [];\n    \n    // Filtrar por email se necess√°rio\n    if (CONFIG.restrictByEmail && email) {\n      events = events.filter(event => \n        event.attendees?.some(attendee => attendee.email.toLowerCase() === email.toLowerCase())\n      );\n    }\n    \n    // Filtrar por t√≠tulo se fornecido\n    if (eventTitle) {\n      events = events.filter(event => \n        event.summary && event.summary.toLowerCase().includes(eventTitle.toLowerCase())\n      );\n    }\n    \n    log(`Encontrados ${events.length} eventos`);\n    return events;\n  } catch (error) {\n    log('Erro ao buscar eventos', error.message);\n    throw error;\n  }\n}\n\n// Buscar evento por ID\nasync function getEventById(token, eventId, calendarId) {\n  log(`Buscando evento com ID: ${eventId}`);\n  \n  try {\n    const client = createClient(token);\n    const response = await client.get(\n      `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events/${encodeURIComponent(eventId)}`\n    );\n    return response.data;\n  } catch (error) {\n    log('Erro ao buscar evento por ID', error.message);\n    throw error;\n  }\n}\n\n// Verificar acesso ao evento\nasync function verifyEventAccess(token, eventId, email, calendarId) {\n  if (!CONFIG.restrictByEmail || !email) return true;\n  \n  const event = await getEventById(token, eventId, calendarId);\n  \n  const isAttendee = event.attendees?.some(attendee => \n    attendee.email.toLowerCase() === email.toLowerCase()\n  );\n  \n  if (!isAttendee) {\n    throw new Error(`Acesso negado: ${email} n√£o √© um participante deste evento`);\n  }\n  \n  return true;\n}\n\n// =========================================================\n// OPERA√á√ïES DO CALEND√ÅRIO\n// =========================================================\n\n// Criar evento\nasync function createEvent(token) {\n  const calendarId = getCalendarId();\n  const { title, description, attendee_email } = inputData;\n  \n  if (!title) {\n    throw new Error(\"Para criar um evento, forne√ßa um t√≠tulo\");\n  }\n  \n  // Calcular hor√°rios\n  const { startTime, endTime } = calculateDateTime();\n  \n  // Verificar limite de agendamentos\n  if (CONFIG.maxAppointmentsPerEmail > 0 && attendee_email) {\n    const count = await checkAppointmentsForEmail(token, attendee_email, calendarId);\n    if (count >= CONFIG.maxAppointmentsPerEmail) {\n      throw new Error(`Limite m√°ximo de ${CONFIG.maxAppointmentsPerEmail} agendamento(s) por email excedido.`);\n    }\n  }\n  \n  // Preparar evento\n  const event = {\n    summary: title,\n    description: description || '',\n    start: {\n      dateTime: startTime.toISOString(),\n      timeZone: CONFIG.timezone\n    },\n    end: {\n      dateTime: endTime.toISOString(),\n      timeZone: CONFIG.timezone\n    }\n  };\n  \n  // Adicionar participante\n  if (attendee_email) {\n    event.attendees = [{\n      email: attendee_email,\n      responseStatus: 'needsAction'\n    }];\n  }\n  \n  // Criar evento\n  log('Criando evento', { title, calendarId });\n  const client = createClient(token);\n  \n  const response = await client.post(\n    `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events`,\n    event\n  );\n  \n  return {\n    success: true,\n    message: \"Evento criado com sucesso\",\n    eventId: response.data.id,\n    eventLink: response.data.htmlLink,\n    startTime: startTime.format(),\n    endTime: endTime.format()\n  };\n}\n\n// Atualizar evento\nasync function updateEvent(token) {\n  const calendarId = getCalendarId();\n  const { event_id, event_title, attendee_email, title, description } = inputData;\n  \n  // Validar dados\n  if (!event_id && !event_title && !attendee_email) {\n    throw new Error(\"Para atualizar um evento, forne√ßa identifica√ß√£o (ID ou t√≠tulo) e email\");\n  }\n  \n  if (!title && !description && !inputData.exact_start_time && !inputData.exact_end_time && \n      !inputData.time_reference && !inputData.day_of_week && !inputData.offset_value) {\n    throw new Error(\"Para atualizar um evento, forne√ßa pelo menos um campo para atualizar\");\n  }\n  \n  // Encontrar o evento\n  let eventId = event_id;\n  \n  if (!eventId) {\n    const events = await findEvents(token, {\n      email: attendee_email,\n      eventTitle: event_title,\n      calendarId\n    });\n    \n    if (events.length === 0) {\n      throw new Error(\"Nenhum evento encontrado com os crit√©rios fornecidos\");\n    }\n    \n    eventId = events[0].id;\n    log(`Usando evento encontrado: ${eventId}`);\n  }\n  \n  // Verificar acesso\n  await verifyEventAccess(token, eventId, attendee_email, calendarId);\n  \n  // Buscar dados atuais\n  const existingEvent = await getEventById(token, eventId, calendarId);\n  \n  // Calcular novos hor√°rios se necess√°rio\n  let startDateTime = dayjs(existingEvent.start.dateTime || existingEvent.start.date).tz(CONFIG.timezone);\n  let endDateTime = dayjs(existingEvent.end.dateTime || existingEvent.end.date).tz(CONFIG.timezone);\n  \n  // Se temos par√¢metros de tempo, recalcular\n  if (inputData.exact_start_time || inputData.time_reference || inputData.offset_value || \n      inputData.day_of_week || inputData.hour_of_day) {\n    const { startTime, endTime } = calculateDateTime();\n    startDateTime = startTime;\n    endDateTime = endTime;\n  }\n  \n  // Preparar atualiza√ß√µes\n  const updatedEvent = {\n    ...existingEvent,\n    summary: title || existingEvent.summary,\n    description: description !== undefined ? description : existingEvent.description,\n    start: {\n      dateTime: startDateTime.toISOString(),\n      timeZone: CONFIG.timezone\n    },\n    end: {\n      dateTime: endDateTime.toISOString(),\n      timeZone: CONFIG.timezone\n    }\n  };\n  \n  // Adicionar novo participante\n  if (attendee_email && !existingEvent.attendees?.some(a => a.email.toLowerCase() === attendee_email.toLowerCase())) {\n    updatedEvent.attendees = [\n      ...(existingEvent.attendees || []),\n      { email: attendee_email, responseStatus: 'needsAction' }\n    ];\n  }\n  \n  // Atualizar evento\n  log('Atualizando evento', { eventId });\n  const client = createClient(token);\n  \n  const response = await client.put(\n    `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events/${encodeURIComponent(eventId)}`,\n    updatedEvent\n  );\n  \n  return {\n    success: true,\n    message: \"Evento atualizado com sucesso\",\n    eventId: response.data.id,\n    eventLink: response.data.htmlLink,\n    startTime: startDateTime.format(),\n    endTime: endDateTime.format()\n  };\n}\n\n// Deletar evento\nasync function deleteEvent(token) {\n  const calendarId = getCalendarId();\n  const { event_id, event_title, attendee_email } = inputData;\n  \n  if (!event_id && !event_title && !attendee_email) {\n    throw new Error(\"Para deletar um evento, forne√ßa o ID do evento ou crit√©rios de busca (t√≠tulo e/ou email)\");\n  }\n  \n  // Encontrar o evento\n  let eventId = event_id;\n  let eventSummary;\n  \n  if (!eventId) {\n    const events = await findEvents(token, {\n      email: attendee_email,\n      eventTitle: event_title,\n      calendarId\n    });\n    \n    if (events.length === 0) {\n      throw new Error(\"Nenhum evento encontrado com os crit√©rios fornecidos\");\n    }\n    \n    eventId = events[0].id;\n    eventSummary = events[0].summary;\n  } else {\n    // Verificar acesso por ID\n    const event = await getEventById(token, eventId, calendarId);\n    eventSummary = event.summary;\n    await verifyEventAccess(token, eventId, attendee_email, calendarId);\n  }\n  \n  // Deletar evento\n  log(`Deletando evento: ${eventId}`);\n  const client = createClient(token);\n  \n  await client.delete(\n    `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events/${encodeURIComponent(eventId)}`\n  );\n  \n  return {\n    success: true,\n    message: \"Evento deletado com sucesso\",\n    eventId,\n    eventSummary\n  };\n}\n\n// Consultar eventos\nasync function queryEvents(token) {\n  const calendarId = getCalendarId();\n  const { attendee_email, event_title, time_min, time_max, max_results } = inputData;\n  \n  // Buscar eventos\n  const events = await findEvents(token, {\n    email: attendee_email,\n    eventTitle: event_title,\n    calendarId,\n    timeMin: time_min,\n    timeMax: time_max,\n    maxResults: max_results\n  });\n  \n  // Simplificar eventos para o retorno\n  const simplifiedEvents = events.map(event => ({\n    id: event.id,\n    title: event.summary,\n    description: event.description,\n    start_time: event.start?.dateTime || event.start?.date,\n    end_time: event.end?.dateTime || event.end?.date,\n    attendees: event.attendees?.map(att => att.email) || [],\n    htmlLink: event.htmlLink\n  }));\n  \n  return {\n    success: true,\n    message: `${events.length} evento(s) encontrado(s)`,\n    count: events.length,\n    events: simplifiedEvents\n  };\n}\n\n// =========================================================\n// EXECU√á√ÉO PRINCIPAL\n// =========================================================\n\nasync function execute() {\n  try {\n    // Verificar opera√ß√£o v√°lida\n    const operations = {\n      'create': createEvent,\n      'update': updateEvent,\n      'delete': deleteEvent,\n      'query': queryEvents\n    };\n    \n    if (!inputData.operation || !operations[inputData.operation]) {\n      throw new Error(\"Opera√ß√£o inv√°lida. Use 'create', 'update', 'delete' ou 'query'\");\n    }\n    \n    // Executar com tratamento de token\n    const result = await executeWithToken(operations[inputData.operation]);\n    \n    return JSON.stringify({\n      ...result,\n      logs\n    });\n  } catch (error) {\n    return JSON.stringify({\n      success: false,\n      message: error.message || \"Erro desconhecido\",\n      errorType: error.errorType || \"general_error\",\n      logs\n    });\n  }\n}\n\n// Iniciar execu√ß√£o\nreturn execute();",
        "specifyInputSchema": true,
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"operation\": {\n      \"type\": \"string\",\n      \"enum\": [\"create\", \"update\", \"delete\", \"query\"],\n      \"description\": \"Opera√ß√£o a ser realizada: criar, atualizar, deletar ou consultar eventos\"\n    },\n    \"title\": {\n      \"type\": \"string\",\n      \"description\": \"T√≠tulo do evento (obrigat√≥rio para cria√ß√£o e atualiza√ß√£o)\"\n    },\n    \"description\": {\n      \"type\": \"string\",\n      \"description\": \"Descri√ß√£o do evento (opcional)\"\n    },\n    \"calendar_id\": {\n      \"type\": \"string\",\n      \"description\": \"ID do calend√°rio (opcional, usa o calend√°rio prim√°rio por padr√£o)\"\n    },\n    \"attendee_email\": {\n      \"type\": \"string\",\n      \"description\": \"Email do participante/cliente (obrigat√≥rio se RESTRICT_OPERATIONS_BY_EMAIL=true)\"\n    },\n    \"event_id\": {\n      \"type\": \"string\",\n      \"description\": \"ID do evento (para atualiza√ß√£o/dele√ß√£o)\"\n    },\n    \"event_title\": {\n      \"type\": \"string\",\n      \"description\": \"T√≠tulo do evento a ser encontrado (para dele√ß√£o/atualiza√ß√£o)\"\n    },\n    \"exact_start_time\": {\n      \"type\": \"string\",\n      \"description\": \"Hor√°rio exato de in√≠cio no formato ISO (alternativa aos par√¢metros relativos)\"\n    },\n    \"exact_end_time\": {\n      \"type\": \"string\",\n      \"description\": \"Hor√°rio exato de t√©rmino no formato ISO (alternativa aos par√¢metros relativos)\"\n    },\n    \"time_reference\": {\n      \"type\": \"string\",\n      \"enum\": [\"now\", \"today\", \"this_week\", \"this_month\", \"this_quarter\", \"this_year\"],\n      \"description\": \"Ponto de refer√™ncia temporal base\"\n    },\n    \"offset_value\": {\n      \"type\": \"integer\",\n      \"description\": \"Deslocamento temporal (positivo=futuro, negativo=passado)\"\n    },\n    \"offset_unit\": {\n      \"type\": \"string\",\n      \"enum\": [\"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\"],\n      \"description\": \"Unidade do deslocamento temporal\"\n    },\n    \"day_of_week\": {\n      \"type\": \"integer\",\n      \"enum\": [0, 1, 2, 3, 4, 5, 6],\n      \"description\": \"Dia da semana (0=domingo, 1=segunda, ..., 6=s√°bado)\"\n    },\n    \"week_of_month\": {\n      \"type\": \"integer\",\n      \"enum\": [1, 2, 3, 4, 5, -1],\n      \"description\": \"Semana do m√™s (1=primeira, 2=segunda, ..., -1=√∫ltima)\"\n    },\n    \"day_of_month\": {\n      \"type\": \"integer\",\n      \"minimum\": -1,\n      \"maximum\": 31,\n      \"description\": \"Dia espec√≠fico do m√™s (1-31, ou -1 para √∫ltimo dia)\"\n    },\n    \"month_of_year\": {\n      \"type\": \"integer\",\n      \"enum\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],\n      \"description\": \"M√™s do ano (1-12)\"\n    },\n    \"quarter_of_year\": {\n      \"type\": \"integer\",\n      \"enum\": [1, 2, 3, 4],\n      \"description\": \"Trimestre do ano (1-4)\"\n    },\n    \"business_days_only\": {\n      \"type\": \"boolean\",\n      \"description\": \"Se verdadeiro, ajusta para o pr√≥ximo dia √∫til se cair em fim de semana\"\n    },\n    \"hour_of_day\": {\n      \"type\": \"integer\",\n      \"minimum\": 0,\n      \"maximum\": 23,\n      \"description\": \"Hora do dia (0-23)\"\n    },\n    \"minute_of_hour\": {\n      \"type\": \"integer\",\n      \"minimum\": 0,\n      \"maximum\": 59,\n      \"description\": \"Minuto da hora (0-59)\"\n    },\n    \"duration_minutes\": {\n      \"type\": \"integer\",\n      \"minimum\": 1,\n      \"description\": \"Dura√ß√£o do evento em minutos (para calcular automaticamente o hor√°rio de t√©rmino)\"\n    },\n    \"time_min\": {\n      \"type\": \"string\",\n      \"description\": \"Data m√≠nima para consulta (ISO)\"\n    },\n    \"time_max\": {\n      \"type\": \"string\",\n      \"description\": \"Data m√°xima para consulta (ISO)\"\n    },\n    \"max_results\": {\n      \"type\": \"number\",\n      \"description\": \"N√∫mero m√°ximo de resultados na consulta\"\n    }\n  },\n  \"required\": [\"operation\"]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        560,
        304
      ],
      "id": "9d11a941-651c-4a90-90fe-420ad9abd47a",
      "name": "GoogleCalendarManager"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1",
          "mode": "list",
          "cachedResultName": "gpt-4.1"
        },
        "options": {
          "temperature": 0.4,
          "topP": 0.8
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        80,
        304
      ],
      "id": "6c675ca6-94c6-41e6-8879-02ee11027bf3",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "M1iyy6bYZ8SwaoAS",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.toolThink",
      "typeVersion": 1,
      "position": [
        688,
        304
      ],
      "id": "d423af6e-9ae5-462e-a03b-332da89e01d8",
      "name": "Think"
    },
    {
      "parameters": {
        "jsCode": "// Obt√©m todos os itens de entrada\nconst items = $input.all();\n\n// Filtra os itens, mantendo apenas aqueles cujo campo body.content n√£o cont√©m apenas emojis\nconst filteredItems = items.filter(item => {\n  // Acessa o campo content dentro de body\n  const content = item.json.body && item.json.body.content ? item.json.body.content : '';\n  \n  // Se o conte√∫do estiver vazio, bloquear\n  if (!content) {\n    return false;\n  }\n  \n  // Regex expandida para detectar emojis, incluindo cora√ß√µes, estrelas e outros s√≠mbolos\n  const emojiRegex = /[\\u{1F000}-\\u{1FFFF}\\u{2600}-\\u{26FF}\\u{2700}-\\u{27BF}\\u{FE00}-\\u{FE0F}\\u{2B50}]/u;\n  \n  // Remove emojis do conte√∫do\n  const textWithoutEmojis = content.replace(emojiRegex, '');\n  \n  // Remove espa√ßos, pontua√ß√£o e outros caracteres n√£o alfanum√©ricos\n  const cleanText = textWithoutEmojis.replace(/[^\\w]/g, '').trim();\n  \n  // Retorna true (mant√©m o item) se houver texto al√©m de emojis ou se n√£o houver emojis\n  return cleanText.length > 0 || !emojiRegex.test(content);\n});\n\n// Retorna os itens filtrados\nreturn filteredItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        128,
        48
      ],
      "id": "6eadcc12-aad3-4065-9e22-cdbd9f2ca1e7",
      "name": "Code - Filtra Emoji"
    }
  ],
  "connections": {
    "Memory": {
      "ai_memory": [
        [
          {
            "node": "Main Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Main Agent": {
      "main": [
        [
          {
            "node": "No Operation 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Core Input": {
      "main": [
        [
          {
            "node": "Code - Filtra Emoji",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restart History": {
      "ai_tool": [
        [
          {
            "node": "Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Set Timer": {
      "ai_tool": [
        [
          {
            "node": "Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "GoogleCalendarManager": {
      "ai_tool": [
        [
          {
            "node": "Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Main Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Think": {
      "ai_tool": [
        [
          {
            "node": "Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Code - Filtra Emoji": {
      "main": [
        [
          {
            "node": "Main Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {},
  "staticData": null,
  "meta": null,
  "pinData": {},
  "versionId": "9dc2b745-6da4-4632-a801-3698396d771c",
  "triggerCount": 1,
  "tags": [],
  "shared": [
    {
      "updatedAt": "2025-09-09T12:45:31.270Z",
      "createdAt": "2025-09-09T12:45:31.270Z",
      "role": "workflow:owner",
      "workflowId": "tA5l5BEwRDEmjShb",
      "projectId": "9dBYDF0pVXjCehV4",
      "project": {
        "updatedAt": "2025-09-04T11:50:59.428Z",
        "createdAt": "2025-09-03T20:20:03.833Z",
        "id": "9dBYDF0pVXjCehV4",
        "name": "Fabio Antonio <fabio.inves@yahoo.com.br>",
        "type": "personal",
        "icon": null,
        "description": null
      }
    }
  ]
}