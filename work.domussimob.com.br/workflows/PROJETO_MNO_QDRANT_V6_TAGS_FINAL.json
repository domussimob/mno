{
  "createdAt": "2025-09-09T12:45:22.280Z",
  "updatedAt": "2025-09-09T19:11:21.207Z",
  "id": "zOejRcE9WI9ygBOM",
  "name": "PROJETO_MNO_QDRANT_V6_TAGS_FINAL",
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('Core Input').item.json.body.mapping.parseJson().system.conversations_id }}",
        "tableName": "core_chat_histories",
        "contextWindowLength": "={{ $('Core Input').item.json.body.mapping.parseJson().system.context_window }}"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1.3,
      "position": [
        2592,
        1104
      ],
      "id": "40b90385-df95-4d04-8ff9-1ca638baa5b5",
      "name": "Memory",
      "credentials": {
        "postgres": {
          "id": "Iz6AdCvM8BbJ72YV",
          "name": "Postgres directus95b506d"
        }
      }
    },
    {
      "parameters": {
        "content": "",
        "width": 700,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        2400,
        1072
      ],
      "typeVersion": 1,
      "id": "3c083ad8-6b35-49bb-ae1b-2124b09f6722",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.body.content || ' ' }}",
        "options": {
          "systemMessage": "=You are a helpful assistant\n\nNunca use hiperlinks\n\n<system_information>\n1. Data e hora atuais: {{ $now.format(\"EEE, MMM dd, yyyy, HH:mm\") }}\n</system_information>\n\n<retrieval_augmented_generation_result>\n{{ $json.body.rag_return }}\n</retrieval_augmented_generation_result>",
          "passthroughBinaryImages": true
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [
        2704,
        848
      ],
      "id": "58a2dfd0-e0bf-465a-9b56-39733e3a6944",
      "name": "Main Agent"
    },
    {
      "parameters": {
        "operation": "push",
        "list": "={{ $('Mapping').first().json.chatwoot.contact_id.toString() }}",
        "messageData": "={{ JSON.stringify({\n    'content': $('Mapping').first().json.chatwoot.content,\n    'data_url': $('Mapping').first().json.chatwoot.data_url,\n    'timestamp': $now,\n    'message_id': $('Mapping').first().json.chatwoot.message_id\n}) }}",
        "tail": true
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        1152,
        208
      ],
      "id": "3ac8f6be-416e-4b75-99c2-f69fc80ff7d1",
      "name": "Add to List",
      "credentials": {
        "redis": {
          "id": "fQ3bHz5EOjsxTtAn",
          "name": "Redis  ia1_redis"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "data",
        "key": "={{ $('Mapping').first().json.chatwoot.contact_id.toString() }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        1344,
        208
      ],
      "id": "c8eb4c06-725f-4ea4-9143-efe2e8c75481",
      "name": "Get List",
      "credentials": {
        "redis": {
          "id": "fQ3bHz5EOjsxTtAn",
          "name": "Redis  ia1_redis"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        1744,
        0
      ],
      "id": "acf8fcd9-43b2-4c69-89b9-6334f4e1b042",
      "name": "No Operation"
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "={\n  \"data\": {{ \n    (() => {\n      const sourceNodeName = $('Get Final List 2').isExecuted ? 'Get Final List 2' : $prevNode.name;\n      const data = $(sourceNodeName).first().json.data;\n      const uniqueIds = new Set();\n      const messages = [];\n\n      data.reduce((_, buffer) => {\n        const parsed = JSON.parse(buffer);\n        if (!uniqueIds.has(parsed.message_id)) {\n          uniqueIds.add(parsed.message_id);\n\n          let index = messages.findIndex(msg => msg.message_id > parsed.message_id);\n          if (index === -1) index = messages.length;\n          messages.splice(index, 0, parsed);\n        }\n      }, []);\n\n      return messages.reduce((acc, msg) => {\n        delete msg.message_id;\n        acc.push({ content: msg, loop_reset: true });\n        return acc;\n      }, []);\n\n    })()\n  }}\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2144,
        304
      ],
      "id": "be56dc3b-dc96-4463-aa5e-1c91b465e31a",
      "name": "Parse JSON"
    },
    {
      "parameters": {
        "fieldToSplitOut": "data",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        144,
        832
      ],
      "id": "d21b083f-6460-4ef2-a995-aca6276bec66",
      "name": "Split Itens"
    },
    {
      "parameters": {
        "options": {
          "reset": "={{ $json.loop_reset }}"
        }
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        352,
        832
      ],
      "id": "82ed29af-c484-4eb7-8712-77815144a38a",
      "name": "Loop"
    },
    {
      "parameters": {
        "url": "={{ $json.content.data_url }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        752,
        832
      ],
      "id": "f9bb457e-011e-4b1b-b4eb-3c105ccce852",
      "name": "Download Media"
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 3,
        "output": "={{\n  $binary.data?.fileExtension === 'oga' \n    ? 0 \n    : !$binary.data || ['png', 'jpg', 'jpeg'].includes($binary.data.fileExtension)\n      ? 1 \n      : $binary.data.fileExtension === 'pdf' \n        ? 2 \n        : 3\n}}"
      },
      "id": "eca689c1-ba20-4a6d-a094-64f528378b95",
      "name": "Switch 02",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        944,
        832
      ]
    },
    {
      "parameters": {
        "content": "",
        "height": 600,
        "width": 2300,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        48,
        -96
      ],
      "typeVersion": 1,
      "id": "13422e28-46ff-496b-bfaf-6938653dabdc",
      "name": "Sticky Note1"
    },
    {
      "parameters": {
        "content": "",
        "height": 1360,
        "width": 2340,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        32,
        -128
      ],
      "typeVersion": 1,
      "id": "e94cbfe0-a842-4915-bd64-a92d7ce8afcc",
      "name": "Sticky Note2"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        3072,
        848
      ],
      "id": "47cef875-c8cb-43db-80d6-5e527c047103",
      "name": "No Operation 2"
    },
    {
      "parameters": {
        "operation": "delete",
        "key": "={{ $('Mapping').first().json.chatwoot.contact_id.toString() }}"
      },
      "id": "1aca2cfe-2fd1-4281-a06e-05eb8a4fdeed",
      "name": "Reset List",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        1744,
        832
      ],
      "notesInFlow": false,
      "credentials": {
        "redis": {
          "id": "fQ3bHz5EOjsxTtAn",
          "name": "Redis  ia1_redis"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "data",
        "key": "={{ $('Mapping').first().json.chatwoot.contact_id.toString() }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        1344,
        624
      ],
      "id": "e1f5631a-05d4-48da-89fd-508f423331dc",
      "name": "Get Final List 2",
      "credentials": {
        "redis": {
          "id": "fQ3bHz5EOjsxTtAn",
          "name": "Redis  ia1_redis"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "data",
        "key": "={{ $('Mapping').first().json.chatwoot.contact_id.toString() }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        1952,
        112
      ],
      "id": "0689c7a2-d7ea-4e32-a26b-bffba985b481",
      "name": "Get Final List 1",
      "credentials": {
        "redis": {
          "id": "fQ3bHz5EOjsxTtAn",
          "name": "Redis  ia1_redis"
        }
      }
    },
    {
      "parameters": {
        "operation": "delete",
        "key": "=41"
      },
      "id": "8cdb4415-c2f4-4e69-b5b8-83fbae12f8dc",
      "name": "Reset List 2",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        2144,
        112
      ],
      "notesInFlow": false,
      "credentials": {
        "redis": {
          "id": "fQ3bHz5EOjsxTtAn",
          "name": "Redis  ia1_redis"
        }
      }
    },
    {
      "parameters": {
        "amount": "={{ \n  $('Mapping').first().json.system.cooldown - $now.diffTo(\n    JSON.parse($('Get List').item.json.data.last()).timestamp,\n    'seconds'\n  )\n}}"
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        1744,
        208
      ],
      "id": "c64c1b99-8cff-41fc-ad74-366719568925",
      "name": "Cooldown",
      "webhookId": "094473f7-38b0-4d1b-aef7-3b0755793b03"
    },
    {
      "parameters": {
        "queue": "main-n8n",
        "options": {
          "acknowledge": "executionFinishesSuccessfully",
          "jsonParseBody": true,
          "onlyContent": true
        }
      },
      "type": "n8n-nodes-base.rabbitmqTrigger",
      "typeVersion": 1,
      "position": [
        64,
        112
      ],
      "id": "7f9c16ec-c72d-430f-a904-c7119bd56ef9",
      "name": "Consumer",
      "credentials": {
        "rabbitmq": {
          "id": "MH13jtxmGsiyxoXR",
          "name": "RabbitMQ rabbitmqee8f16a"
        }
      }
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 2,
        "output": "={{ \n  $node[\"Get Final List 2\"].runIndex === 0\n    ? (\n        JSON.parse($('Get Final List 1').first().json.data.last()).timestamp ===\n        JSON.parse($('Get Final List 2').first().json.data.last()).timestamp\n      ) ? 1 : 0\n    : (\n          JSON.parse($('Get Final List 2').all(0, $runIndex - 0).first().json.data.last()).timestamp ===\n          JSON.parse($('Get Final List 2').all(0, $runIndex - 1).first().json.data.last()).timestamp\n      ) ? 1 : 0\n}}"
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        1552,
        720
      ],
      "id": "2d842b49-2668-468e-bb24-73684e7a73bd",
      "name": "Switch 3"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "main",
        "responseMode": "lastNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        2512,
        848
      ],
      "id": "e736981d-e15b-49b9-8f72-175024f8ff0e",
      "name": "Core Input",
      "webhookId": "ac84e6c0-8ef2-4a9a-878c-66ebf9fbecc1"
    },
    {
      "parameters": {
        "model": "={{ $json.body.mapping.parseJson().system.model }}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        2464,
        1104
      ],
      "id": "24f19bea-42ed-4667-9093-5595a38cc4bc",
      "name": "OpenRouter",
      "credentials": {
        "openRouterApi": {
          "id": "6a7OLAi8teUd9jSw",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 860,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        2400,
        752
      ],
      "id": "8e471040-44e9-4115-923b-d969529c7b4c",
      "name": "Sticky Note5"
    },
    {
      "parameters": {
        "content": "",
        "height": 520,
        "width": 900,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        2384,
        720
      ],
      "typeVersion": 1,
      "id": "e2d9b6ef-629d-4279-9b1e-2caffc494fd8",
      "name": "Sticky Note7"
    },
    {
      "parameters": {
        "content": "",
        "height": 700,
        "width": 2300,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        48,
        528
      ],
      "typeVersion": 1,
      "id": "ed613f21-8e0e-46b5-bf4d-63c44fb440f2",
      "name": "Sticky Note6"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "DO $$\nBEGIN\n  IF NOT EXISTS (\n    SELECT 1 \n    FROM ai_agents\n    WHERE account_id = {{ $json.body.account.id }}\n      AND {{ $json.body.inbox.id }} = ANY(string_to_array(inboxes_ids, ',')::int[])\n  ) THEN\n    RAISE EXCEPTION 'Nenhum AI Agent encontrado para a conta % e inbox %', {{ $json.body.account.id }}, {{ $json.body.inbox.id }};\n  END IF;\nEND $$;\n\nWITH\n-- 1) Seleciona o AI Agent associado à conta e à caixa de entrada\nselected_ai AS (\n    SELECT ai.*\n    FROM ai_agents ai\n    WHERE ai.account_id = {{ $json.body.account.id }}\n      AND {{ $json.body.inbox.id }} = ANY(string_to_array(ai.inboxes_ids, ',')::int[])\n    LIMIT 1\n),\n/*\nSeleciona um AI Agent específico baseado no account_id e no inbox.id.\n- Filtra os agentes pela conta (account_id).\n- Converte a string inboxes_ids para array de inteiros e verifica se contém o inbox.id.\n- Retorna apenas um AI Agent (LIMIT 1).\n*/\n\n-- 2) Seleciona as variáveis globais (assume-se que seja um singleton)\nselected_gv AS (\n    SELECT *\n    FROM global_vars\n    LIMIT 1\n),\n/*\nRecupera as variáveis globais da tabela global_vars.\n- Como se assume que há apenas um conjunto de variáveis globais, retorna apenas uma linha (LIMIT 1).\n*/\n\n-- 3) Faz o upsert do usuário: insere se não existir, caso contrário, ignora\nupsert_user AS (\n    INSERT INTO users (id, date_created, picture_url)\n    VALUES ({{ $json.body.sender.id }}, NOW(), '{{ $json.body.sender.avatar }}')\n    ON CONFLICT (id) DO NOTHING\n    RETURNING *\n),\n/*\nInsere um novo usuário na tabela users caso ele ainda não exista.\n- Se o usuário já existir (id conflitante), a inserção é ignorada.\n- Retorna os dados do usuário recém-inserido.\n*/\n\n-- 4) Seleciona o usuário (recém-inserido ou existente)\nfinal_user AS (\n    SELECT * FROM upsert_user\n    UNION\n    SELECT * FROM users\n    WHERE id = {{ $json.body.sender.id }}\n),\n/*\nGarante que o usuário está disponível para os próximos passos.\n- Se o usuário foi inserido no passo anterior (upsert_user), ele é retornado.\n- Caso contrário, seleciona o usuário existente na tabela users.\n- Usa UNION para combinar as duas possibilidades.\n*/\n\n-- 5) Cria uma nova conversa apenas se não existir nenhuma para esse usuário\nmaybe_new_conversation AS (\n    INSERT INTO conversations (id, user_id, date_created)\n    SELECT gen_random_uuid(), final_user.id, NOW()\n    FROM final_user\n    WHERE NOT EXISTS (\n        SELECT 1\n        FROM conversations\n        WHERE user_id = final_user.id\n    )\n    RETURNING *\n),\n/*\nCria uma nova conversa apenas se o usuário ainda não tiver uma.\n- Gera um UUID para a nova conversa.\n- Define a date_created como o timestamp atual.\n- Usa WHERE NOT EXISTS para evitar criar conversas duplicadas para o mesmo usuário.\n- Retorna os dados da conversa recém-criada.\n*/\n\n-- 6) Seleciona a última conversa do usuário (nova ou existente)\nlast_conversation AS (\n    SELECT * FROM maybe_new_conversation\n    UNION\n    SELECT * FROM conversations\n    WHERE user_id = (SELECT id FROM final_user)\n    ORDER BY date_created DESC\n    LIMIT 1\n)\n/*\nSeleciona a última conversa do usuário, seja ela recém-criada ou já existente.\n- Combina os resultados de maybe_new_conversation (se foi criada) com as conversas já existentes.\n- Filtra as conversas pelo user_id correspondente.\n- Ordena por date_created em ordem decrescente para garantir que a mais recente seja selecionada.\n- Retorna apenas a conversa mais recente (LIMIT 1).\n*/\n\n-- 7) Retorna os resultados no formato JSON\nSELECT\n    (SELECT row_to_json(ai) FROM selected_ai ai) AS ai_agents,\n    (SELECT row_to_json(gv) FROM selected_gv gv) AS global_vars,\n    (SELECT row_to_json(final_user) FROM final_user) AS users,\n    (SELECT row_to_json(last_conversation) FROM last_conversation) AS conversations;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        352,
        112
      ],
      "id": "800f1265-3feb-4b5f-8ff2-ea9d8244bd29",
      "name": "Get Vars",
      "credentials": {
        "postgres": {
          "id": "Iz6AdCvM8BbJ72YV",
          "name": "Postgres directus95b506d"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=http://{{ $('Mapping').item.json.system.stirling_pdf_service }}:8080/api/v1/convert/pdf/img",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-API-KEY",
              "value": "={{ $('Mapping').first().json.system.stirling_pdf_key }}"
            },
            {
              "name": "accept",
              "value": "*/*"
            }
          ]
        },
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "name": "imageFormat",
              "value": "jpg"
            },
            {
              "name": "singleOrMultiple",
              "value": "single"
            },
            {
              "name": "colorType",
              "value": "color"
            },
            {
              "name": "dpi",
              "value": "80"
            },
            {
              "parameterType": "formBinaryData",
              "name": "fileInput",
              "inputDataFieldName": "data"
            }
          ]
        },
        "options": {}
      },
      "id": "0abd93a5-652a-4e16-a6df-47db93e0bec9",
      "name": "Convert PDF",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1152,
        928
      ],
      "notesInFlow": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/audio/transcriptions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{ $('Mapping').first().json.system.openai_key }}"
            }
          ]
        },
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "whisper-1"
            },
            {
              "parameterType": "formBinaryData",
              "name": "file",
              "inputDataFieldName": "data"
            }
          ]
        },
        "options": {}
      },
      "id": "f863b5b4-c982-43ae-86f8-e1fcf95e740f",
      "name": "Transcription",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1152,
        720
      ],
      "notesInFlow": true
    },
    {
      "parameters": {
        "content": "Fluxo de processamento principal",
        "height": 80,
        "width": 260,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        64,
        -80
      ],
      "id": "535f632f-c929-4c32-b6b9-92534a7e65eb",
      "name": "Sticky Note13"
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\nconst FormData = require('form-data');\n\nconst mappingData = $('Mapping').first().json; // Obtém todo o conteúdo de 'Mapping'\nconsole.log(\"Mapping Data:\", mappingData);\n\nconst baseWebhookUrl = `http://${mappingData.system.n8n_webhook_service}:5678/webhook/`;\nconst finalWorkflowPath = mappingData.system.workflow_path;\nconst defaultFinalUrl = `${baseWebhookUrl}${finalWorkflowPath}`;\n\nconst formData = new FormData();\n\n// Unifica os valores de \"content\" com quebra de linha dupla\nconst unifiedContent = items\n  .map(item => item.json.content)\n  .filter(content => content) // Remove itens vazios ou undefined\n  .join('\\n\\n');\nconsole.log(\"Unified Content:\", unifiedContent);\n\n// Monta o JSON separado para o corpo da requisição\nconst jsonData = {\n  content: unifiedContent,\n  mapping: mappingData\n};\n\n// Adiciona os dados JSON ao FormData\nformData.append('content', jsonData.content);\nformData.append('mapping', JSON.stringify(jsonData.mapping));\n\n// Adiciona arquivos binários mantendo os nomes originais\nitems.forEach((item) => {\n  if (item.binary) {\n    Object.keys(item.binary).forEach((key) => {\n      const file = item.binary[key];\n      formData.append(key, Buffer.from(file.data, 'base64'), {\n        filename: file.fileName || key,\n        contentType: file.mimeType,\n      });\n    });\n  }\n});\n\nif (mappingData.system.enabled_rag === true || mappingData.system.enabled_rag === 'true') {\n  console.log(\"RAG is enabled. Sending request to the RAG endpoint first.\");\n  const ragUrl = `${baseWebhookUrl}rag`;\n  console.log(`Sending RAG request to: ${ragUrl}`);\n\n  return axios.post(ragUrl, formData, { headers: formData.getHeaders() })\n    .then(ragResponse => {\n      console.log(\"RAG Response received:\", ragResponse.data);\n      // Ajuste: obter o valor de \"output\" em vez de \"rag_return\"\n      const rag_return = ragResponse.data.output;\n      jsonData.rag_return = rag_return; // Inclui o retorno do RAG no JSON\n\n      // Reconstroi o FormData com os dados atualizados (incluindo rag_return)\n      const finalFormData = new FormData();\n      finalFormData.append('content', jsonData.content);\n      finalFormData.append('mapping', JSON.stringify(jsonData.mapping));\n      finalFormData.append('rag_return', rag_return);\n      items.forEach((item) => {\n        if (item.binary) {\n          Object.keys(item.binary).forEach((key) => {\n            const file = item.binary[key];\n            finalFormData.append(key, Buffer.from(file.data, 'base64'), {\n              filename: file.fileName || key,\n              contentType: file.mimeType,\n            });\n          });\n        }\n      });\n      \n      // Recupera a URL final do mapping; se não existir, usa a URL padrão\n      let finalUrl = mappingData.system.rag_return;\n      if (!finalUrl) {\n        console.error(\"mappingData.system.rag_return is undefined. Using default final URL instead.\");\n        finalUrl = defaultFinalUrl;\n      }\n      console.log(`Mapping system.rag_return value: \"${finalUrl}\"`);\n      console.log(\"Sending final request to the RAG final endpoint...\");\n\n      return axios.post(finalUrl, finalFormData, { headers: finalFormData.getHeaders() })\n        .then(finalResponse => {\n          console.log(\"Final Response received:\", finalResponse.data);\n          return [{\n            json: {\n              rag: ragResponse.data,\n              final: finalResponse.data,\n              logs: [\n                `RAG request sent to: ${ragUrl}`,\n                `RAG response received with output: ${rag_return}`,\n                `Final request sent to: ${finalUrl}`,\n                `Final response received successfully.`\n              ]\n            }\n          }];\n        })\n        .catch(finalError => {\n          console.error(`Final request error for URL (${finalUrl}):`, finalError.message);\n          return [{\n            json: {\n              error: finalError.message,\n              rag: ragResponse.data,\n              logs: [\n                `RAG request sent to: ${ragUrl}`,\n                `RAG response received with output: ${rag_return}`,\n                `Attempted final request to: ${finalUrl}`,\n                `Final request error: ${finalError.message}`\n              ]\n            }\n          }];\n        });\n    })\n    .catch(ragError => {\n      console.error(\"RAG request error:\", ragError.message);\n      return [{\n        json: {\n          error: ragError.message,\n          logs: [\n            `RAG request sent to: ${baseWebhookUrl}rag`,\n            `RAG request error: ${ragError.message}`\n          ]\n        }\n      }];\n    });\n} else {\n  console.log(\"RAG is not enabled. Sending request directly to the default final URL:\", defaultFinalUrl);\n  return axios.post(defaultFinalUrl, formData, { headers: formData.getHeaders() })\n    .then(response => {\n      console.log(\"Final Response received:\", response.data);\n      return [{\n        json: {\n          final: response.data,\n          logs: [\n            `Final request sent to: ${defaultFinalUrl}`,\n            `Final response received successfully.`\n          ]\n        }\n      }];\n    })\n    .catch(error => {\n      console.error(\"Final request error:\", error.message);\n      return [{\n        json: {\n          error: error.message,\n          logs: [\n            `Final request error for URL (${defaultFinalUrl}): ${error.message}`\n          ]\n        }\n      }];\n    });\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        544,
        624
      ],
      "id": "c60d9c66-5277-4f0d-a224-17141f0b6f82",
      "name": "Execute Core"
    },
    {
      "parameters": {
        "content": "Fluxo Core, responsável pelo processamento da AI",
        "height": 80,
        "width": 260,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        2448,
        704
      ],
      "id": "a0065f05-597c-4044-a517-df66c261ccee",
      "name": "Sticky Note14"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Obtém o último item da tabela conversations com base no campo 'date_created'\nWITH last_conversation AS (\n    SELECT id \n    FROM conversations\n    WHERE user_id = {{ $('Mapping').first().json.chatwoot.contact_id }}\n    ORDER BY date_created DESC\n    LIMIT 1\n),\n\n-- Obtém os últimos dois registros da tabela core_chat_histories com base no session_id\nlast_two_chat_histories AS (\n    SELECT id \n    FROM core_chat_histories\n    WHERE session_id = (SELECT id FROM last_conversation)\n    ORDER BY id DESC\n    LIMIT 2\n)\n\n-- Deleta os últimos dois registros encontrados\nDELETE FROM core_chat_histories\nWHERE id IN (SELECT id FROM last_two_chat_histories);",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        1952,
        624
      ],
      "id": "1c9714d8-31df-4453-a068-3fa0477975da",
      "name": "Clear History",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "Iz6AdCvM8BbJ72YV",
          "name": "Postgres directus95b506d"
        }
      }
    },
    {
      "parameters": {
        "name": "restart_history",
        "description": "=Invoque essa tool para iniciar uma nova conversa para o user, assim ignorando o histórico passado. Apenas quando o user solicitar.",
        "jsCode": "const axios = require('axios');\n\n// Converte o mapeamento recebido em JSON\nconst mapping = JSON.parse($('Core Input').item.json.body.mapping);\n\n// Verifica se o usuário é admin; caso contrário, retorna erro\nif (mapping.system.user_type !== 'admin') {\n  return JSON.stringify({ success: false, error: \"Acesso negado: usuário não autorizado.\" });\n}\n\n/**\n * Função que espera pelo tempo especificado.\n * @param {number} ms - Milissegundos a aguardar.\n * @returns {Promise<void>}\n */\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n/**\n * Função para enviar a requisição para criar uma conversa no Directus.\n * Tenta até 3 vezes em caso de falha, com delay de 1 segundo entre as tentativas.\n * @returns {Promise<object>} - Objeto com sucesso ou erro.\n */\nasync function sendRequest() {\n  const url = `http://${mapping.system.directus_service}:8055/items/conversations`;\n  const data = {\n    user_id: mapping.chatwoot.contact_id,\n    date_created: new Date().toISOString()\n  };\n  const headers = {\n    Authorization: `Bearer ${mapping.system.directus_token}`,\n    'Content-Type': 'application/json'\n  };\n\n  let attempt = 0;\n  let lastError = null;\n\n  while (attempt < 3) {\n    try {\n      const response = await axios.post(url, data, { headers });\n      console.log(`Requisição realizada com sucesso na tentativa ${attempt + 1}.`);\n      return { success: true, data: response.data };\n    } catch (error) {\n      attempt++;\n      lastError = error;\n      console.error(`Tentativa ${attempt} falhou:`, error.response ? error.response.data : error.message);\n      if (attempt < 3) {\n        console.log(\"Aguardando 1 segundo antes da nova tentativa...\");\n        await delay(1000);\n      }\n    }\n  }\n  \n  return { success: false, error: lastError.response ? lastError.response.data : lastError.message };\n}\n\nreturn sendRequest().then(result => JSON.stringify(result));"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        2704,
        1104
      ],
      "id": "4ddf8770-aa6a-4c89-9dcd-2c246a38fdec",
      "name": "Restart History"
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 3,
        "output": "={{\n  $json.content.data_url?.match(/\\.(oga|png|jpg|jpeg|txt|pdf)$/i) !== null \n  && !!$json.content.data_url \n    ? 0 \n    : !!$json.content.content \n      ? 1\n      : 2\n}}"
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        544,
        1024
      ],
      "id": "24511da5-c107-4130-8c0d-54d58b28d823",
      "name": "Switch 2"
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 3,
        "output": "={{ \n  $('Add to List').item.json.chatwoot.message_id !==\n  JSON.parse($('Get List').item.json.data.first()).message_id\n    ? 0\n    : $now.minus($('Mapping').first().json.system.cooldown, 'seconds').diffTo(\n        JSON.parse($('Get List').item.json.data.last()).timestamp,\n        'seconds'\n      ) >= 0\n      ? 1\n      : 2\n}}\n\n\n\n"
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        1552,
        112
      ],
      "id": "d174a506-4263-4a05-bfa3-3cfeb5d9e355",
      "name": "Switch 1"
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 2,
        "output": "={{\n  (\n    $('Mapping').first().json.chatwoot.channel !== 'WhatsApp Web Group' ||\n    (\n      $('Mapping').first().json.system.allow_whatsapp_groups === 'always_enabled' ||\n      (\n        $('Mapping').first().json.system.allow_whatsapp_groups === 'enabled_when_mentioned' &&\n        $('Mapping').first().json.system.agent_mentioned\n      )\n    )\n  )\n  &&\n  {\n    'pending_status': \n      $('Mapping').first().json.chatwoot.sender_type === 'Contact' &&\n      $('Mapping').first().json.chatwoot.conversation_status === 'pending' &&\n      !(\n        $('Mapping').first().json.chatwoot.current_labels.includes('ia-pausada') ||\n        $('Mapping').first().json.chatwoot.current_labels.includes('ia-desativada')\n      ),\n\n    'all_status': \n      $('Mapping').first().json.chatwoot.sender_type === 'Contact' &&\n      !(\n        $('Mapping').first().json.chatwoot.current_labels.includes('ia-pausada') ||\n        $('Mapping').first().json.chatwoot.current_labels.includes('ia-desativada')\n      ),\n\n    'not_assigned': \n      $('Mapping').first().json.chatwoot.sender_type === 'Contact' &&\n      !$('Mapping').first().json.chatwoot.assignee &&\n       !(\n        $('Mapping').first().json.chatwoot.current_labels.includes('ia-pausada') ||\n        $('Mapping').first().json.chatwoot.current_labels.includes('ia-desativada')\n      )\n\n  }\n\n\n  [$('Mapping').first().json.system.enabled_condition]\n    ? 1\n    : 0\n}}",
        "looseTypeValidation": true
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        944,
        112
      ],
      "id": "11136f35-6b98-46ae-b209-a6074c739e3b",
      "name": "Switch 0"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "7cade77f-2498-4515-991a-cbe2d5ffe67a",
              "name": "content",
              "value": "={{\n  $json.content?.content \n  || $json.text \n  || (\n    $('Switch 2').item.json.content.data_url.endsWith('.txt') \n      ? $json.data + '\\n\\n' + $('Switch 2').item.json.content?.content \n      : null\n  )\n}}",
              "type": "string"
            },
            {
              "id": "e8da4202-58a2-4990-9e36-9a56f18c7263",
              "name": "loop_reset",
              "value": false,
              "type": "boolean"
            }
          ]
        },
        "includeOtherFields": true,
        "include": "selected",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1552,
        1024
      ],
      "id": "e61c0d05-4499-42a9-b6fd-171ed0f78dec",
      "name": "Keep Loop"
    },
    {
      "parameters": {
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "core_chat_histories",
          "mode": "list",
          "cachedResultName": "core_chat_histories"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "date_created": "={{ $now }}",
            "session_id": "={{ $json.system.conversations_id }}",
            "message": "={{ JSON.parse(JSON.stringify({\n  \"type\": \"human\",\n  \"content\": $json.chatwoot.content,\n  \"user_name\": $json.chatwoot.user_name\n})) }}"
          },
          "matchingColumns": [
            "id"
          ],
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": false,
              "defaultMatch": true,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "message",
              "displayName": "message",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "object",
              "canBeUsedToMatch": true
            },
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "date_created",
              "displayName": "date_created",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        1152,
        0
      ],
      "id": "1b326992-654a-4676-b645-e48aed4602fe",
      "name": "Update History",
      "credentials": {
        "postgres": {
          "id": "Iz6AdCvM8BbJ72YV",
          "name": "Postgres directus95b506d"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\n\n// Função de delay\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// Função com retry para operações de rede\nasync function withRetry(operation, operationName, maxRetries = 3) {\n  let lastError;\n  \n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      console.log(`[${operationName}] Tentativa ${attempt} de ${maxRetries}`);\n      return await operation();\n    } catch (error) {\n      lastError = error;\n      console.error(`[${operationName}] Erro na tentativa ${attempt}: ${error.message}`);\n      \n      if (attempt < maxRetries) {\n        const retryDelay = 2000; // 2 segundos entre tentativas\n        console.log(`[${operationName}] Aguardando ${retryDelay}ms antes da próxima tentativa`);\n        await delay(retryDelay);\n      }\n    }\n  }\n  \n  throw lastError;\n}\n\n// Extrai os dados de mapping\nconst mapping = $('Mapping').first().json;\nconst { system, chatwoot } = mapping;\n\n// Obter dados da conversa\nconst conversation = $('Consumer').first().json.body.conversation;\nconst assigneeID = conversation.messages[0].conversation.assignee_id;\n\n// Variáveis reutilizáveis\nconst chatwootService = system.chatwoot_service;\nconst accountId = chatwoot.account_id;\nconst conversationId = chatwoot.conversation_id;\nconst userToken = chatwoot.user_token;\nconst assigneeName = chatwoot.assignee;\nconst enabledCondition = system.enabled_condition;\nconst conversationStatus = chatwoot.conversation_status;\n\n// Apaga tags \nif ((enabledCondition === \"not_assigned\" && assigneeName !== null) || \n    (enabledCondition === \"pending_status\" && conversationStatus !== \"pending\")) {\n  \n  // Prepara novo array de labels (apaga ia-pausada e ia_ativada)\n  const labels = chatwoot.current_labels || [];\n  const labelsAtualizadas = labels.filter(tag => tag !== \"ia-ativada\" && tag !== \"ia-pausada\");\n\n  // Envia payload JSON corretamente com retry\n  return withRetry(async () => {\n    try {\n      const response = await axios.post(\n        `http://${chatwootService}:3000/api/v1/accounts/${accountId}/conversations/${conversationId}/labels`,\n        { labels: labelsAtualizadas },\n        {\n          headers: {\n            'Content-Type': 'application/json',\n            api_access_token: userToken\n          }\n        }\n      );\n      return [{ json: response.data }];\n    } catch (error) {\n      console.error(`Erro ao atualizar labels: ${error.message}`);\n      throw error;\n    }\n  }, \"updateLabels\")\n  .then(result => result)\n  .catch(error => [{ json: { error: error.response?.data || error.message } }]);\n}\n\n// pausa da IA quando usuário envia mensagem\nif (system.allow_human_interruption &&\n    chatwoot.sender_type === 'User' &&\n    chatwoot.current_labels.includes('ia-ativada')) {\n  \n  // Prepara novo array de labels\n  const labels = chatwoot.current_labels || [];\n  const labelsAtualizadas = labels\n    .filter(tag => tag !== \"ia-ativada\")\n    .concat(\"ia-pausada\");\n\n  // Envia payload JSON corretamente com retry\n  return withRetry(async () => {\n    try {\n      const response = await axios.post(\n        `http://${chatwootService}:3000/api/v1/accounts/${accountId}/conversations/${conversationId}/labels`,\n        { labels: labelsAtualizadas },\n        {\n          headers: {\n            'Content-Type': 'application/json',\n            api_access_token: userToken\n          }\n        }\n      );\n      return [{ json: response.data }];\n    } catch (error) {\n      console.error(`Erro ao pausar IA: ${error.message}`);\n      throw error;\n    }\n  }, \"pauseAI\")\n  .then(result => result)\n  .catch(error => [{ json: { error: error.response?.data || error.message } }]);\n}\n\n// Se nenhuma condição for atendida\nreturn [{ json: { message: \"Nenhuma ação realizada\" } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1344,
        0
      ],
      "id": "3ebf1a49-1f48-475f-8ab8-43f7feb521c3",
      "name": "Open Conversation"
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\nconst FormData = require('form-data');\n\n// 1.função para escapar caracteres especiais de regex\nfunction escapeRegex(str) {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\n// 2. array de abreviações (note os pontos escapados)\nconst ABBREVIATIONS = [\n    'Dr', 'Dra', 'Sr', 'Sra', 'Srta', 'Sta', \n    'Exmo', 'Exma', 'Prof', 'Profa', 'Eng', \n    'etc', 'V\\\\.Exa', 'V\\\\.Sa', 'pg', 'pag'\n];\n\n// Array para armazenar logs detalhados\nconst detailedLogs = [];\n\n// Funções de log aprimoradas\nfunction logMessage(msg) {\n  console.log(msg);\n  detailedLogs.push({ type: 'info', message: msg, timestamp: new Date().toISOString() });\n}\n\nfunction logError(msg) {\n  console.error(msg);\n  detailedLogs.push({ type: 'error', message: msg, timestamp: new Date().toISOString() });\n}\n\nfunction logRequest(method, url, headers, payload) {\n  detailedLogs.push({\n    type: 'request',\n    method,\n    url,\n    headers,\n    payload,\n    timestamp: new Date().toISOString()\n  });\n}\n\nfunction logResponse(status, data) {\n  detailedLogs.push({\n    type: 'response',\n    status,\n    data,\n    timestamp: new Date().toISOString()\n  });\n}\n\n// ------------------------------\n// Configurações Gerais\n// ------------------------------\nconst MIN_TOTAL_LENGTH = 50;               // Texto menor que 100 caracteres: enviar inteiro.\nconst MIN_SEGMENT_LENGTH = 50;              // Segmentos menores que 50 caracteres serão mesclados.\nconst DESIRED_TEXT_SEGMENT_SIZE = 300;      // Tamanho ideal para segmentos no modo \"text\".\nconst DESIRED_AUDIO_SEGMENT_SIZE = 450;     // Tamanho ideal para segmentos no modo \"audio\" (~30s).\nconst DELAY_FACTOR = 5000;                  // Delay: 5000ms por 100 caracteres.\nconst MAX_RETRIES = 3;                      // Número máximo de tentativas\nconst RETRY_DELAY = 2000;                   // Delay entre tentativas (ms)\n\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// ------------------------------\n// Função para normalizar texto (nova função)\n// ------------------------------\nfunction normalizeText(text) {\n  // Remove espaços extras no final de cada linha antes de quebras de linha\n  text = text.replace(/\\s+\\n/g, '\\n');\n  \n  // Remove múltiplos espaços consecutivos e substitui por um único espaço\n  text = text.replace(/[ \\t]+/g, ' ');\n  \n  // Preserva \\n\\nOnde você prefere? mas normaliza outros padrões\n  if (text.includes(\"Onde você prefere?\")) {\n    const parts = text.split(/(Onde você prefere\\?)/);\n    if (parts.length >= 2) {\n      // Preserva a estrutura da pergunta final\n      const indexOfQuestion = parts.indexOf(\"Onde você prefere?\");\n      if (indexOfQuestion > 0) {\n        // Garante exatamente duas quebras de linha antes da pergunta\n        parts[indexOfQuestion-1] = parts[indexOfQuestion-1].replace(/\\n*$/, '\\n\\n');\n      }\n      // Reconstrói o texto\n      return parts.join('');\n    }\n  }\n  \n  // Normaliza \\n\\n\\n+ para \\n\\n (preserva parágrafos, mas elimina extras)\n  return text.replace(/\\n{3,}/g, '\\n\\n');\n}\n\n// ------------------------------\n// Função para processar o texto de clínicas (nova função)\n// ------------------------------\nfunction processClinicText(text) {\n  // Normaliza o texto para remover espaços extras\n  text = normalizeText(text);\n  \n  // Identifica o padrão específico do texto da clínica\n  if (text.includes(\"unidades\") && text.includes(\"Dra.\") && text.includes(\"Onde você prefere?\")) {\n    // Divide o texto em partes principais\n    const segments = [];\n    \n    // Extrai a introdução (até o primeiro \\n\\n)\n    const introEnd = text.indexOf(\"\\n\\n\");\n    if (introEnd > 0) {\n      segments.push(text.substring(0, introEnd));\n      text = text.substring(introEnd + 2); // Remove a introdução do texto restante\n    }\n    \n    // Processa o conteúdo principal (unidades)\n    const mainEnd = text.indexOf(\"\\n\\nOnde você prefere?\");\n    if (mainEnd > 0) {\n      const mainText = text.substring(0, mainEnd);\n      // Limpa espaços extras nas linhas\n      const cleanedMainText = mainText.replace(/\\s+\\n/g, '\\n')\n                                    .replace(/\\n\\s+/g, '\\n');\n      segments.push(cleanedMainText);\n      \n      // Adiciona a pergunta final\n      segments.push(\"\\n\\nOnde você prefere?\");\n    } else {\n      // Se não encontrar a pergunta final, adiciona o resto do texto\n      segments.push(text);\n    }\n    \n    return segments.filter(p => p.trim().length > 0);\n  }\n  \n  // Se não for o padrão específico, retorna o texto normalizado inteiro\n  return [text];\n}\n\n// ------------------------------\n// Parâmetros obtidos dos nós\n// ------------------------------\nconst mapping = $('Mapping').first().json;\nconst chatwootData = mapping.chatwoot;\nconst accountId = chatwootData.account_id;\nconst conversationId = chatwootData.conversation_id;\nconst botToken = chatwootData.bot_token;\n\nconst system = mapping.system;\nconst outputFormat = system.output_format.toLowerCase(); // \"text\", \"audio\" ou \"smart\"\nconst elevenlabsKey = system.elevenlabs_key;\nconst elevenlabsVoice = system.elevenlabs_voice || \"JBFqnCBsd6RMkjVDRZzb\";\nconst elevenlabsModel = system.elevenlabs_model || \"eleven_multilingual_v2\";\nconst chatwootService = system.chatwoot_service; // Valor para a URL do Chatwoot\n\n// Texto original (ajustado para acessar o payload final corretamente)\nconst originalText = $('Execute Core').first().json.final.output;\nlogMessage(`[Main] Texto original possui ${originalText.length} caracteres.`);\nlogMessage(`[Main] Modo de saída: ${outputFormat}`);\n\n// Endpoint do Chatwoot (ajustado para usar chatwootService)\nconst chatwootUrl = `http://${chatwootService}:3000/api/v1/accounts/${encodeURIComponent(accountId)}/conversations/${encodeURIComponent(conversationId)}/messages`;\nlogMessage(`[Main] Chatwoot URL: ${chatwootUrl}`);\n\n// Log dos parâmetros de entrada\nlogMessage(`[Main] Parâmetros: accountId=${accountId}, conversationId=${conversationId}`);\nlogMessage(`[Main] Chatwoot Service: ${chatwootService}`);\nlogMessage(`[Main] Token (primeiros 5 caracteres): ${botToken.substring(0, 5)}...`);\n\n// ------------------------------\n// Função com retry para operações de rede\n// ------------------------------\nasync function withRetry(operation, operationName, maxRetries = MAX_RETRIES) {\n  let lastError;\n  \n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      logMessage(`[${operationName}] Tentativa ${attempt} de ${maxRetries}`);\n      return await operation();\n    } catch (error) {\n      lastError = error;\n      logError(`[${operationName}] Erro na tentativa ${attempt}: ${error.message}`);\n      \n      if (attempt < maxRetries) {\n        logMessage(`[${operationName}] Aguardando ${RETRY_DELAY}ms antes da próxima tentativa`);\n        await delay(RETRY_DELAY);\n      }\n    }\n  }\n  \n  throw lastError;\n}\n\n// ------------------------------\n// Função para enviar mensagem de texto\n// ------------------------------\nasync function sendTextMessage(content) {\n  // Normaliza o texto antes de enviar\n  const normalizedContent = normalizeText(content);\n  \n  const payload = { content: normalizedContent, message_type: \"outgoing\" };\n  const headers = {\n    \"api_access_token\": botToken,\n    \"Content-Type\": \"application/json\"\n  };\n  \n  logMessage(`[sendTextMessage] Enviando mensagem de texto.`);\n  logMessage(`[sendTextMessage] URL: ${chatwootUrl}`);\n  logMessage(`[sendTextMessage] Payload: ${JSON.stringify(payload)}`);\n  logMessage(`[sendTextMessage] Headers: ${JSON.stringify(headers)}`);\n  \n  logRequest('POST', chatwootUrl, headers, payload);\n  \n  return withRetry(async () => {\n    try {\n      const response = await axios.post(chatwootUrl, payload, { headers });\n      logMessage(`[sendTextMessage] Resposta do Chatwoot: status ${response.status}`);\n      logResponse(response.status, response.data);\n      return response.data;\n    } catch (error) {\n      logError(`[sendTextMessage] Erro ao enviar mensagem de texto: ${error.toString()}`);\n      \n      if (error.response) {\n        logError(`[sendTextMessage] Status: ${error.response.status}`);\n        logError(`[sendTextMessage] Headers: ${JSON.stringify(error.response.headers)}`);\n        logError(`[sendTextMessage] Erro Response: ${JSON.stringify(error.response.data)}`);\n        logResponse(error.response.status, error.response.data);\n      } else if (error.request) {\n        logError(`[sendTextMessage] Erro Request: ${error.request}`);\n      }\n      \n      throw error;\n    }\n  }, \"sendTextMessage\");\n}\n\n// ------------------------------\n// Função para enviar mensagem de áudio\n// ------------------------------\nasync function sendAudioMessage(audioBuffer) {\n  const form = new FormData();\n  form.append(\"attachments[]\", audioBuffer, { filename: \"audio.mp3\", contentType: \"audio/mpeg\" });\n  form.append(\"message_type\", \"outgoing\");\n  \n  const headers = {\n    \"api_access_token\": botToken,\n    ...form.getHeaders()\n  };\n  \n  logMessage(`[sendAudioMessage] Enviando mensagem de áudio.`);\n  logMessage(`[sendAudioMessage] URL: ${chatwootUrl}`);\n  logMessage(`[sendAudioMessage] Headers: ${JSON.stringify(headers)}`);\n  logMessage(`[sendAudioMessage] Tamanho do áudio: ${audioBuffer.length} bytes`);\n  \n  logRequest('POST', chatwootUrl, headers, \"Form Data com áudio\");\n  \n  return withRetry(async () => {\n    try {\n      const response = await axios.post(chatwootUrl, form, { headers });\n      logMessage(`[sendAudioMessage] Resposta do Chatwoot: status ${response.status}`);\n      logResponse(response.status, response.data);\n      return response.data;\n    } catch (error) {\n      logError(`[sendAudioMessage] Erro ao enviar mensagem de áudio: ${error.toString()}`);\n      \n      if (error.response) {\n        logError(`[sendAudioMessage] Status: ${error.response.status}`);\n        logError(`[sendAudioMessage] Headers: ${JSON.stringify(error.response.headers)}`);\n        logError(`[sendAudioMessage] Erro Response: ${JSON.stringify(error.response.data)}`);\n        logResponse(error.response.status, error.response.data);\n      } else if (error.request) {\n        logError(`[sendAudioMessage] Erro Request: ${error.request}`);\n      }\n      \n      throw error;\n    }\n  }, \"sendAudioMessage\");\n}\n\n// ------------------------------\n// Função para converter texto em áudio via Elevenlabs\n// ------------------------------\nasync function convertTextToSpeech(text) {\n  const url = `https://api.elevenlabs.io/v1/text-to-speech/${encodeURIComponent(elevenlabsVoice)}?output_format=mp3_44100_128`;\n  const headers = {\n    \"xi-api-key\": elevenlabsKey,\n    \"Content-Type\": \"application/json\"\n  };\n  const payload = {\n    text: text,\n    model_id: elevenlabsModel\n  };\n  \n  logMessage(`[convertTextToSpeech] Convertendo texto para áudio (primeiros 50 caracteres): \"${text.substring(0,50)}...\"`);\n  logMessage(`[convertTextToSpeech] URL da API Elevenlabs: ${url}`);\n  logMessage(`[convertTextToSpeech] Modelo utilizado: ${elevenlabsModel}`);\n  \n  logRequest('POST', url, headers, payload);\n  \n  return withRetry(async () => {\n    try {\n      const response = await axios.post(url, payload, { headers, responseType: 'arraybuffer' });\n      logMessage(`[convertTextToSpeech] Conversão realizada com sucesso. Status: ${response.status}`);\n      logResponse(response.status, \"Binary Audio Data\");\n      return response.data;\n    } catch (error) {\n      logError(`[convertTextToSpeech] Erro ao converter texto para áudio: ${error.toString()}`);\n      \n      if (error.response) {\n        logError(`[convertTextToSpeech] Status: ${error.response.status}`);\n        logError(`[convertTextToSpeech] Headers: ${JSON.stringify(error.response.headers)}`);\n        // Para arraybuffer, precisamos converter para texto para ver o erro\n        if (error.response.data) {\n          try {\n            const errorText = Buffer.from(error.response.data).toString('utf8');\n            logError(`[convertTextToSpeech] Erro Response: ${errorText}`);\n            logResponse(error.response.status, errorText);\n          } catch (e) {\n            logError(`[convertTextToSpeech] Não foi possível converter resposta de erro: ${e.toString()}`);\n          }\n        }\n      } else if (error.request) {\n        logError(`[convertTextToSpeech] Erro Request: ${error.request}`);\n      }\n      \n      throw error;\n    }\n  }, \"convertTextToSpeech\");\n}\n\n// ------------------------------\n// Função para mesclar segmentos curtos (para modos text and audio)\n// ------------------------------\nfunction mergeShortSegments(segments, minLength) {\n  const merged = [];\n  let buffer = \"\";\n  \n  for (const seg of segments) {\n    // Preservar segmentos que contêm quebras de linha, independente do tamanho\n    if (seg.includes('\\n')) {\n      if (buffer) {\n        merged.push(buffer);\n        buffer = \"\";\n      }\n      merged.push(seg);\n    }\n    // Para outros segmentos, manter a lógica original\n    else if ((buffer + \" \" + seg).trim().length < minLength) {\n      buffer = (buffer + \" \" + seg).trim();\n    } else {\n      if (buffer) {\n        merged.push(buffer);\n        buffer = \"\";\n      }\n      merged.push(seg);\n    }\n  }\n  \n  if (buffer) {\n    if (merged.length > 0 && !merged[merged.length - 1].includes('\\n')) {\n      merged[merged.length - 1] += \" \" + buffer;\n    } else {\n      merged.push(buffer);\n    }\n  }\n  \n  return merged;\n}\n\n// ------------------------------\n// Função de segmentação genérica (evita quebrar palavras)\n// ------------------------------\nfunction segmentTextGeneric(text, desiredMaxLength) {\n    // Primeiro, verifica se é um texto de clínica\n    if (text.includes(\"unidades\") && text.includes(\"Dra.\") && text.includes(\"Onde você prefere?\")) {\n      return processClinicText(text);\n    }\n    \n    // Normaliza o texto para remover espaços extras\n    text = normalizeText(text);\n    \n    if (text.length <= desiredMaxLength) return [text];\n    \n    let segments = [];\n    \n    // Escapa as abreviações e monta o padrão corretamente\n    const escapedAbbr = ABBREVIATIONS.map(abbr => escapeRegex(abbr));\n    const abbreviationPattern = `\\\\b(${escapedAbbr.join('|')})\\\\.`;\n    const sentenceSplitRegex = new RegExp(`(?<!${abbreviationPattern})(?<=[.?!])\\\\s+`, 'g');\n    \n    // Tratamento especial para a pergunta final \"Onde você prefere?\"\n    if (text.includes(\"Onde você prefere?\")) {\n        const questionIndex = text.lastIndexOf(\"Onde você prefere?\");\n        const beforeQuestion = text.substring(0, questionIndex);\n        \n        // Verifica se a pergunta está em um parágrafo separado\n        const hasNewlineBefore = beforeQuestion.endsWith(\"\\n\\n\");\n        \n        // Processa a parte principal\n        if (beforeQuestion.trim()) {\n            // Divide por parágrafos se existirem\n            if (beforeQuestion.includes(\"\\n\\n\")) {\n                const mainSegments = beforeQuestion.split(/\\n\\n+/)\n                                     .map(seg => seg.trim())\n                                     .filter(seg => seg.length > 0);\n                segments = [...mainSegments];\n            } else {\n                // Se não tem parágrafos, divide por sentenças\n                const mainSegments = beforeQuestion.split(sentenceSplitRegex)\n                                     .map(seg => seg ? seg.trim() : '')\n                                     .filter(seg => seg.length > 0);\n                segments = [...mainSegments];\n            }\n        }\n        \n        // Adiciona a pergunta final como um segmento separado\n        // preservando a formatação original\n        if (hasNewlineBefore) {\n            segments.push(\"\\n\\nOnde você prefere?\");\n        } else {\n            segments.push(\"Onde você prefere?\");\n        }\n    } else if (text.includes(\"\\n\\n\")) {\n        // Se tem parágrafos mas não tem a pergunta final específica\n        segments = text.split(/\\n\\n+/)\n                      .map(seg => seg.trim())\n                      .filter(seg => seg.length > 0);\n    } else {\n        // Se não tem parágrafos, divide por sentenças\n        segments = text.split(sentenceSplitRegex)\n                      .map(seg => seg ? seg.trim() : '')\n                      .filter(seg => seg.length > 0);\n    }\n    \n    // Mescla segmentos curtos, preservando aqueles com quebras de linha\n    segments = mergeShortSegments(segments, MIN_SEGMENT_LENGTH);\n    \n    // Se algum segmento for muito longo, subdivide-o\n    const finalSegments = [];\n    segments.forEach(seg => {\n        // Se o segmento contém quebras de linha e é longo\n        if (seg.includes('\\n') && seg.length > desiredMaxLength * 1.5) {\n            // Divide por linhas para preservar a formatação\n            const lines = seg.split(/(\\n)/);\n            let current = \"\";\n            \n            for (let i = 0; i < lines.length; i++) {\n                const line = lines[i];\n                // Se for uma quebra de linha\n                if (line === '\\n') {\n                    current += '\\n';\n                } else if (line.trim()) {\n                    // Se não for uma quebra e não estiver vazio\n                    if ((current + line).length > desiredMaxLength) {\n                        finalSegments.push(current);\n                        current = line;\n                    } else {\n                        current += line;\n                    }\n                }\n            }\n            \n            if (current) finalSegments.push(current);\n        }\n        // Se não tem quebras de linha mas é longo\n        else if (seg.length > desiredMaxLength * 1.5) {\n            const words = seg.split(\" \");\n            let current = \"\";\n            \n            for (const word of words) {\n                if ((current + \" \" + word).length > desiredMaxLength) {\n                    finalSegments.push(current.trim());\n                    current = word;\n                } else {\n                    current += (current ? \" \" : \"\") + word;\n                }\n            }\n            \n            if (current.trim()) finalSegments.push(current.trim());\n        } else {\n            finalSegments.push(seg);\n        }\n    });\n    \n    return finalSegments;\n}\n\n// ------------------------------\n// Funções de segmentação para cada modo\n// ------------------------------\nfunction segmentForText(text) {\n  return segmentTextGeneric(text, DESIRED_TEXT_SEGMENT_SIZE);\n}\n\nfunction segmentForAudio(text) {\n  return segmentTextGeneric(text, DESIRED_AUDIO_SEGMENT_SIZE);\n}\n\n// ------------------------------\n// Função de segmentação inteligente (smart)\n// ------------------------------\nfunction smartSegment(text) {\n  // Verifica se é um texto de clínica\n  if (text.includes(\"unidades\") && text.includes(\"Dra.\") && text.includes(\"Onde você prefere?\")) {\n    const parts = processClinicText(text);\n    return parts.map(part => ({ type: \"text\", content: part }));\n  }\n  \n  // Comportamento original\n  const sentences = text.split(/(?<=[.?!])\\s+/).map(s => s.trim()).filter(s => s);\n  const segments = [];\n  let audioBuffer = \"\";\n  \n  for (const sentence of sentences) {\n    // Preservar sentenças com quebras de linha como texto\n    if (sentence.includes('\\n') || /\\d/.test(sentence) || sentence.length < 80 || sentence.length > 600) {\n      if (audioBuffer) {\n        segments.push({ type: \"audio\", content: audioBuffer.trim() });\n        audioBuffer = \"\";\n      }\n      segments.push({ type: \"text\", content: sentence });\n    } else {\n      if ((audioBuffer + \" \" + sentence).trim().length > DESIRED_AUDIO_SEGMENT_SIZE) {\n        segments.push({ type: \"audio\", content: audioBuffer.trim() });\n        audioBuffer = sentence;\n      } else {\n        audioBuffer = (audioBuffer + \" \" + sentence).trim();\n      }\n    }\n  }\n  \n  if (audioBuffer) {\n    segments.push({ type: \"audio\", content: audioBuffer.trim() });\n  }\n  \n  // Mescla segmentos de texto curtos, preservando aqueles com quebras de linha\n  const mergedSegments = [];\n  \n  for (let i = 0; i < segments.length; i++) {\n    const seg = segments[i];\n    // Nunca mesclar segmentos que contêm quebras de linha\n    if (seg.type === \"text\" && !seg.content.includes('\\n') && seg.content.length < MIN_SEGMENT_LENGTH) {\n      if (mergedSegments.length > 0 && mergedSegments[mergedSegments.length - 1].type === \"text\" \n          && !mergedSegments[mergedSegments.length - 1].content.includes('\\n')) {\n        mergedSegments[mergedSegments.length - 1].content += \" \" + seg.content;\n      } else if (i < segments.length - 1 && segments[i+1].type === \"text\" \n                && !segments[i+1].content.includes('\\n')) {\n        segments[i+1].content = seg.content + \" \" + segments[i+1].content;\n      } else {\n        mergedSegments.push(seg);\n      }\n    } else {\n      mergedSegments.push(seg);\n    }\n  }\n  \n  return mergedSegments;\n}\n\n// ------------------------------\n// Função principal para segmentar e enviar a mensagem\n// ------------------------------\nasync function main() {\n  try {\n    logMessage(`[Main] Modo de saída selecionado: ${outputFormat}`);\n    \n    // Verificação inicial de parâmetros essenciais\n    if (!originalText || originalText.trim().length === 0) {\n      throw new Error(\"Texto original está vazio ou não foi encontrado\");\n    }\n    \n    if (!chatwootService) {\n      throw new Error(\"chatwoot_service não definido\");\n    }\n    \n    if (!accountId) {\n      throw new Error(\"account_id não definido\");\n    }\n    \n    if (!conversationId) {\n      throw new Error(\"conversation_id não definido\");\n    }\n    \n    if (!botToken) {\n      throw new Error(\"bot_token não definido\");\n    }\n    \n    // Adicionando um delay inicial para garantir que o Chatwoot esteja pronto\n    await delay(1000);\n  \n    if (outputFormat === \"audio\") {\n      if (!elevenlabsKey) {\n        throw new Error(\"ElevenLabs API key não definida para modo audio\");\n      }\n      \n      const segments = segmentForAudio(originalText);\n      logMessage(`[Main] Texto segmentado em ${segments.length} segmento(s) para áudio.`);\n      \n      for (const segment of segments) {\n        logMessage(`[Main] Processando segmento de áudio: \"${segment.substring(0,50)}...\"`);\n        const audioBuffer = await convertTextToSpeech(segment);\n        await sendAudioMessage(audioBuffer);\n        logMessage(`[Main] Segmento de áudio enviado: \"${segment.substring(0,50)}...\"`);\n        const delayTime = Math.ceil(segment.length / 100) * DELAY_FACTOR;\n        logMessage(`[Main] Aguardando ${delayTime}ms antes do próximo segmento de áudio.`);\n        await delay(delayTime);\n      }\n      \n      return { message: \"Mensagem de áudio enviada com sucesso.\", logs: detailedLogs };\n    } else if (outputFormat === \"smart\") {\n      if (!elevenlabsKey) {\n        throw new Error(\"ElevenLabs API key não definida para modo smart\");\n      }\n      \n      const segments = smartSegment(originalText);\n      logMessage(`[Main] Texto segmentado em ${segments.length} parte(s) (smart mode).`);\n      \n      for (const seg of segments) {\n        if (seg.type === \"audio\") {\n          logMessage(`[Main] Processando segmento de áudio smart: \"${seg.content.substring(0,50)}...\"`);\n          const audioBuffer = await convertTextToSpeech(seg.content);\n          await sendAudioMessage(audioBuffer);\n          logMessage(`[Main] Segmento de áudio enviado: \"${seg.content.substring(0,50)}...\"`);\n        } else {\n          logMessage(`[Main] Processando segmento de texto smart: \"${seg.content.substring(0,50)}...\"`);\n          await sendTextMessage(seg.content);\n          logMessage(`[Main] Segmento de texto enviado: \"${seg.content.substring(0,50)}...\"`);\n        }\n        \n        const delayTime = Math.ceil(seg.content.length / 100) * DELAY_FACTOR;\n        logMessage(`[Main] Aguardando ${delayTime}ms antes do próximo segmento.`);\n        await delay(delayTime);\n      }\n      \n      return { message: \"Mensagem smart enviada com sucesso.\", logs: detailedLogs };\n    } else {\n      // Modo padrão: text\n      // Verifica se é um texto da clínica para tratamento especial\n      if (originalText.includes(\"unidades\") && (originalText.includes(\"Dra.\") || originalText.includes(\"Dr.\")) && originalText.includes(\"Onde você prefere?\")) {\n        const segments = processClinicText(originalText);\n        logMessage(`[Main] Texto de clínica segmentado em ${segments.length} parte(s).`);\n        \n        for (const segment of segments) {\n          logMessage(`[Main] Processando segmento de clínica: \"${segment.substring(0,50)}...\"`);\n          await sendTextMessage(segment);\n          logMessage(`[Main] Segmento de clínica enviado: \"${segment.substring(0,50)}...\"`);\n          \n          const delayTime = Math.ceil(segment.length / 100) * DELAY_FACTOR;\n          logMessage(`[Main] Aguardando ${delayTime}ms antes do próximo segmento.`);\n          await delay(delayTime);\n        }\n        \n        return { message: \"Mensagens de texto da clínica enviadas com sucesso.\", logs: detailedLogs };\n      } else {\n        // Comportamento normal para outros casos\n        const segments = segmentForText(originalText);\n        logMessage(`[Main] Texto segmentado em ${segments.length} segmento(s) para texto.`);\n        \n        for (const segment of segments) {\n          logMessage(`[Main] Processando segmento de texto: \"${segment.substring(0,50)}...\"`);\n          await sendTextMessage(segment);\n          logMessage(`[Main] Segmento de texto enviado: \"${segment.substring(0,50)}...\"`);\n          \n          const delayTime = Math.ceil(segment.length / 100) * DELAY_FACTOR;\n          logMessage(`[Main] Aguardando ${delayTime}ms antes do próximo segmento de texto.`);\n          await delay(delayTime);\n        }\n        \n        return { message: \"Mensagens de texto enviadas com sucesso.\", logs: detailedLogs };\n      }\n    }\n  } catch (error) {\n    logError(`[Main] Erro: ${error.toString()}`);\n    return { error: error.toString(), logs: detailedLogs };\n  }\n}\n\nreturn main().then(result => [{ json: result }]);"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1952,
        832
      ],
      "id": "9684d03b-f0e2-4bfe-b426-1e18e6439c33",
      "name": "Chatwoot Output"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH last_conversation AS (\n  -- Encontra a última conversa do usuário\n  SELECT id\n  FROM conversations\n  WHERE user_id = {{ $('Mapping').first().json.chatwoot.contact_id }}\n  ORDER BY date_created DESC\n  LIMIT 1\n),\nlast_two_chat_histories AS (\n  -- Obtém os dois últimos históricos da conversa e define uma ordem para identificar o penúltimo\n  SELECT \n    id,\n    ROW_NUMBER() OVER (ORDER BY id DESC) AS rn\n  FROM core_chat_histories\n  WHERE session_id = (SELECT id FROM last_conversation)\n  ORDER BY id DESC\n  LIMIT 2\n),\nupdate_chat_histories AS (\n  UPDATE core_chat_histories c\n  SET \n    date_created = NOW(),\n    message = (\n      CASE \n        WHEN l.rn = 2 \n          THEN jsonb_set(c.message::jsonb, '{user_name}', to_jsonb('{{ $('Mapping').first().json.chatwoot.user_name }}'::text), true)\n        ELSE c.message::jsonb\n      END\n    )::json\n  FROM last_two_chat_histories l\n  WHERE c.id = l.id\n  RETURNING 1\n)\nUPDATE users u\nSET date_updated = NOW()\nWHERE u.id = {{ $('Mapping').first().json.chatwoot.contact_id }};",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        2144,
        832
      ],
      "id": "7b9f630d-5c2a-41a6-9c08-1901a88102eb",
      "name": "Add Register",
      "credentials": {
        "postgres": {
          "id": "Iz6AdCvM8BbJ72YV",
          "name": "Postgres directus95b506d"
        }
      }
    },
    {
      "parameters": {
        "name": "set_timer",
        "description": "Invoque essa tool para configurar um timer que iniciará uma ação após o tempo especificado. Apenas usuários admin podem usar essa tool. O tempo deve ser informado com valor e unidade (s, m, h). Apenas quando o user solicitar.",
        "jsCode": "const axios = require('axios');\nconst dayjs = require('dayjs');\nconst duration = require('dayjs/plugin/duration');\ndayjs.extend(duration);\n\n/**\n * Esta tool configura um timer via webhook.\n * Ela envia, para o endpoint, todo o objeto mapping (obtido em Core Input)\n * e o tempo em segundos calculado a partir dos parâmetros \"timer_value\" e \"timer_unit\".\n * Apenas usuários admin podem utilizar esta tool.\n */\n\n// Converte o mapping recebido em JSON\nconst mapping = JSON.parse($('Core Input').item.json.body.mapping);\n\n// Verifica se o usuário é admin\nif (mapping.system.user_type !== 'admin') {\n  return JSON.stringify({ success: false, error: \"Acesso negado: usuário não autorizado.\" });\n}\n\n// Obtém os parâmetros do timer a partir do input (query)\nconst timerValue = query.timer_value;  // Número (ex: 30)\nconst timerUnit = query.timer_unit;      // \"s\", \"m\" ou \"h\"\n\n// Calcula o tempo em segundos usando dayjs.duration\nconst timerSeconds = dayjs.duration(timerValue, timerUnit).asSeconds();\n\n// Prepara o payload para o webhook\nconst payload = {\n  mapping: mapping,\n  timer_seconds: timerSeconds\n};\n\n// URL do webhook substituindo 'n8n_webhook' pelo valor da variável no mapping\nconst url = `http://${mapping.system.n8n_webhook_service}:5678/webhook/timer`;\n\n/**\n * Função para enviar a requisição ao webhook.\n * Tenta enviar uma única vez e retorna o resultado.\n */\nasync function sendTimerRequest() {\n  try {\n    console.log(`Enviando requisição para configurar o timer para ${timerSeconds} segundos...`);\n    const response = await axios.post(url, payload, {\n      headers: { 'Content-Type': 'application/json' }\n    });\n    console.log(\"Timer configurado com sucesso.\");\n    return { success: true, message: `Timer configurado com sucesso. Ele será acionado em ${timerSeconds} segundos.` };\n  } catch (error) {\n    console.error(\"Erro ao configurar o timer:\", error.response ? error.response.data : error.message);\n    return { success: false, error: error.response ? error.response.data : error.message };\n  }\n}\n\nreturn sendTimerRequest().then(result => JSON.stringify(result));",
        "specifyInputSchema": true,
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"timer_value\": {\n      \"type\": \"number\",\n      \"description\": \"Valor do timer. Exemplo: 30\"\n    },\n    \"timer_unit\": {\n      \"type\": \"string\",\n      \"description\": \"Unidade de tempo para o timer: 's' para segundos, 'm' para minutos, 'h' para horas.\",\n      \"enum\": [\"s\", \"m\", \"h\"]\n    }\n  },\n  \"required\": [\"timer_value\", \"timer_unit\"]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        2832,
        1104
      ],
      "id": "63518928-e3cf-4b79-8e2f-a4f638608847",
      "name": "Set Timer"
    },
    {
      "parameters": {
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "tableName": {
          "__rl": true,
          "value": "knowledge",
          "mode": "list",
          "cachedResultName": "knowledge"
        },
        "additionalFields": {},
        "options": {
          "connectionTimeout": 300,
          "delayClosingIdleConnection": 5
        }
      },
      "type": "n8n-nodes-base.postgresTrigger",
      "typeVersion": 1,
      "position": [
        144,
        1392
      ],
      "id": "3338f404-acd9-4ad0-aa60-c2dee2b13dae",
      "name": "Knowledge Trigger",
      "credentials": {
        "postgres": {
          "id": "Iz6AdCvM8BbJ72YV",
          "name": "Postgres directus95b506d"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  k.*,\n  n.value AS namespace,\n  ph.value AS pinecone_host,\n  (\n    SELECT json_agg(ku.url)\n    FROM knowledge_urls ku\n    WHERE ku.knowledge_id = k.id\n  ) AS urls,\n  (\n    SELECT json_agg(kf.directus_files_id)\n    FROM knowledge_files kf\n    WHERE kf.knowledge_id = k.id\n  ) AS files_id,\n  (\n    SELECT row_to_json(gv)\n    FROM global_vars gv\n    LIMIT 1\n  ) AS global_vars\nFROM knowledge k\nLEFT JOIN namespace n ON n.id = k.name_id\nLEFT JOIN pinecone_host ph ON ph.id = k.pinecone_host_id\nWHERE k.id = {{ $('Knowledge Trigger').first().json.payload.id }};\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        352,
        1392
      ],
      "id": "b2a16523-e6c9-484a-ba11-abfb1bf7c9d2",
      "name": "Get Global Vars",
      "credentials": {
        "postgres": {
          "id": "Iz6AdCvM8BbJ72YV",
          "name": "Postgres directus95b506d"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\n\n// Delay configurável\nfunction delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Executa requisição GET com retry, usando parâmetros configuráveis.\nasync function axiosGetWithRetry(url, config, maxAttempts = 3, delayMs = 1000) {\n  let attempt = 1;\n  while (attempt <= maxAttempts) {\n    try {\n      return await axios.get(url, config);\n    } catch (err) {\n      console.error(`Tentativa ${attempt} para ${url} falhou:`, {\n        message: err.message,\n        status: err.response?.status,\n        data: err.response?.data,\n      });\n      if (attempt === maxAttempts) throw err;\n      attempt++;\n      await delay(delayMs);\n    }\n  }\n}\n\n// Prompt para gerar resumo de um bloco de texto\nconst SUMMARY_PROMPT = `Analise o texto a seguir e elabore um resumo conciso e direto, destacando os principais tópicos e informações essenciais. Esse resumo servirá de base para compor a descrição geral do documento.\n\nTexto:\n{conteudo}\n\nResumo:`;\n\n// Prompt para criar a descrição diretamente a partir do texto completo\nconst DIRECT_DESCRIPTION_PROMPT = `Analise o texto a seguir e crie uma descrição clara e objetiva do conteúdo geral do documento. A resposta deve ser um único parágrafo conciso de texto simples, sem formatação, com aproximadamente 300 caracteres.\n\nTexto:\n{conteudo}\n\nDescrição:`;\n\n// Prompt para gerar a descrição final a partir dos resumos\nconst FINAL_DESCRIPTION_PROMPT = `Com base nos resumos a seguir, elabore uma descrição clara e objetiva do conteúdo geral do documento. A resposta deve ser um único parágrafo conciso de texto simples, sem formatação, com aproximadamente 300 caracteres.\n\nResumos:\n{conteudo}\n\nDescrição:`;\n\n// Cria chunks de forma orgânica, sem misturar conteúdos de diferentes scrapings\nfunction createChunks(text, chunkLength, overlapPercentage) {\n  const overlapLength = Math.floor(chunkLength * (overlapPercentage / 100));\n  const chunks = [];\n  let currentPos = 0;\n  while (currentPos < text.length) {\n    let endPos = currentPos + chunkLength;\n    if (endPos >= text.length) {\n      endPos = text.length;\n    } else {\n      const searchStart = Math.max(currentPos, endPos - 100);\n      let breakPos = -1;\n      let pos = text.lastIndexOf(\"\\n\\n\", endPos);\n      if (pos >= searchStart) {\n        breakPos = pos + 2;\n      } else {\n        pos = text.lastIndexOf(\"\\n\", endPos);\n        if (pos >= searchStart) {\n          breakPos = pos + 1;\n        } else {\n          pos = text.lastIndexOf(\".\", endPos);\n          if (pos >= searchStart) {\n            breakPos = pos + 1;\n          } else {\n            pos = text.lastIndexOf(\"?\", endPos);\n            if (pos >= searchStart) {\n              breakPos = pos + 1;\n            } else {\n              pos = text.lastIndexOf(\"!\", endPos);\n              if (pos >= searchStart) {\n                breakPos = pos + 1;\n              }\n            }\n          }\n        }\n      }\n      if (breakPos > currentPos) {\n        endPos = breakPos;\n      }\n    }\n    const chunk = text.substring(currentPos, endPos).trim();\n    if (chunk.length > 0) chunks.push(chunk);\n    if (endPos === text.length) break;\n    currentPos = endPos - overlapLength;\n    if (currentPos < 0) currentPos = 0;\n  }\n  return chunks;\n}\n\n// Função para atualizar o campo \"description\" da tabela \"knowledge\" no Directus\nasync function updateDirectusDescription(newDescription, globalVars, globalId) {\n  const patchUrl = `http://${globalVars.directus_service}:8055/items/knowledge/${globalId}`;\n  const patchPayload = { description: newDescription };\n  const headers = {\n    \"Content-Type\": \"application/json\",\n    \"Authorization\": `Bearer ${globalVars.directus_token}`\n  };\n  let attempts = 0;\n  while (attempts < 3) {\n    try {\n      const response = await axios.patch(patchUrl, patchPayload, { headers });\n      console.log(`Directus update successful: ${JSON.stringify(response.data)}`);\n      return response.data;\n    } catch (error) {\n      attempts++;\n      console.error(`Directus update attempt ${attempts} failed: ${error.message}`);\n      if (attempts < 3) {\n        await delay(1000);\n      } else {\n        throw error;\n      }\n    }\n  }\n}\n\nasync function processScraping() {\n  // Extrai dados do nó Get Global Vars\n  const globalData = $('Get Global Vars').first().json;\n  const globalVars = globalData.global_vars;\n  const filesIds = Array.isArray(globalData.files_id) ? globalData.files_id : [];\n  const originalUrls = Array.isArray(globalData.urls) ? globalData.urls : [];\n  // Usa s3_url definido em global_vars\n  const host = globalVars.s3_url;\n  const directusToken = globalVars.directus_token;\n  const jinaToken = globalVars.jina_ai_token;\n  const openrouterKey = globalVars.openrouter_key;\n  const directusService = globalVars.directus_service;\n  const n8nWebhookService = globalVars.n8n_webhook_service;\n  const chunkLength = globalData.chunks_length || 2000; // fallback default\n  const overlapPercentage = globalData.overlap || 0;      // fallback default\n  \n  // Extrai o valor de Knowledge Trigger\n  const knowledgeTriggerId = $('Knowledge Trigger').first().json.payload.id;\n\n  // Processa arquivos para obter finalUrl com retry (se existirem)\n  const fileResults = await Promise.all(\n    filesIds.map(async (fileId) => {\n      try {\n        const response = await axiosGetWithRetry(\n          `http://${directusService}:8055/files/${fileId}`,\n          { headers: { Authorization: `Bearer ${directusToken}` } }\n        );\n        const filename_disk = response.data.data.filename_disk;\n        // Retira o \"s3\" pois já está incluso na URL\n        const finalUrl = `${host}/directus/${filename_disk}`;\n        return { type: 'file', fileId, url: finalUrl };\n      } catch (err) {\n        return {\n          type: 'file',\n          fileId,\n          error: err.message,\n          status: err.response?.status,\n          responseData: err.response?.data,\n        };\n      }\n    })\n  );\n\n  // Prepara URLs para scraping (se existirem)\n  const originalUrlsToScrape = originalUrls.map(url => ({ type: 'original', url }));\n  const allUrlsToScrape = [\n    ...fileResults.filter(item => item.url),\n    ...originalUrlsToScrape\n  ];\n\n  // Executa scraping com retry para cada URL (se houver)\n  const scrapeResults = await Promise.all(\n    allUrlsToScrape.map(async (item) => {\n      try {\n        const scrapingUrl = `https://r.jina.ai/${item.url}`;\n        const response = await axiosGetWithRetry(\n          scrapingUrl,\n          { headers: { Authorization: `Bearer ${jinaToken}` } }\n        );\n        return { ...item, scrapeData: response.data };\n      } catch (err) {\n        return {\n          ...item,\n          scrapeError: err.message,\n          status: err.response?.status,\n          errorData: err.response?.data,\n        };\n      }\n    })\n  );\n\n  // Agrega e limpa conteúdo dos scrapings para gerar chunks e descrição\n  const scrapedTexts = scrapeResults.map(item => item.scrapeData ? JSON.stringify(item.scrapeData) : '');\n  const aggregatedContent = scrapedTexts.join(' ');\n  const cleanedContent = aggregatedContent.replace(/[^a-zA-Z0-9\\s]/g, ' ');\n\n  // Gera chunks dos scrapings (mantendo conteúdo orgânico por scraping)\n  const chunks = [];\n  scrapeResults.forEach(item => {\n    if (item.scrapeData) {\n      const text = JSON.stringify(item.scrapeData);\n      const itemChunks = createChunks(text, chunkLength, overlapPercentage);\n      itemChunks.forEach(chunk => {\n        chunks.push({ chunk, source: item.url });\n      });\n    }\n  });\n\n  // Geração da descrição do conteúdo\n  const blockSize = 200000;\n  let finalDescription;\n  async function enviarPrompt(promptContent) {\n    const response = await axios.post(\n      'https://openrouter.ai/api/v1/chat/completions',\n      {\n        model: 'openai/gpt-4o-mini',\n        messages: [{ role: 'user', content: promptContent }]\n      },\n      { headers: { Authorization: `Bearer ${openrouterKey}` } }\n    );\n    return response.data;\n  }\n  if (cleanedContent.length > blockSize) {\n    const blocks = [];\n    for (let i = 0; i < cleanedContent.length; i += blockSize) {\n      blocks.push(cleanedContent.substring(i, i + blockSize));\n    }\n    const summaries = await Promise.all(\n      blocks.map(async (block) => {\n        const prompt = `<dados>${block}</dados>\\n` + SUMMARY_PROMPT.replace('{conteudo}', block);\n        try {\n          const summaryResponse = await enviarPrompt(prompt);\n          return (summaryResponse.choices && summaryResponse.choices[0].message.content) || '';\n        } catch (err) {\n          return '';\n        }\n      })\n    );\n    const aggregatedSummaries = summaries.join(' ');\n    const descriptionPrompt = `<dados>${aggregatedSummaries}</dados>\\n` + FINAL_DESCRIPTION_PROMPT.replace('{conteudo}', aggregatedSummaries);\n    try {\n      const descriptionResponse = await enviarPrompt(descriptionPrompt);\n      finalDescription = descriptionResponse;\n    } catch (err) {\n      finalDescription = { error: err.message, status: err.response?.status, errorData: err.response?.data };\n    }\n  } else {\n    const directPrompt = `<dados>${cleanedContent}</dados>\\n` + DIRECT_DESCRIPTION_PROMPT.replace('{conteudo}', cleanedContent);\n    try {\n      const descriptionResponse = await enviarPrompt(directPrompt);\n      finalDescription = descriptionResponse;\n    } catch (err) {\n      finalDescription = { error: err.message, status: err.response?.status, errorData: err.response?.data };\n    }\n  }\n  \n  // Extrai somente o conteúdo da descrição, se disponível\n  if (finalDescription && finalDescription.choices && finalDescription.choices[0] && finalDescription.choices[0].message) {\n    finalDescription = finalDescription.choices[0].message.content;\n  }\n\n  // Atualiza o campo \"description\" na tabela \"knowledge\" no Directus\n  try {\n    const updateResponse = await updateDirectusDescription(finalDescription, globalVars, globalData.id);\n    console.log(\"Directus update response:\", updateResponse);\n  } catch (error) {\n    console.error(\"Falha ao atualizar o Directus após 3 tentativas:\", error.message);\n  }\n\n  // Geração dos vetores a partir dos chunks\n  for (const chunkItem of chunks) {\n    const vectorPromptBody = {\n      messages: [\n        {\n          role: \"user\",\n          content: `Você é um agente interno de um sistema especializado em extrair perguntas e respostas de documentos. Sua tarefa é analisar o chunk fornecido, que representa um segmento de um documento completo, e gerar perguntas e respostas baseadas nas informações contidas nele. \n\nContexto do documento: ${globalData.Instruction_Prompt}\n\nDiretrizes:\n1. Extraia informações relevantes (respostas) do chunk fornecido. Essas informações devem ser associadas a perguntas principais, mantendo sempre o tom e o estilo do texto original.\n2. Para cada resposta extraída:\n   - Crie uma pergunta principal (q) que tenha como resposta a informação extraída (a).\n   - Identifique o trecho específico do documento (t) de onde a resposta foi retirada.\n   - Formule perguntas alternativas (sq) que poderiam ser feitas para obter a mesma resposta (a).\n3. Sempre que encontrar múltiplas informações relevantes, crie múltiplas perguntas e respostas.\n4. Mantenha a originalidade e fidelidade ao conteúdo fornecido.\n\nChunk:\n${chunkItem.chunk}`\n        }\n      ],\n      response_format: {\n        type: \"json_schema\",\n        json_schema: {\n          name: \"extracted_data\",\n          strict: true,\n          schema: {\n            type: \"object\",\n            properties: {\n              results: {\n                type: \"array\",\n                items: {\n                  type: \"object\",\n                  properties: {\n                    a: { type: \"string\", description: \"A resposta ou informação extraída.\" },\n                    t: { type: \"string\", description: \"O trecho exato do documento de onde a resposta foi retirada.\" },\n                    q: { type: \"string\", description: \"A pergunta principal que leva à resposta.\" },\n                    sq: { type: \"array\", items: { type: \"string\" }, description: \"Perguntas alternativas que poderiam obter a mesma resposta.\" }\n                  },\n                  required: [\"a\", \"t\", \"q\", \"sq\"],\n                  additionalProperties: false\n                }\n              }\n            },\n            required: [\"results\"],\n            additionalProperties: false\n          }\n        }\n      }\n    };\n    try {\n      const vectorResponse = await axios.post(\n        'https://openrouter.ai/api/v1/chat/completions',\n        vectorPromptBody,\n        { headers: { Authorization: `Bearer ${openrouterKey}` } }\n      );\n      // Envia a resposta para o webhook incluindo global_vars, knowledge_trigger_id, pinecone_host e namespace\n      await axios.post(\n        `http://${n8nWebhookService}:5678/webhook/vector`,\n        {\n          ...vectorResponse.data,\n          global_vars: globalVars,\n          knowledge_trigger_id: knowledgeTriggerId,\n          pinecone_host: globalData.pinecone_host,\n          namespace: globalData.namespace\n        }\n      );\n    } catch (err) {\n      console.error('Erro ao gerar vetor para chunk:', err.message);\n    }\n    // Aguarda 10 segundos antes da próxima requisição\n    await delay(10000);\n  }\n\n  return { files: fileResults, scraping: scrapeResults, description: finalDescription, chunks };\n}\n\nreturn processScraping()\n  .then(result => [{ json: result }])\n  .catch(error => {\n    console.error('Erro geral:', { message: error.message, details: error });\n    return [{ json: { error: error.message, details: error } }];\n  });"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        544,
        1392
      ],
      "id": "f3cb1b01-08e1-4bc7-b2df-d8467066b53d",
      "name": "Process Docs"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "vector",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        864,
        1392
      ],
      "id": "f1335d12-6bb3-4c2b-a5f1-934ebd214279",
      "name": "Vector Trigger",
      "webhookId": "1fb6174c-df10-445a-b64f-b11982679e1e"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/embeddings",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer {{ $('Vector Trigger').first().json.body.global_vars.openai_key }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "input",
              "value": "={{ `Context: ${$('Split Vectors').item.json.t} Question: ${$('Split Vectors').item.json.q} Answer: ${$('Split Vectors').item.json.a} Similar Questions: ${$('Split Vectors').item.json.sq.join(\", \")}` }}"
            },
            {
              "name": "model",
              "value": "text-embedding-3-small"
            },
            {
              "name": "dimensions",
              "value": "={{ 1536 }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1472,
        1392
      ],
      "id": "55126fe4-f94d-436d-aafa-213ef4c52734",
      "name": "Embeddings",
      "notesInFlow": true
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "={{ $json.body.choices[0].message.content.parseJson() }}",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1072,
        1392
      ],
      "id": "d0ed8626-0baa-4348-a013-97a331aa17e5",
      "name": "Parse JSON 2"
    },
    {
      "parameters": {
        "fieldToSplitOut": "results",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        1264,
        1392
      ],
      "id": "99f4bc12-253e-4f0f-ab9d-18d4dad9d885",
      "name": "Split Vectors"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH new_vector AS (\n  INSERT INTO vectors \n    (id, date_created, question, answer, context, similar_questions, knowledge_id)\n  VALUES \n    (\n      uuid_generate_v4(), \n      NOW(), \n      '{{ $('Parse JSON 2').item.json.results[$itemIndex].q }}', \n      '{{ $('Parse JSON 2').item.json.results[$itemIndex].a }}', \n      '{{ $('Parse JSON 2').item.json.results[$itemIndex].t }}', \n      '{{ $('Parse JSON 2').item.json.results[$itemIndex].sq.join(',') }}', \n      {{ $('Vector Trigger').item.json.body.knowledge_trigger_id }}\n    )\n  RETURNING id AS vector_id\n),\nnew_dimension AS (\n  INSERT INTO dimensions (values, date_created, vector_id)\n  SELECT '{{ $('Embeddings').item.json.data[0].embedding.join(',') }}', NOW(), vector_id\n  FROM new_vector\n  RETURNING vector_id\n)\nINSERT INTO vectors_status (vector_id, value)\nSELECT vector_id, '#2ECDA7'\nFROM new_vector\nRETURNING vector_id;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        1664,
        1392
      ],
      "id": "ba8adbbc-fa9d-4eb9-94da-18c4abcddba5",
      "name": "Add Vectors",
      "credentials": {
        "postgres": {
          "id": "Iz6AdCvM8BbJ72YV",
          "name": "Postgres directus95b506d"
        }
      }
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "rag",
        "responseMode": "lastNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        144,
        1712
      ],
      "id": "f43c0f28-423d-40aa-b7ab-72cd65ef9d9a",
      "name": "RAG Input",
      "webhookId": "8c2c32ce-b05e-4e1f-8c61-a4279aabd479"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Por favor, analise a entrada do usuário e o histórico recente. \n\nResponda para a IA principal de forma objetiva sem incluir informações que não estejam presentes no retoro Rag.\nMas sempre veja o contexto inteiro do Rag para uma resposta mais acertiva.\n\nEntrada do usuário: \n<user_input>{{ $('RAG Input').first().json.body.content }}</user_input>\n\nHistórico das últimas 10 mensagens: \n<conversation_history>{{ $('Get History').first().json.chat_histories.map(item => item.message).slice(-10).toJsonString() }}</conversation_history>\n\nUtilize a Tool Think para refletir melhor e para trabalhar o contexto de histórico de mensagens, com o conteúdo obtido no RAG para dar a melhor resposta. Seja objetivo.\n\n",
        "options": {
          "systemMessage": "=Você é um agente especializado em realizar buscas precisas no banco vetorial para fornecer contexto relevante à inteligência artificial principal.\n\nObjetivo Principal\nAnalisar a entrada do usuário e o histórico de mensagens para decidir se deve invocar a tool 'retriever' e realizar buscas eficientes, priorizando relevância contextual sobre similaridade vetorial.\n\nDiretrizes de Busca\nBusca desnecessária:\nSe a entrada do usuário for composta exclusivamente por uma saudação isolada (ex: \"Olá\", \"Oi\", \"Bom dia\"), retorne:\n\"Busca desnecessária.\"\n\nAtenção: Se a saudação vier acompanhada de qualquer outra palavra ou informação (ex: \"Olá, gostaria de agendar uma consulta\"), NÃO ignore. Considere todo o texto para busca.\n\nPalavras simples e termos contextuais:\nNão ignore palavras aparentemente simples (ex: \"presencial\", \"online\", \"remoto\", \"agora\", \"hoje\") se elas fizerem parte do contexto da solicitação. Elas podem ser essenciais para a relevância da busca.\n\nAnálise de contexto:\nExamine detalhadamente o histórico para entender o contexto completo da conversa.\n\nPrincípio da precaução:\nNa dúvida, sempre invoque a tool 'retriever'.\n\nNenhuma informação encontrada:\nSe nenhuma informação relevante for encontrada, retorne:\n\"Nenhuma informação relevante encontrada.\"\n\nProcessamento de Resultados (CRÍTICO)\nAvaliação de relevância:\nAnalise TODOS os resultados retornados, não apenas o de maior score.\n\nPriorização contextual:\nUm resultado com score menor pode ser mais relevante para a pergunta específica.\n\nVerificação de contradições:\nIdentifique e resolva contradições entre diferentes resultados.\n\nCombinação inteligente:\nSintetize informações de múltiplos resultados quando necessário para fornecer uma resposta completa.\n\nVerificação de precisão:\nConfirme que sua interpretação dos resultados é fiel ao conteúdo original. Retorno conteúdo de forma original, sem altera-lo ou incluir frases como \"Baseado nas informações disponíveis...\"\n\nRegras para Invocar o 'Retriever'\nAnalise cuidadosamente a entrada do usuário e as descrições dos conhecimentos disponíveis.\n\nConsidere relevante qualquer pergunta relacionada aos documentos nos conhecimentos disponíveis.\n\nUse as descrições dos conhecimentos para identificar o knowledge_id mais adequado:\n\njson\n<knowledge_metadata>{{ $('Get History').first().json.knowledge.map(item => ({ knowledge_id: item.id, description: item.description })).toJsonString() }}</knowledge_metadata>\nUse múltiplas queries para cobrir todas as possibilidades em solicitações amplas ou ambíguas.\n\nFormatação da Resposta Final\nPrecisão: Forneça apenas o conteúdo necessário para responder à solicitação. Você não responde ao usuário e sim o Agente principal. \n\nObjetividade: Evite interpretações adicionais ou suposições.\n\nTransparência: Se combinar informações de múltiplos resultados, organize-as logicamente.\n\nVerificação final: Confirme que sua resposta é consistente com todos os resultados relevantes.\n\nInstruções Adicionais\nSe houver qualquer relação potencial entre a solicitação e os conhecimentos disponíveis, realize a busca imediatamente.\n\nAo invocar o 'retriever', faça perguntas claras e precisas, alinhadas ao contexto da entrada do usuário. IMPORTANTE: Cite exatamente a consulta do usuário primeiro, seguido da sua interpretação para busca dupla. Seja muito breve na interpretação para não alterar o contexto principal do usuário.\n\nO foco é fornecer contexto relevante e preciso para a AI principal, priorizando a qualidade da informação sobre a similaridade vetorial.\n\nSugestão Extra\nExemplo de saudações isoladas: \"Oi\", \"Olá\", \"Bom dia\", \"Boa tarde\", \"Boa noite\".\nExemplo de saudações compostas (NÃO ignorar): \"Oi, gostaria de marcar uma consulta online\", \"Bom dia, tem vaga presencial?\"",
          "passthroughBinaryImages": true
        }
      },
      "id": "73e907c7-5ed9-45c5-bce7-dcb8d7164a57",
      "name": "RAG Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [
        544,
        1712
      ],
      "retryOnFail": false,
      "executeOnce": false
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH knowledge_descriptions AS (\n  SELECT json_agg(\n    json_build_object(\n      'id', k.id,\n      'description', k.description,\n      'pinecone_host', ph.value,\n      'namespace', ns.value\n    )\n  ) AS knowledge_data\n  FROM knowledge_ai_agents kaa\n  JOIN knowledge k ON k.id = kaa.knowledge_id\n  LEFT JOIN pinecone_host ph ON ph.id = k.pinecone_host_id\n  LEFT JOIN namespace ns ON ns.id = k.name_id\n  WHERE kaa.ai_agents_id = {{ $('RAG Input').item.json.body.mapping.parseJson().system.ai_agent_id }}\n),\nchat_histories AS (\n  SELECT json_agg(ch.*) AS chat_items\n  FROM core_chat_histories ch\n  WHERE ch.session_id = '{{ $('RAG Input').item.json.body.mapping.parseJson().system.conversations_id }}'\n)\nSELECT\n  (SELECT knowledge_data FROM knowledge_descriptions) AS knowledge,\n  (SELECT chat_items FROM chat_histories) AS chat_histories;\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        352,
        1712
      ],
      "id": "a00b2ca3-ed03-4468-91e2-b7300b15f0e4",
      "name": "Get History",
      "credentials": {
        "postgres": {
          "id": "Iz6AdCvM8BbJ72YV",
          "name": "Postgres directus95b506d"
        }
      }
    },
    {
      "parameters": {
        "content": "",
        "height": 660,
        "width": 1860,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        32,
        1264
      ],
      "typeVersion": 1,
      "id": "94c0b839-b301-4198-9ed5-788a60c21655",
      "name": "Sticky Note8"
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 1100,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        48,
        1600
      ],
      "id": "37234a60-eea9-434c-b605-4a6417389f8e",
      "name": "Sticky Note9"
    },
    {
      "parameters": {
        "content": "",
        "width": 300,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        672,
        1952
      ],
      "typeVersion": 1,
      "id": "68e53c8f-93e9-44bc-b703-e6b18b0849f5",
      "name": "Sticky Note3"
    },
    {
      "parameters": {
        "model": "={{ $('RAG Input').item.json.body.mapping.parseJson().system.model }}",
        "options": {
          "temperature": 0.7
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        544,
        1984
      ],
      "id": "a4ecf0e2-6532-466b-9d45-a0aad854381f",
      "name": "OpenRouter ",
      "credentials": {
        "openRouterApi": {
          "id": "6a7OLAi8teUd9jSw",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 700,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        48,
        1280
      ],
      "id": "0e7883ac-04cf-42e0-a4fd-01a86e2c6fd5",
      "name": "Sticky Note10"
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 1100,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        768,
        1280
      ],
      "id": "0569d5f6-d998-4be1-ab2b-749167bfca6c",
      "name": "Sticky Note11"
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "={\n  \"chatwoot\": {\n    \"account_id\": {{ $('Consumer').first().json.body.account.id }},\n    \"user_token\" : \"{{ $('Get Vars').item.json.ai_agents.user_token }}\",\n    \"contact_id\": {{ $('Consumer').first().json.body.conversation.contact_inbox.contact_id }},\n\n    \"conversation_id\": {{ $('Consumer').first().json.body.conversation.messages[0].conversation_id }},\n    \"sender_type\": {{ JSON.stringify($('Consumer').first().json.body.conversation.messages[0].sender_type) }},\n    \"bot_token\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.bot_token) }},\n\"current_labels\": {{ $json.current_labels === null ? null : JSON.stringify($json.current_labels) }},\n\n   \"conversation_status\": {{ JSON.stringify($json.current_status) }},\n\n    \"assignee\": {{ JSON.stringify($('Consumer').first().json.body.conversation?.meta?.assignee?.name || null ) }},\n    \n    \"content\": {{ JSON.stringify(\n      ($('Consumer').first().json.body?.content || '')\n        .replace(\n          /^\\*\\*(.*?)\\*\\*\\n\\n/,\n          $('Consumer').first().json.body.sender.identifier?.match(/@g\\.us$/) ? '' : '$&'\n        )\n        .replace(\n          new RegExp('@' + ($('Get Vars').first().json.ai_agents.phone_number || '').replace(/\\D/g, ''), 'g'),\n          '@YOU'\n        )\n        .trim()\n    ) }},\n    \n    \"data_url\": {{ JSON.stringify(\n        $('Consumer').first().json.body.conversation.messages?.[0]?.attachments?.[0]?.data_url || null\n      )\n    }},\n    \n    \"message_id\": {{ $('Consumer').first().json.body.id }},\n    \n    \"channel\": {{\n      JSON.stringify(\n        $('Consumer').first().json.body.conversation.channel === 'Channel::Api' \n        ? (\n            /@s\\.whatsapp\\.net$/.test($('Consumer').first().json.body.sender.identifier) \n            ? 'WhatsApp Web' \n            : /@g\\.us$/.test($('Consumer').first().json.body.sender.identifier) \n            ? 'WhatsApp Web Group' \n            : $('Consumer').first().json.body.conversation.channel.replace('Channel::', '')\n          ) \n        : $('Consumer').first().json.body.conversation.channel.replace('Channel::', '')\n      )\n    }},\n    \n    \"user_name\": {{ JSON.stringify(\n      $('Consumer').first().json.body.sender.identifier?.match(/@g\\.us$/)\n        ? (\n            $('Consumer').first().json.body?.content?.match(/^\\*\\*(.*?)\\*\\*/)?.[1] || ''\n          )\n        : $('Consumer').first().json.body.sender?.name || ''\n    ) }},\n\n    \"phone_number\": {{ JSON.stringify($('Consumer').first().json.body.sender.phone_number) || null }}\n  },\n  \n  \"system\": {\n    \"cooldown\": {{ $('Get Vars').first().json.ai_agents.cooldown }},\n    \"workflow_path\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.workflow_path) }},\n    \"model\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.model) }},\n    \"openai_key\": {{ JSON.stringify($('Get Vars').first().json.global_vars.openai_key) }},\n    \"directus_token\": {{ JSON.stringify($('Get Vars').first().json.global_vars.directus_token) }},\n    \"stirling_pdf_key\": {{ JSON.stringify($('Get Vars').first().json.global_vars.stirling_pdf_key) }},\n    \"elevenlabs_key\": \"{{ $('Get Vars').first().json.global_vars.elevenlabs_key }}\",\n    \"conversations_id\": {{ JSON.stringify($('Get Vars').first().json.conversations.id) }},\n    \"context_window\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.context_window) }},\n    \"enabled_condition\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.enabled_condition) }},\n    \"allow_whatsapp_groups\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.allow_whatsapp_groups) }},\n    \"allow_human_interruption\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.allow_human_interruption) }},\n    \"agent_phone_number\": {{ JSON.stringify(($('Get Vars').first().json.ai_agents.phone_number || '').replace(/\\D/g, '')) }},\n    \"agent_mentioned\": {{ JSON.stringify(($('Consumer').first().json.body?.content || '' ).includes('@' + ($('Get Vars').first().json.ai_agents.phone_number || '').replace(/\\D/g, ''))) }},\n    \"agent_name\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.name) }},\n    \"user_type\": {{ JSON.stringify($('Get Vars').first().json.users.type) }},\n    \"output_format\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.output_format) }},\n    \"elevenlabs_model\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.elevenlabs_model) }},\n    \"elevenlabs_voice\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.elevenlabs_voice) }},\n    \"chatwoot_service\": {{ JSON.stringify($('Get Vars').first().json.global_vars.chatwoot_service) }},\n    \"n8n_webhook_service\": {{ JSON.stringify($('Get Vars').first().json.global_vars.n8n_webhook_service) }},\n    \"stirling_pdf_service\": {{ JSON.stringify($('Get Vars').first().json.global_vars.stirling_pdf_service) }},\n    \"directus_service\": {{ JSON.stringify($('Get Vars').first().json.global_vars.directus_service) }},\n    \"enabled_rag\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.enabled_rag) }},\n    \"ai_agent_id\": {{ JSON.stringify($('Get Vars').first().json.ai_agents.id) }},\n    \"pinecone_key\": {{ JSON.stringify($('Get Vars').first().json.global_vars.pinecone_key) }},\n    \"downtime\": {{ new Date(\"1970-01-01T\" + $('Get Vars').first().json.ai_agents.downtime + \"Z\").getTime() / 1000 }},\n    \"clientId\": {{ JSON.stringify($('Get Vars').first().json.global_vars.clientId) }},\n    \"clientSecret\": {{ JSON.stringify($('Get Vars').first().json.global_vars.clientSecret) }},\n    \"refreshToken\": {{ JSON.stringify($('Get Vars').first().json.global_vars.refreshToken) }},\n    \"accessToken\": {{ JSON.stringify($('Get Vars').first().json.global_vars.accessToken) }}\n  }\n}\n\n\n",
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        752,
        112
      ],
      "id": "3c1414d8-3b08-4c55-af1f-c346b9b00b3d",
      "name": "Mapping"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        1744,
        624
      ],
      "id": "e54aad6f-07e5-4cf1-8dd8-8b2d4b1ed3d8",
      "name": "No Operation "
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\n\nasync function runTool() {\n  const logArray = [];\n  let currentStatus = \"\";\n  let currentLabels = [];\n  let enabledCondition = \"\";\n  let senderType = \"\";\n  let labelsAtualizadas = [];\n\n  try {\n    console.log(\"Obtendo data de última interação e downtime...\");\n    logArray.push(\"Obtendo data de última interação e downtime...\");\n\n    // Obter dados básicos\n    const dateUpdatedStr = $('Get Vars').first().json.users.date_updated;\n    const downtimeStr = $('Get Vars').first().json.ai_agents.downtime;\n    enabledCondition = $('Get Vars').first().json.ai_agents.enabled_condition;\n\n    // Log dos valores obtidos\n    console.log(`date_updated: ${dateUpdatedStr}`);\n    console.log(`downtime: ${downtimeStr}`);\n    logArray.push(`date_updated: ${dateUpdatedStr}`, `downtime: ${downtimeStr}`);\n\n    // Verificar se o downtime está desativado\n    if (downtimeStr === \"00:00:00\") {\n      console.log(\"Downtime é 00:00:00. Nenhuma ação será realizada.\");\n      logArray.push(\"Downtime é 00:00:00. Nenhuma ação será realizada.\");\n      currentStatus = $('Consumer').first().json.body.conversation.status;\n      currentLabels = $('Consumer').first().json.body.conversation.labels || [];\n      return [{ json: { current_status: currentStatus, logs: logArray } }];\n    }\n\n    // --- CORREÇÃO DO CÁLCULO DE TEMPO ---\n    let diffMs = 0;\n    if (dateUpdatedStr) {\n        const lastUpdated = new Date(dateUpdatedStr);\n        const now = new Date();\n        diffMs = now - lastUpdated;\n    } else {\n        logArray.push(\"Primeira interação detectada (date_updated nulo). Diferença de tempo definida como 0.\");\n    }\n    const diffMinutes = (diffMs / 60000).toFixed(2);\n    // --- FIM DA CORREÇÃO ---\n\n    // Converter downtime para milissegundos\n    const [hours, minutes, seconds] = downtimeStr.split(':').map(Number);\n    const downtimeMs = ((hours * 3600) + (minutes * 60) + seconds) * 1000;\n    const downtimeMinutes = (downtimeMs / 60000).toFixed(2);\n\n    console.log(`diff: ${diffMinutes} minutos, downtime: ${downtimeMinutes} minutos`);\n    logArray.push(`diff: ${diffMinutes} minutos`, `downtime: ${downtimeMinutes} minutos`);\n\n    // Obter dados da conversa\n    const conversation = $('Consumer').first().json.body.conversation;\n    const conversationStatus = conversation.status;\n    const convId = conversation.messages[0]?.conversation_id;\n\n    const chatwootService = $('Get Vars').first().json.global_vars.chatwoot_service;\n    const accountId = $('Consumer').first().json.body.account.id;\n    const userToken = $('Get Vars').first().json.ai_agents.user_token;\n\n    try {\n      const labelsResponse = await axios.get(\n        `http://${chatwootService}:3000/api/v1/accounts/${\n          encodeURIComponent(accountId)}/conversations/${\n          encodeURIComponent(convId)}/labels`,\n        {\n          headers: {\n            \"api_access_token\": userToken,\n            \"Content-Type\": \"application/json\"\n          }\n        }\n      );\n      \n      currentLabels = labelsResponse.data.payload || [];\n      console.log(\"Labels atualizados obtidos:\", currentLabels);\n      logArray.push(\"Labels atualizados obtidos com sucesso\");\n      \n    } catch (err) {\n      console.error(\"Erro ao obter labels:\", err.message);\n      logArray.push(`Erro ao obter labels: ${err.message}`);\n      currentLabels = []; // Fallback seguro\n    }\n\n    if (!Array.isArray(currentLabels)) {\n      console.warn(\"Formato inválido de labels. Convertendo para array.\");\n      currentLabels = [];\n    }\n\n    senderType = conversation.messages[0].sender_type;\n    const assigneeID = conversation.messages[0].conversation.assignee_id;\n\n    console.log(`status da conversa: ${conversationStatus}`, `ID da conversa: ${convId}`);\n    logArray.push(`status da conversa: ${conversationStatus}`, `ID da conversa: ${convId}`);\n\n    currentStatus = conversationStatus;\n\n    // Lógica para pending_status\n    if (enabledCondition !== \"pending_status\") {\n        console.log(\"Condições open_status atendidas...\");\n        logArray.push(\"Condições open_status atendidas...\");\n        const toggleUrl = `http://${chatwootService}:3000/api/v1/accounts/${\n          encodeURIComponent(accountId)}/conversations/${\n          encodeURIComponent(convId)}/toggle_status`;\n\n        try {\n          await axios.post(\n            toggleUrl,\n            { status: \"open\" },\n            { headers: { api_access_token: userToken } }\n          );\n          currentStatus = \"open\";\n          logArray.push(\"Status alterado para open com sucesso\");\n        } catch (err) {\n          console.error(\"Erro na mudança de status:\", err.message);\n          logArray.push(`Erro na mudança de status: ${err.message}`);\n        }\n    }\n\n    // Lógica para reativar a IA após o downtime\n    if (diffMs >= downtimeMs && currentLabels.includes('ia-pausada')  && senderType !== 'User') {\n        console.log(\"Condições de reativação por downtime atendidas...\");\n        logArray.push(\"Condições de reativação por downtime atendidas...\");\n\n        labelsAtualizadas = [\n          ...currentLabels.filter(tag => tag !== \"ia-pausada\"),\n          \"ia-ativada\"\n        ];\n\n        const labelsUrl = `http://${chatwootService}:3000/api/v1/accounts/${\n          encodeURIComponent(accountId)}/conversations/${\n          encodeURIComponent(convId)}/labels`;\n\n        try {\n          await axios.post(\n            labelsUrl,\n            { labels: labelsAtualizadas },\n            { headers: { \"Content-Type\": \"application/json\", \"api_access_token\": userToken } }\n          );\n          currentLabels = labelsAtualizadas;\n          logArray.push(\"Labels (ia-ativada) atualizadas com sucesso\");\n        } catch (err) {\n          console.error(\"Erro na atualização de labels:\", err.message);\n          logArray.push(`Erro na atualização de labels: ${err.message}`);\n        }\n    } else {\n        const motivo = diffMs < downtimeMs ? \n          \"tempo insuficiente desde a última interação\" : \n          !currentLabels.includes('ia-pausada') ? \"label 'ia-pausada' não encontrada\" :\n          \"última mensagem foi do usuário\";\n        logArray.push(`Nenhuma ação de reativação por downtime: ${motivo}`);\n    }\n\n    // Lógica para ativar a IA se não houver tags de controle\n    if ( (enabledCondition === \"all_status\") || (enabledCondition === \"not_assigned\" && !assigneeID) || (enabledCondition === \"pending_status\" && conversationStatus === \"pending\") ) {\n        if ( !currentLabels.includes('ia-pausada') && !currentLabels.includes('ia-ativada') && !currentLabels.includes('ia-desativada') && senderType !== 'User' ) {\n            console.log(\"Condições para ativação inicial da IA atendidas...\");\n            logArray.push(\"Condições para ativação inicial da IA atendidas...\");\n            \n            labelsAtualizadas = [...currentLabels, \"ia-ativada\"];\n            const labelsUrl = `http://${chatwootService}:3000/api/v1/accounts/${\n              encodeURIComponent(accountId)}/conversations/${\n              encodeURIComponent(convId)}/labels`;\n\n            try {\n              await axios.post(\n                labelsUrl,\n                { labels: labelsAtualizadas },\n                { headers: { \"Content-Type\": \"application/json\", \"api_access_token\": userToken } }\n              );\n              currentLabels = labelsAtualizadas;\n              logArray.push(\"Label 'ia-ativada' adicionada com sucesso.\");\n            } catch (err) {\n              console.error(\"Erro na atualização de labels:\", err.message);\n              logArray.push(`Erro na atualização de labels: ${err.message}`);\n            }\n        } \n    }\n\n    // Apaga tags ia-pausada e ia-ativa, se ia-desativada está presente\n    if ( currentLabels.includes('ia-desativada') ) {\n        console.log(\"Label 'ia-desativada' encontrada. Removendo outras labels de controle.\");\n        logArray.push(\"Label 'ia-desativada' encontrada. Removendo outras labels de controle.\");\n\n        const labelsAposLimpeza = currentLabels.filter(tag => tag !== \"ia-ativada\" && tag !== \"ia-pausada\");\n\n        // Apenas faz a chamada se houver mudança\n        if (labelsAposLimpeza.length < currentLabels.length) {\n            const labelsUrl = `http://${chatwootService}:3000/api/v1/accounts/${\n              encodeURIComponent(accountId)}/conversations/${\n              encodeURIComponent(convId)}/labels`;\n\n            try {\n              await axios.post(\n                labelsUrl,\n                { labels: labelsAposLimpeza },\n                { headers: { \"Content-Type\": \"application/json\", \"api_access_token\": userToken } }\n              );\n              currentLabels = labelsAposLimpeza;\n              logArray.push(\"Labels de controle removidas com sucesso.\");\n            } catch (err) {\n              console.error(\"Erro na atualização de labels:\", err.message);\n              logArray.push(`Erro na atualização de labels: ${err.message}`);\n            }\n        }\n    } \n\n    return [{ json: { current_status: currentStatus, current_labels: currentLabels, logs: logArray } }];\n  } catch (error) {\n    console.error(\"Erro geral:\", error.message);\n    logArray.push(`Erro geral: ${error.message}`);\n    return [{ json: { error: error.message, current_status: currentStatus, current_labels: currentLabels, logs: logArray } }];\n  }\n}\n\nreturn runTool();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        544,
        112
      ],
      "id": "55f4f038-0e0f-43dc-9043-13e9d8fa6e2c",
      "name": "Downtime",
      "alwaysOutputData": false
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        1344,
        832
      ],
      "id": "6e79b760-5a8a-4268-938b-a45e30486f30",
      "name": "No Operation 0"
    },
    {
      "parameters": {
        "triggerMode": "listenTrigger",
        "channelName": "specific_channel",
        "options": {}
      },
      "type": "n8n-nodes-base.postgresTrigger",
      "typeVersion": 1,
      "position": [
        1296,
        1696
      ],
      "id": "7067b511-d9ff-4a2d-b1e5-62a37a6ea856",
      "name": "Postgres Trigger",
      "credentials": {
        "postgres": {
          "id": "Iz6AdCvM8BbJ72YV",
          "name": "Postgres directus95b506d"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "async function main() {\n  const trimLog = (msg, limit = 100) =>\n    (typeof msg === 'string' && msg.length > limit ? msg.substring(0, limit) + '...' : msg);\n\n  let logs = [];\n\n  try {\n    const payload = $('Postgres Trigger').first().json.payload;\n    logs.push(\"Payload carregado.\");\n    console.log(\"Payload:\", trimLog(JSON.stringify(payload)));\n\n    const op = payload.operation;\n    logs.push(\"Operação: \" + op);\n    console.log(\"Operação:\", op);\n\n    // Adaptação para Qdrant\n    let pineconeHost = payload.data.pinecone_host;\n    if (!pineconeHost.startsWith(\"http\")) {\n      pineconeHost = \"http://\" + pineconeHost;\n      logs.push(\"Prefixo 'http://' adicionado.\");\n      console.log(\"pinecone_host modificado:\", pineconeHost);\n    }\n\n    const pineconeHeaders = {\n      \"Content-Type\": \"application/json\",\n      ...(payload.global_vars.pinecone_key && { \"Authorization\": `Bearer ${payload.global_vars.pinecone_key}` })\n    };\n    logs.push(\"Headers Pinecone configurados.\");\n    console.log(\"Headers Pinecone:\", pineconeHeaders);\n\n    let endpoint, options, response, mainResponse;\n\n    // Operação de DELETE\n    if (op === \"DISABLED\" || op === \"DELETE\") {\n      endpoint = `${pineconeHost}/collections/${payload.data.namespace}/points/delete`;\n      logs.push(\"Endpoint para deleção: \" + endpoint);\n      console.log(\"Endpoint de deleção:\", endpoint);\n\n      const deleteBody = { points: [payload.data.id] };\n      options = { method: \"POST\", uri: endpoint, headers: pineconeHeaders, body: deleteBody, json: true };\n      response = await this.helpers.request(options);\n      logs.push(\"Resposta da deleção recebida.\");\n      mainResponse = response;\n\n    // Operações de UPSERT\n    } else if ((op === \"UPDATE\" || op === \"INSERT\") && payload.data.enabled === true) {\n      let embedding;\n\n      // Lógica para INSERT\n      if (op === \"INSERT\") {\n        const directusHost = \"http://\" + payload.global_vars.directus_service + \":8055\";\n        const directusEndpoint = directusHost + \"/items/dimensions\";\n        const directusHeaders = {\n          \"Authorization\": \"Bearer \" + payload.global_vars.directus_token,\n          \"Content-Type\": \"application/json\"\n        };\n        \n        const directusQueryOptions = {\n          method: \"GET\",\n          uri: directusEndpoint,\n          qs: { \"filter[vector_id][_eq]\": payload.data.id },\n          headers: directusHeaders,\n          json: true\n        };\n\n        const directusRecord = await this.helpers.request(directusQueryOptions);\n        if (directusRecord?.data?.length > 0 && directusRecord.data[0].values) {\n          const directusValues = directusRecord.data[0].values;\n          embedding = typeof directusValues === \"string\" ? \n            directusValues.split(\",\").map(Number) : \n            directusValues;\n          logs.push(\"Embedding reutilizado do Directus\");\n        }\n      }\n\n      // Geração de embedding via OpenAI se necessário\n      if (!embedding) {\n        const openAIHeaders = {\n          \"Authorization\": \"Bearer \" + payload.global_vars.openai_key,\n          \"Content-Type\": \"application/json\"\n        };\n        \n        const openAIInput = `Context: ${payload.data.context} Question: ${payload.data.question} Answer: ${payload.data.answer}`;\n        const openAIBody = {\n          input: openAIInput,\n          model: \"text-embedding-3-small\",\n          dimensions: 1536\n        };\n\n        const openAIResponse = await this.helpers.request({\n          method: \"POST\",\n          uri: \"https://api.openai.com/v1/embeddings\",\n          headers: openAIHeaders,\n          body: openAIBody,\n          json: true\n        });\n\n        if (openAIResponse?.data?.[0]?.embedding) {\n          embedding = openAIResponse.data[0].embedding;\n        } else {\n          throw new Error(\"Falha ao gerar embedding\");\n        }\n      }\n\n      // Preparar payload para Qdrant\n      const similarQuestionsArray = payload.data.similar_questions ? \n        payload.data.similar_questions.split(\",\").map(s => s.trim()) : \n        [];\n      \n      const upsertBody = {\n        points: [{\n          id: payload.data.id,\n          vector: embedding,\n          payload: {\n            a: payload.data.answer,\n            t: payload.data.context,\n            q: payload.data.question,\n            sq: similarQuestionsArray\n          }\n        }]\n      };\n\n      // Upsert no Qdrant\n      endpoint = `${pineconeHost}/collections/${payload.data.namespace}/points`;\n      response = await this.helpers.request({\n        method: \"PUT\",\n        uri: endpoint,\n        headers: pineconeHeaders,\n        body: upsertBody,\n        json: true\n      });\n      logs.push(\"Upsert no Qdrant realizado\");\n      mainResponse = response;\n\n      // Atualizar tabela dimensions\n      const directusDimensionsEndpoint = \"http://\" + payload.global_vars.directus_service + \":8055/items/dimensions\";\n      const dimensionsQuery = {\n        method: \"GET\",\n        uri: directusDimensionsEndpoint,\n        qs: { \"filter[vector_id][_eq]\": payload.data.id },\n        headers: { \"Authorization\": \"Bearer \" + payload.global_vars.directus_token },\n        json: true\n      };\n\n      const existingRecord = await this.helpers.request(dimensionsQuery);\n      const dimensionsBody = {\n        values: embedding.join(\",\"),\n        vector_id: payload.data.id,\n        date_updated: new Date().toISOString()\n      };\n\n      if (existingRecord?.data?.length > 0) {\n        await this.helpers.request({\n          method: \"PATCH\",\n          uri: `${directusDimensionsEndpoint}/${existingRecord.data[0].id}`,\n          headers: { \"Authorization\": \"Bearer \" + payload.global_vars.directus_token },\n          body: dimensionsBody,\n          json: true\n        });\n        logs.push(\"Dimensions atualizado\");\n      } else {\n        await this.helpers.request({\n          method: \"POST\",\n          uri: directusDimensionsEndpoint,\n          headers: { \"Authorization\": \"Bearer \" + payload.global_vars.directus_token },\n          body: { ...dimensionsBody, date_created: new Date().toISOString() },\n          json: true\n        });\n        logs.push(\"Novo registro em Dimensions criado\");\n      }\n\n    // Operação ENABLED\n    } else if (op === \"ENABLED\") {\n   endpoint = `${pineconeHost}/collections/${payload.data.namespace}/points`; // Endpoint correto do Qdrant\n      logs.push(\"Endpoint para upsert (Get Dimensions): \" + endpoint);\n      console.log(\"Endpoint de upsert:\", endpoint);\n\n      let similarQuestionsArray = [];\n  if (payload.data.similar_questions) {\n    similarQuestionsArray = payload.data.similar_questions.split(\",\").map(s => s.trim());\n  }\n  logs.push(\"similar_questions convertido para array: \" + trimLog(JSON.stringify(similarQuestionsArray)));\n  console.log(\"similar_questions array:\", similarQuestionsArray);\n\n  // Upsert no Qdrant\n  endpoint = `${pineconeHost}/collections/${payload.data.namespace}/points`; // Endpoint correto\n\n  // incluido por Francis para funcionar no qdrant - inicio\n\n  // Obter embedding existente do Directus (tabela dimensions)\nconst directusHost = \"http://\" + payload.global_vars.directus_service + \":8055\";\nconst directusEndpoint = directusHost + \"/items/dimensions\";\nconst directusHeaders = {\n  \"Authorization\": \"Bearer \" + payload.global_vars.directus_token,\n  \"Content-Type\": \"application/json\"\n};\n\nconst directusQueryOptions = {\n  method: \"GET\",\n  uri: directusEndpoint,\n  qs: { \"filter[vector_id][_eq]\": payload.data.id },\n  headers: directusHeaders,\n  json: true\n};\n\nlet directusRecord = await this.helpers.request(directusQueryOptions);\nlet directusValues = directusRecord.data[0].values;\n\n// Converter string para array de floats\nlet embedding = [];\nif (typeof directusValues === \"string\") {\n  embedding = directusValues.split(\",\").map(parseFloat);\n} else {\n  embedding = directusValues;\n}\n\n\n // incluido por Francis para funcionar no qdrant - fim\n\n\n\n  const upsertBody = {\n    points: [\n      {\n        id: payload.data.id,\n        vector: embedding,\n        payload: {\n          a: payload.data.answer,\n          t: payload.data.context,\n          q: payload.data.question,\n          sq: similarQuestionsArray // Usa a variável já declarada\n        }\n      }\n    ]\n  };\n\n\n      options = {\n        method: \"PUT\",\n        uri: endpoint,\n        headers: pineconeHeaders,\n        body: upsertBody,\n        json: true\n      };\n\n      response = await this.helpers.request(options);\n      logs.push(\"Resposta do upsert recebida.\");\n      mainResponse = response;\n    }\n\n\n    // Atualiza a tabela vectors_status para os casos ENABLED, DISABLED, INSERT ou UPDATE (ou DELETE)\n    if ([\"ENABLED\", \"DISABLED\", \"INSERT\", \"UPDATE\", \"DELETE\"].includes(op)) {\n      const statusValue = payload.data.enabled === true ? \"#2ECDA7\" : \"#E35169\";\n      const directusStatusHost = \"http://\" + payload.global_vars.directus_service + \":8055\";\n      const directusStatusEndpoint = directusStatusHost + \"/items/vectors_status\";\n      const directusHeaders = {\n        \"Authorization\": \"Bearer \" + payload.global_vars.directus_token,\n        \"Content-Type\": \"application/json\"\n      };\n      logs.push(\"Atualizando tabela vectors_status em: \" + directusStatusEndpoint);\n      console.log(\"Directus vectors_status endpoint:\", directusStatusEndpoint);\n\n      const statusQueryOptions = {\n        method: \"GET\",\n        uri: directusStatusEndpoint,\n        qs: { \"filter[vector_id][_eq]\": payload.data.id },\n        headers: directusHeaders,\n        json: true\n      };\n\n      let statusRecord = await this.helpers.request(statusQueryOptions);\n      logs.push(\"Resposta da consulta vectors_status: \" + trimLog(JSON.stringify(statusRecord)));\n      console.log(\"Directus vectors_status GET response:\", trimLog(JSON.stringify(statusRecord)));\n\n      const currentTimestamp = new Date().toISOString();\n      const statusBody = {\n        value: statusValue,\n        vector_id: payload.data.id,\n        date_created: currentTimestamp,\n        date_updated: currentTimestamp\n      };\n\n      if (statusRecord && statusRecord.data && statusRecord.data.length > 0) {\n        const recordId = statusRecord.data[0].id;\n        const statusUpdateEndpoint = directusStatusEndpoint + \"/\" + recordId;\n        logs.push(\"Atualizando registro vectors_status com id: \" + recordId);\n        console.log(\"Atualizando vectors_status em:\", statusUpdateEndpoint);\n\n        const statusUpdateOptions = {\n          method: \"PATCH\",\n          uri: statusUpdateEndpoint,\n          headers: directusHeaders,\n          body: statusBody,\n          json: true\n        };\n\n        var statusResponse = await this.helpers.request(statusUpdateOptions);\n        logs.push(\"Resposta atualização vectors_status: \" + trimLog(JSON.stringify(statusResponse)));\n        console.log(\"Directus vectors_status update response:\", trimLog(JSON.stringify(statusResponse)));\n      } else {\n        logs.push(\"Nenhum registro vectors_status encontrado, criando novo.\");\n        console.log(\"Criando novo registro vectors_status.\");\n\n        const statusCreateOptions = {\n          method: \"POST\",\n          uri: directusStatusEndpoint,\n          headers: directusHeaders,\n          body: statusBody,\n          json: true\n        };\n\n        var statusResponse = await this.helpers.request(statusCreateOptions);\n        logs.push(\"Resposta criação vectors_status: \" + trimLog(JSON.stringify(statusResponse)));\n        console.log(\"Directus vectors_status create response:\", trimLog(JSON.stringify(statusResponse)));\n      }\n    }\n\n    return [{\n      json: {\n        mainResponse,\n        logs\n      }\n    }];\n  } catch (error) {\n    console.error(\"Erro:\", error);\n    logs.push(\"Erro: \" + error.message);\n    return [{\n      json: {\n        error: error.message,\n        logs\n      }\n    }];\n  }\n}\n\nreturn main();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1664,
        1712
      ],
      "id": "e426e606-dbfb-4199-abd2-ebd1750b2b0c",
      "name": "Update Vectors"
    },
    {
      "parameters": {
        "operation": "select",
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "dimensions",
          "mode": "list",
          "cachedResultName": "dimensions"
        },
        "returnAll": true,
        "where": {
          "values": [
            {
              "column": "vector_id",
              "value": "={{ $json.payload.data.id }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        1472,
        1712
      ],
      "id": "fb181a89-4932-427c-885f-03bcc85df3f0",
      "name": "Get Dimensions",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "Iz6AdCvM8BbJ72YV",
          "name": "Postgres directus95b506d"
        }
      }
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 700,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1168,
        1600
      ],
      "id": "e095f371-008b-4a5c-8328-aca9f6aa2f41",
      "name": "Sticky Note15"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        912,
        1712
      ],
      "id": "03739d5e-6c23-4182-972f-e326a9728eea",
      "name": "No Operation 3"
    },
    {
      "parameters": {
        "name": "GoogleCalendarManager",
        "description": "=Complete tool for Google Calendar management with support for flexible time references. Create, update, delete, or query events using intuitive time specifications and offsets.",
        "jsCode": "// =========================================================\n// CONFIGURAÇÕES CUSTOMIZÁVEIS\n// =========================================================\nconst CONFIG = {\n  maxAppointmentsPerEmail: -1,    // -1 para desativar, 1 para um agendamento por email\n  daysToCheck: 30,               // Período para verificar agendamentos\n  timezone: 'America/Sao_Paulo', // Fuso horário padrão\n  restrictByEmail: true,         // Se true, requer email para todas operações\n  defaultDuration: 60            // Duração padrão em minutos\n};\n\n// Obter credenciais do sistema\nconst inputMapping = $('Core Input').item.json.body.mapping;\nconst systemData = JSON.parse(inputMapping).system;\nconst credentials = {\n  accessToken: systemData.accessToken,\n  refreshToken: systemData.refreshToken,\n  clientId: systemData.clientId,\n  clientSecret: systemData.clientSecret,\n  directusToken: systemData.directus_token,\n  directusService: systemData.directus_service\n};\n\n// Input do usuário e array de logs\nconst inputData = query;\nconst logs = [];\n\n// Configuração do dayjs\nconst dayjs = require('dayjs');\nconst utc = require('dayjs/plugin/utc');\nconst timezone = require('dayjs/plugin/timezone');\nconst weekday = require('dayjs/plugin/weekday');\nconst isoWeek = require('dayjs/plugin/isoWeek');\nconst dayOfYear = require('dayjs/plugin/dayOfYear');\nconst quarterOfYear = require('dayjs/plugin/quarterOfYear');\nconst customParseFormat = require('dayjs/plugin/customParseFormat');\nconst isBetween = require('dayjs/plugin/isBetween');\n\n// Configurar plugins do dayjs\ndayjs.extend(utc);\ndayjs.extend(timezone);\ndayjs.extend(weekday);\ndayjs.extend(isoWeek);\ndayjs.extend(dayOfYear);\ndayjs.extend(quarterOfYear);\ndayjs.extend(customParseFormat);\ndayjs.extend(isBetween);\n\n// Configurar timezone\ndayjs.tz.setDefault(CONFIG.timezone);\n\n// =========================================================\n// FUNÇÕES AUXILIARES\n// =========================================================\n\n// Função para logging\nfunction log(message, data = null) {\n  const entry = {\n    timestamp: new Date().toISOString(),\n    message\n  };\n  \n  if (data) {\n    if (typeof data === 'string' && data.length > 200) {\n      entry.data = data.substring(0, 200) + '... (truncado)';\n    } else if (typeof data === 'object') {\n      const stringified = JSON.stringify(data);\n      entry.data = stringified.length > 200 \n        ? JSON.stringify(data).substring(0, 200) + '... (truncado)' \n        : data;\n    } else {\n      entry.data = data;\n    }\n  }\n  \n  logs.push(entry);\n}\n\n// Função para verificar se o email é obrigatório e foi fornecido\nfunction validateEmailRequirement() {\n  if (CONFIG.restrictByEmail && !inputData.attendee_email) {\n    throw new Error(\"Email obrigatório: Quando RESTRICT_OPERATIONS_BY_EMAIL está ativado, o campo 'attendee_email' é obrigatório\");\n  }\n}\n\n// Função para renovar o token\nasync function refreshGoogleToken() {\n  log('Renovando token do Google');\n  \n  try {\n    const axios = require('axios');\n    const qs = require('querystring');\n    \n    const response = await axios({\n      method: 'post',\n      url: 'https://oauth2.googleapis.com/token',\n      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n      data: qs.stringify({\n        client_id: credentials.clientId,\n        client_secret: credentials.clientSecret,\n        refresh_token: credentials.refreshToken,\n        grant_type: 'refresh_token'\n      })\n    });\n    \n    const newToken = response.data.access_token;\n    \n    // Atualizar token no Directus\n    await axios({\n      method: 'patch',\n      url: `http://${credentials.directusService}:8055/items/global_vars`,\n      headers: {\n        'Authorization': `Bearer ${credentials.directusToken}`,\n        'Content-Type': 'application/json'\n      },\n      data: { accessToken: newToken }\n    });\n    \n    log('Token renovado e atualizado com sucesso');\n    return newToken;\n  } catch (error) {\n    log('Erro ao renovar token', error.message);\n    throw error;\n  }\n}\n\n// Função para obter o ID do calendário\nfunction getCalendarId() {\n  return (!inputData.calendar_id || inputData.calendar_id === '') ? 'primary' : inputData.calendar_id;\n}\n\n// Função para executar operações com renovação automática de token\nasync function executeWithToken(operation) {\n  try {\n    validateEmailRequirement();\n    return await operation(credentials.accessToken);\n  } catch (error) {\n    // Se for erro de token expirado, renovar e tentar novamente\n    if (error.response && error.response.status === 401) {\n      log('Token expirado, renovando e tentando novamente');\n      const newToken = await refreshGoogleToken();\n      const result = await operation(newToken);\n      return {\n        ...result,\n        message: result.message + \" (após renovação do token)\"\n      };\n    }\n    \n    // Outros erros\n    const errorMsg = error.message || 'Erro desconhecido';\n    let errorType = \"general_error\";\n    \n    if (errorMsg.includes(\"Limite máximo\")) errorType = \"appointment_limit_exceeded\";\n    if (errorMsg.includes(\"Acesso negado\") || errorMsg.includes(\"Email obrigatório\")) errorType = \"access_denied\";\n    \n    throw { message: errorMsg, errorType };\n  }\n}\n\n// =========================================================\n// PROCESSAMENTO DE TEMPO RELATIVO\n// =========================================================\n\n// Função para verificar se é dia útil\nfunction isBusinessDay(date) {\n  const dayOfWeek = date.day();\n  return dayOfWeek !== 0 && dayOfWeek !== 6; // 0 = domingo, 6 = sábado\n}\n\n// Função para ajustar para o próximo dia útil\nfunction adjustToBusinessDay(date) {\n  if (isBusinessDay(date)) return date;\n  return date.day() === 6 ? date.add(2, 'day') : date.add(1, 'day');\n}\n\n// Função para calcular data/hora a partir de referências relativas\nfunction calculateDateTime() {\n  // Se horários exatos forem fornecidos, usá-los diretamente\n  if (inputData.exact_start_time) {\n    return {\n      startTime: dayjs(inputData.exact_start_time).tz(CONFIG.timezone),\n      endTime: inputData.exact_end_time \n        ? dayjs(inputData.exact_end_time).tz(CONFIG.timezone)\n        : dayjs(inputData.exact_start_time).tz(CONFIG.timezone).add(inputData.duration_minutes || CONFIG.defaultDuration, 'minute')\n    };\n  }\n\n  // Iniciar com a data/hora base\n  let baseDate = dayjs().tz(CONFIG.timezone);\n  \n  // Aplicar a referência temporal base\n  if (inputData.time_reference) {\n    switch (inputData.time_reference) {\n      case 'now': \n        // Já estamos usando now como base\n        break;\n      case 'today': \n        baseDate = baseDate.startOf('day');\n        break;\n      case 'this_week': \n        baseDate = baseDate.startOf('week');\n        break;\n      case 'this_month': \n        baseDate = baseDate.startOf('month');\n        break;\n      case 'this_quarter': \n        baseDate = baseDate.startOf('quarter');\n        break;\n      case 'this_year': \n        baseDate = baseDate.startOf('year');\n        break;\n    }\n  }\n  \n  // Aplicar deslocamento temporal (offset)\n  if (typeof inputData.offset_value === 'number' && inputData.offset_unit) {\n    baseDate = baseDate.add(inputData.offset_value, inputData.offset_unit);\n  }\n  \n  // Aplicar mês do ano, se especificado\n  if (typeof inputData.month_of_year === 'number') {\n    baseDate = baseDate.month(inputData.month_of_year - 1); // Meses em dayjs são 0-11\n  }\n  \n  // Aplicar trimestre do ano, se especificado\n  if (typeof inputData.quarter_of_year === 'number') {\n    const startMonth = (inputData.quarter_of_year - 1) * 3;\n    baseDate = baseDate.month(startMonth).startOf('month');\n  }\n  \n  // Aplicar dia do mês\n  if (typeof inputData.day_of_month === 'number') {\n    if (inputData.day_of_month === -1) {\n      baseDate = baseDate.endOf('month').startOf('day');\n    } else {\n      baseDate = baseDate.date(inputData.day_of_month);\n    }\n  }\n  \n  // Aplicar dia da semana e semana do mês\n  if (typeof inputData.day_of_week === 'number') {\n    if (typeof inputData.week_of_month === 'number') {\n      // Voltar para o início do mês atual\n      let monthStart = baseDate.startOf('month');\n      \n      if (inputData.week_of_month === -1) {\n        // Última semana do mês\n        let monthEnd = baseDate.endOf('month');\n        while (monthEnd.day() !== inputData.day_of_week) {\n          monthEnd = monthEnd.subtract(1, 'day');\n        }\n        baseDate = monthEnd;\n      } else {\n        // Encontrar o primeiro dia da semana especificado no mês\n        let firstOccurrence = monthStart.day(inputData.day_of_week);\n        \n        // Se estivermos no mês anterior, avançar uma semana\n        if (firstOccurrence.month() !== monthStart.month()) {\n          firstOccurrence = firstOccurrence.add(7, 'day');\n        }\n        \n        // Avançar para a semana específica\n        baseDate = firstOccurrence.add((inputData.week_of_month - 1) * 7, 'day');\n      }\n    } else {\n      // Somente dia da semana especificado, ir para o próximo\n      baseDate = baseDate.day(inputData.day_of_week);\n      \n      // Se já passou esta semana, avançar uma semana\n      if (baseDate.isBefore(dayjs().tz(CONFIG.timezone))) {\n        baseDate = baseDate.add(7, 'day');\n      }\n    }\n  }\n  \n  // Ajustar para dia útil se necessário\n  if (inputData.business_days_only === true) {\n    baseDate = adjustToBusinessDay(baseDate);\n  }\n  \n  // Aplicar hora e minuto\n  if (typeof inputData.hour_of_day === 'number') {\n    baseDate = baseDate.hour(inputData.hour_of_day).minute(typeof inputData.minute_of_hour === 'number' ? inputData.minute_of_hour : 0);\n  } else if (typeof inputData.minute_of_hour === 'number') {\n    baseDate = baseDate.minute(inputData.minute_of_hour);\n  }\n  \n  // Se nem hora nem minuto foram especificados, usar hora atual\n  if (typeof inputData.hour_of_day !== 'number' && typeof inputData.minute_of_hour !== 'number') {\n    const now = dayjs().tz(CONFIG.timezone);\n    baseDate = baseDate.hour(now.hour()).minute(now.minute());\n  }\n  \n  // Zerar segundos e milissegundos\n  baseDate = baseDate.second(0).millisecond(0);\n  \n  // Calcular hora de término (início + duração)\n  const duration = inputData.duration_minutes || CONFIG.defaultDuration;\n  const endDate = baseDate.add(duration, 'minute');\n  \n  log('Data/hora calculada', {\n    start: baseDate.format(),\n    end: endDate.format()\n  });\n  \n  return {\n    startTime: baseDate,\n    endTime: endDate\n  };\n}\n\n// =========================================================\n// FUNÇÕES DE API DO GOOGLE CALENDAR\n// =========================================================\n\n// Cliente HTTP reutilizável\nconst createClient = (token) => {\n  const axios = require('axios');\n  return {\n    get: (url, params = {}) => axios({\n      method: 'get',\n      url,\n      headers: { 'Authorization': `Bearer ${token}` },\n      params\n    }),\n    post: (url, data) => axios({\n      method: 'post',\n      url,\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      },\n      data\n    }),\n    put: (url, data) => axios({\n      method: 'put',\n      url,\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      },\n      data\n    }),\n    delete: (url) => axios({\n      method: 'delete',\n      url,\n      headers: { 'Authorization': `Bearer ${token}` }\n    })\n  };\n};\n\n// Verificar limite de agendamentos por email\nasync function checkAppointmentsForEmail(token, email, calendarId) {\n  if (CONFIG.maxAppointmentsPerEmail === -1) return 0;\n  \n  log(`Verificando agendamentos para ${email}`);\n  \n  try {\n    const client = createClient(token);\n    const now = new Date();\n    const pastDate = new Date(now);\n    pastDate.setDate(now.getDate() - CONFIG.daysToCheck);\n    \n    const response = await client.get(\n      `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events`,\n      {\n        timeMin: pastDate.toISOString(),\n        timeMax: new Date(now.getTime() + (365 * 24 * 60 * 60 * 1000)).toISOString(),\n        q: email,\n        singleEvents: true\n      }\n    );\n    \n    // Filtrar eventos onde o email é participante\n    const relevantEvents = response.data.items.filter(event => \n      event.attendees?.some(attendee => attendee.email.toLowerCase() === email.toLowerCase())\n    );\n    \n    log(`Encontrados ${relevantEvents.length} agendamentos para ${email}`);\n    return relevantEvents.length;\n  } catch (error) {\n    log('Erro ao verificar agendamentos', error.message);\n    return 0; // Em caso de erro, não bloqueamos\n  }\n}\n\n// Buscar eventos\nasync function findEvents(token, params) {\n  const { email, eventTitle, calendarId, timeMin, timeMax, maxResults } = params;\n  \n  log(`Buscando eventos ${eventTitle ? `com título \"${eventTitle}\" ` : ''}${email ? `para ${email}` : ''}`);\n  \n  try {\n    const client = createClient(token);\n    \n    // Preparar datas padrão se não fornecidas\n    const now = new Date();\n    const defaultPastDate = new Date(now);\n    defaultPastDate.setDate(now.getDate() - CONFIG.daysToCheck);\n    \n    const searchTimeMin = timeMin || defaultPastDate.toISOString();\n    const searchTimeMax = timeMax || new Date(now.getTime() + (365 * 24 * 60 * 60 * 1000)).toISOString();\n    \n    // Termo de busca\n    const queryParam = eventTitle && email ? `${email} ${eventTitle}` : \n                       email ? email : \n                       eventTitle ? eventTitle : '';\n    \n    const response = await client.get(\n      `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events`,\n      {\n        timeMin: searchTimeMin,\n        timeMax: searchTimeMax,\n        q: queryParam,\n        singleEvents: true,\n        maxResults: maxResults || 10\n      }\n    );\n    \n    let events = response.data.items || [];\n    \n    // Filtrar por email se necessário\n    if (CONFIG.restrictByEmail && email) {\n      events = events.filter(event => \n        event.attendees?.some(attendee => attendee.email.toLowerCase() === email.toLowerCase())\n      );\n    }\n    \n    // Filtrar por título se fornecido\n    if (eventTitle) {\n      events = events.filter(event => \n        event.summary && event.summary.toLowerCase().includes(eventTitle.toLowerCase())\n      );\n    }\n    \n    log(`Encontrados ${events.length} eventos`);\n    return events;\n  } catch (error) {\n    log('Erro ao buscar eventos', error.message);\n    throw error;\n  }\n}\n\n// Buscar evento por ID\nasync function getEventById(token, eventId, calendarId) {\n  log(`Buscando evento com ID: ${eventId}`);\n  \n  try {\n    const client = createClient(token);\n    const response = await client.get(\n      `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events/${encodeURIComponent(eventId)}`\n    );\n    return response.data;\n  } catch (error) {\n    log('Erro ao buscar evento por ID', error.message);\n    throw error;\n  }\n}\n\n// Verificar acesso ao evento\nasync function verifyEventAccess(token, eventId, email, calendarId) {\n  if (!CONFIG.restrictByEmail || !email) return true;\n  \n  const event = await getEventById(token, eventId, calendarId);\n  \n  const isAttendee = event.attendees?.some(attendee => \n    attendee.email.toLowerCase() === email.toLowerCase()\n  );\n  \n  if (!isAttendee) {\n    throw new Error(`Acesso negado: ${email} não é um participante deste evento`);\n  }\n  \n  return true;\n}\n\n// =========================================================\n// OPERAÇÕES DO CALENDÁRIO\n// =========================================================\n\n// Criar evento\nasync function createEvent(token) {\n  const calendarId = getCalendarId();\n  const { title, description, attendee_email } = inputData;\n  \n  if (!title) {\n    throw new Error(\"Para criar um evento, forneça um título\");\n  }\n  \n  // Calcular horários\n  const { startTime, endTime } = calculateDateTime();\n  \n  // Verificar limite de agendamentos\n  if (CONFIG.maxAppointmentsPerEmail > 0 && attendee_email) {\n    const count = await checkAppointmentsForEmail(token, attendee_email, calendarId);\n    if (count >= CONFIG.maxAppointmentsPerEmail) {\n      throw new Error(`Limite máximo de ${CONFIG.maxAppointmentsPerEmail} agendamento(s) por email excedido.`);\n    }\n  }\n  \n  // Preparar evento\n  const event = {\n    summary: title,\n    description: description || '',\n    start: {\n      dateTime: startTime.toISOString(),\n      timeZone: CONFIG.timezone\n    },\n    end: {\n      dateTime: endTime.toISOString(),\n      timeZone: CONFIG.timezone\n    }\n  };\n  \n  // Adicionar participante\n  if (attendee_email) {\n    event.attendees = [{\n      email: attendee_email,\n      responseStatus: 'needsAction'\n    }];\n  }\n  \n  // Criar evento\n  log('Criando evento', { title, calendarId });\n  const client = createClient(token);\n  \n  const response = await client.post(\n    `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events`,\n    event\n  );\n  \n  return {\n    success: true,\n    message: \"Evento criado com sucesso\",\n    eventId: response.data.id,\n    eventLink: response.data.htmlLink,\n    startTime: startTime.format(),\n    endTime: endTime.format()\n  };\n}\n\n// Atualizar evento\nasync function updateEvent(token) {\n  const calendarId = getCalendarId();\n  const { event_id, event_title, attendee_email, title, description } = inputData;\n  \n  // Validar dados\n  if (!event_id && !event_title && !attendee_email) {\n    throw new Error(\"Para atualizar um evento, forneça identificação (ID ou título) e email\");\n  }\n  \n  if (!title && !description && !inputData.exact_start_time && !inputData.exact_end_time && \n      !inputData.time_reference && !inputData.day_of_week && !inputData.offset_value) {\n    throw new Error(\"Para atualizar um evento, forneça pelo menos um campo para atualizar\");\n  }\n  \n  // Encontrar o evento\n  let eventId = event_id;\n  \n  if (!eventId) {\n    const events = await findEvents(token, {\n      email: attendee_email,\n      eventTitle: event_title,\n      calendarId\n    });\n    \n    if (events.length === 0) {\n      throw new Error(\"Nenhum evento encontrado com os critérios fornecidos\");\n    }\n    \n    eventId = events[0].id;\n    log(`Usando evento encontrado: ${eventId}`);\n  }\n  \n  // Verificar acesso\n  await verifyEventAccess(token, eventId, attendee_email, calendarId);\n  \n  // Buscar dados atuais\n  const existingEvent = await getEventById(token, eventId, calendarId);\n  \n  // Calcular novos horários se necessário\n  let startDateTime = dayjs(existingEvent.start.dateTime || existingEvent.start.date).tz(CONFIG.timezone);\n  let endDateTime = dayjs(existingEvent.end.dateTime || existingEvent.end.date).tz(CONFIG.timezone);\n  \n  // Se temos parâmetros de tempo, recalcular\n  if (inputData.exact_start_time || inputData.time_reference || inputData.offset_value || \n      inputData.day_of_week || inputData.hour_of_day) {\n    const { startTime, endTime } = calculateDateTime();\n    startDateTime = startTime;\n    endDateTime = endTime;\n  }\n  \n  // Preparar atualizações\n  const updatedEvent = {\n    ...existingEvent,\n    summary: title || existingEvent.summary,\n    description: description !== undefined ? description : existingEvent.description,\n    start: {\n      dateTime: startDateTime.toISOString(),\n      timeZone: CONFIG.timezone\n    },\n    end: {\n      dateTime: endDateTime.toISOString(),\n      timeZone: CONFIG.timezone\n    }\n  };\n  \n  // Adicionar novo participante\n  if (attendee_email && !existingEvent.attendees?.some(a => a.email.toLowerCase() === attendee_email.toLowerCase())) {\n    updatedEvent.attendees = [\n      ...(existingEvent.attendees || []),\n      { email: attendee_email, responseStatus: 'needsAction' }\n    ];\n  }\n  \n  // Atualizar evento\n  log('Atualizando evento', { eventId });\n  const client = createClient(token);\n  \n  const response = await client.put(\n    `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events/${encodeURIComponent(eventId)}`,\n    updatedEvent\n  );\n  \n  return {\n    success: true,\n    message: \"Evento atualizado com sucesso\",\n    eventId: response.data.id,\n    eventLink: response.data.htmlLink,\n    startTime: startDateTime.format(),\n    endTime: endDateTime.format()\n  };\n}\n\n// Deletar evento\nasync function deleteEvent(token) {\n  const calendarId = getCalendarId();\n  const { event_id, event_title, attendee_email } = inputData;\n  \n  if (!event_id && !event_title && !attendee_email) {\n    throw new Error(\"Para deletar um evento, forneça o ID do evento ou critérios de busca (título e/ou email)\");\n  }\n  \n  // Encontrar o evento\n  let eventId = event_id;\n  let eventSummary;\n  \n  if (!eventId) {\n    const events = await findEvents(token, {\n      email: attendee_email,\n      eventTitle: event_title,\n      calendarId\n    });\n    \n    if (events.length === 0) {\n      throw new Error(\"Nenhum evento encontrado com os critérios fornecidos\");\n    }\n    \n    eventId = events[0].id;\n    eventSummary = events[0].summary;\n  } else {\n    // Verificar acesso por ID\n    const event = await getEventById(token, eventId, calendarId);\n    eventSummary = event.summary;\n    await verifyEventAccess(token, eventId, attendee_email, calendarId);\n  }\n  \n  // Deletar evento\n  log(`Deletando evento: ${eventId}`);\n  const client = createClient(token);\n  \n  await client.delete(\n    `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events/${encodeURIComponent(eventId)}`\n  );\n  \n  return {\n    success: true,\n    message: \"Evento deletado com sucesso\",\n    eventId,\n    eventSummary\n  };\n}\n\n// Consultar eventos\nasync function queryEvents(token) {\n  const calendarId = getCalendarId();\n  const { attendee_email, event_title, time_min, time_max, max_results } = inputData;\n  \n  // Buscar eventos\n  const events = await findEvents(token, {\n    email: attendee_email,\n    eventTitle: event_title,\n    calendarId,\n    timeMin: time_min,\n    timeMax: time_max,\n    maxResults: max_results\n  });\n  \n  // Simplificar eventos para o retorno\n  const simplifiedEvents = events.map(event => ({\n    id: event.id,\n    title: event.summary,\n    description: event.description,\n    start_time: event.start?.dateTime || event.start?.date,\n    end_time: event.end?.dateTime || event.end?.date,\n    attendees: event.attendees?.map(att => att.email) || [],\n    htmlLink: event.htmlLink\n  }));\n  \n  return {\n    success: true,\n    message: `${events.length} evento(s) encontrado(s)`,\n    count: events.length,\n    events: simplifiedEvents\n  };\n}\n\n// =========================================================\n// EXECUÇÃO PRINCIPAL\n// =========================================================\n\nasync function execute() {\n  try {\n    // Verificar operação válida\n    const operations = {\n      'create': createEvent,\n      'update': updateEvent,\n      'delete': deleteEvent,\n      'query': queryEvents\n    };\n    \n    if (!inputData.operation || !operations[inputData.operation]) {\n      throw new Error(\"Operação inválida. Use 'create', 'update', 'delete' ou 'query'\");\n    }\n    \n    // Executar com tratamento de token\n    const result = await executeWithToken(operations[inputData.operation]);\n    \n    return JSON.stringify({\n      ...result,\n      logs\n    });\n  } catch (error) {\n    return JSON.stringify({\n      success: false,\n      message: error.message || \"Erro desconhecido\",\n      errorType: error.errorType || \"general_error\",\n      logs\n    });\n  }\n}\n\n// Iniciar execução\nreturn execute();",
        "specifyInputSchema": true,
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"operation\": {\n      \"type\": \"string\",\n      \"enum\": [\"create\", \"update\", \"delete\", \"query\"],\n      \"description\": \"Operação a ser realizada: criar, atualizar, deletar ou consultar eventos\"\n    },\n    \"title\": {\n      \"type\": \"string\",\n      \"description\": \"Título do evento (obrigatório para criação e atualização)\"\n    },\n    \"description\": {\n      \"type\": \"string\",\n      \"description\": \"Descrição do evento (opcional)\"\n    },\n    \"calendar_id\": {\n      \"type\": \"string\",\n      \"description\": \"ID do calendário (opcional, usa o calendário primário por padrão)\"\n    },\n    \"attendee_email\": {\n      \"type\": \"string\",\n      \"description\": \"Email do participante/cliente (obrigatório se RESTRICT_OPERATIONS_BY_EMAIL=true)\"\n    },\n    \"event_id\": {\n      \"type\": \"string\",\n      \"description\": \"ID do evento (para atualização/deleção)\"\n    },\n    \"event_title\": {\n      \"type\": \"string\",\n      \"description\": \"Título do evento a ser encontrado (para deleção/atualização)\"\n    },\n    \"exact_start_time\": {\n      \"type\": \"string\",\n      \"description\": \"Horário exato de início no formato ISO (alternativa aos parâmetros relativos)\"\n    },\n    \"exact_end_time\": {\n      \"type\": \"string\",\n      \"description\": \"Horário exato de término no formato ISO (alternativa aos parâmetros relativos)\"\n    },\n    \"time_reference\": {\n      \"type\": \"string\",\n      \"enum\": [\"now\", \"today\", \"this_week\", \"this_month\", \"this_quarter\", \"this_year\"],\n      \"description\": \"Ponto de referência temporal base\"\n    },\n    \"offset_value\": {\n      \"type\": \"integer\",\n      \"description\": \"Deslocamento temporal (positivo=futuro, negativo=passado)\"\n    },\n    \"offset_unit\": {\n      \"type\": \"string\",\n      \"enum\": [\"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\"],\n      \"description\": \"Unidade do deslocamento temporal\"\n    },\n    \"day_of_week\": {\n      \"type\": \"integer\",\n      \"enum\": [0, 1, 2, 3, 4, 5, 6],\n      \"description\": \"Dia da semana (0=domingo, 1=segunda, ..., 6=sábado)\"\n    },\n    \"week_of_month\": {\n      \"type\": \"integer\",\n      \"enum\": [1, 2, 3, 4, 5, -1],\n      \"description\": \"Semana do mês (1=primeira, 2=segunda, ..., -1=última)\"\n    },\n    \"day_of_month\": {\n      \"type\": \"integer\",\n      \"minimum\": -1,\n      \"maximum\": 31,\n      \"description\": \"Dia específico do mês (1-31, ou -1 para último dia)\"\n    },\n    \"month_of_year\": {\n      \"type\": \"integer\",\n      \"enum\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],\n      \"description\": \"Mês do ano (1-12)\"\n    },\n    \"quarter_of_year\": {\n      \"type\": \"integer\",\n      \"enum\": [1, 2, 3, 4],\n      \"description\": \"Trimestre do ano (1-4)\"\n    },\n    \"business_days_only\": {\n      \"type\": \"boolean\",\n      \"description\": \"Se verdadeiro, ajusta para o próximo dia útil se cair em fim de semana\"\n    },\n    \"hour_of_day\": {\n      \"type\": \"integer\",\n      \"minimum\": 0,\n      \"maximum\": 23,\n      \"description\": \"Hora do dia (0-23)\"\n    },\n    \"minute_of_hour\": {\n      \"type\": \"integer\",\n      \"minimum\": 0,\n      \"maximum\": 59,\n      \"description\": \"Minuto da hora (0-59)\"\n    },\n    \"duration_minutes\": {\n      \"type\": \"integer\",\n      \"minimum\": 1,\n      \"description\": \"Duração do evento em minutos (para calcular automaticamente o horário de término)\"\n    },\n    \"time_min\": {\n      \"type\": \"string\",\n      \"description\": \"Data mínima para consulta (ISO)\"\n    },\n    \"time_max\": {\n      \"type\": \"string\",\n      \"description\": \"Data máxima para consulta (ISO)\"\n    },\n    \"max_results\": {\n      \"type\": \"number\",\n      \"description\": \"Número máximo de resultados na consulta\"\n    }\n  },\n  \"required\": [\"operation\"]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        2944,
        1104
      ],
      "id": "e744f607-8a94-4ad6-8e8c-0bd61037938d",
      "name": "GoogleCalendarManager"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1-mini",
          "mode": "list",
          "cachedResultName": "gpt-4.1-mini"
        },
        "options": {
          "temperature": 0.2,
          "topP": 0.8
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        704,
        1984
      ],
      "id": "f5a4b361-e95c-4144-aea2-18e895bc5971",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "M1iyy6bYZ8SwaoAS",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "name": "retriever",
        "description": "=Invoque essa tool para buscar informações no banco vetorial e fornecer respostas relevantes com base nos conhecimentos disponíveis. Use-a somente quando necessário para complementar o contexto.",
        "jsCode": "const axios = require(‘axios’);\n\nasync function runTool() {\nlet logs = “”;\n\ntry {\n// Obter parâmetros de entrada\nlogs += “Obtendo parâmetros de entrada…\\n”;\nconst searchQuery = query.query;\nconst knowledgeId = query.knowledge_id;\nlogs += searchQuery: ${searchQuery}\\nknowledgeId: ${knowledgeId}\\n;\n\n// Obter mapping a partir do nó \"RAG Input\"\nlet mappingInput = $('RAG Input').first().json.body.mapping;\nif (typeof mappingInput === 'string') {\n  try {\n    mappingInput = JSON.parse(mappingInput);\n    logs += \"Mapping Input convertido de string para objeto.\\n\";\n  } catch (e) {\n    throw new Error(\"Falha ao converter mapping para objeto.\");\n  }\n}\nlogs += \"Mapping Input obtido.\\n\";\n\nif (!mappingInput.system) {\n  throw new Error(\"mappingInput.system está indefinido.\");\n}\n\n// Gerar embeddings usando a API do OpenAI\nlogs += \"Chamando endpoint de embeddings da OpenAI...\\n\";\nconst openaiKey = mappingInput.system.openai_key;\nconst embeddingResponse = await axios.post(\n  'https://api.openai.com/v1/embeddings',\n  {\n    input: searchQuery,\n    model: \"text-embedding-3-small\"\n  },\n  {\n    headers: {\n      \"Authorization\": `Bearer ${openaiKey}`,\n      \"Content-Type\": \"application/json\"\n    }\n  }\n);\nlogs += \"Embeddings obtidos com sucesso.\\n\";\nconst embedding = embeddingResponse.data.data[0].embedding;\nlogs += `Embedding (primeiros 5 valores): ${embedding.slice(0,5).join(\", \")}...\\n`;\n\n// Obter pinecone_host e namespace do histórico\nlogs += \"Obtendo pinecone_host e namespace a partir do histórico...\\n\";\nconst historyKnowledge = $('Get History').first().json.knowledge;\nconst knowledgeItem = historyKnowledge.find(item => item.id === knowledgeId);\nif (!knowledgeItem) {\n  throw new Error(`Conhecimento com id ${knowledgeId} não encontrado.`);\n}\nconst pineconeHostRaw = knowledgeItem.pinecone_host;\nconst namespace = knowledgeItem.namespace;\nlogs += `pineconeHostRaw: ${pineconeHostRaw}, namespace: ${namespace}\\n`;\n\n// Garantir que pinecone_host comece com \"https://\"\nlet pineconeHost = pineconeHostRaw.startsWith(\"http\") ? pineconeHostRaw : `http://${pineconeHostRaw}`;\nlogs += `pineconeHost final: ${pineconeHost}\\n`;\n\n// Requisição para a API do Qdrant\nlogs += \"Chamando API do Qdrant...\\n\";\nconst pineconeKey = mappingInput.system.pinecone_key; // Opcional (se usar autenticação)\nconst qdrantQueryUrl = `${pineconeHost}/collections/${namespace}/points/search`;\n\nconst qdrantResponse = await axios.post(\n  qdrantQueryUrl,\n  {\n    vector: embedding,\n    limit: 3, // Ajuste conforme necessário\n    with_payload: true, // Certifique-se de incluir os metadados\n    with_vector: false\n  },\n  {\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...(pineconeKey && { \"Authorization\": `Bearer ${pineconeKey}` }) // Opcional\n    }\n  }\n);\n\nlogs += \"Resposta do Qdrant obtida com sucesso.\\n\";\n\n// Processar resposta do Qdrant\nconst matches = qdrantResponse.data.result; // Certifique-se de que 'result' contém os vetores e payloads\nmatches.forEach((m, idx) => {\n  logs += `Match ${idx + 1}: id=${m.id}, score=${m.score}, payload=${JSON.stringify(m.payload)}\\n`;\n});\n\n// Filtrar e formatar resultados\nconst filteredMatches = matches.filter(item => item.score >= 0.0)\n  .map(item => ({\n    vector: item.id,\n    score: item.score,\n    answer: item.payload?.answer || null, // Certifique-se de acessar os campos corretos\n    question: item.payload?.question || null,\n    context: item.payload?.content || null // Adicione outros campos conforme necessário\n  }));\n\nlogs += `Matches filtrados: ${JSON.stringify(filteredMatches)}\\n`;\n\nconst resultString = `Os vetores retornados foram: ${JSON.stringify(filteredMatches)}`;\n\nconsole.log(\"Logs:\", logs);\n\nreturn resultString;\n\n} catch (error) {\nlogs += Erro: ${error.message}\\n;\nconsole.error(“Erro:”, error.message, “Logs:”, logs);\n\nreturn `Erro: ${error.message}`;\n\n}\n}\n\nreturn runTool();\n",
        "specifyInputSchema": true,
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"knowledge_id\": {\n      \"type\": \"integer\",\n      \"description\": \"O ID do conhecimento específico no qual a busca será realizada.\"\n    },\n    \"query\": {\n      \"type\": \"string\",\n      \"description\": \"A pergunta ou consulta que será usada para realizar a busca no banco vetorial.\"\n    }\n  }\n}"
      },
      "id": "7d2db786-3211-421e-bbdb-493b1cfebc85",
      "name": "Retriever1",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        1808,
        2064
      ]
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\nconst FormData = require('form-data');\n\n// 1.função para escapar caracteres especiais de regex\nfunction escapeRegex(str) {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\n// 2. array de abreviações (note os pontos escapados)\nconst ABBREVIATIONS = [\n    'Dr', 'Dra', 'Sr', 'Sra', 'Srta', 'Sta', \n    'Exmo', 'Exma', 'Prof', 'Profa', 'Eng', \n    'etc', 'V\\\\.Exa', 'V\\\\.Sa', 'pg', 'pag'\n];\n\n// Array para armazenar logs detalhados\nconst detailedLogs = [];\n\n// Funções de log aprimoradas\nfunction logMessage(msg) {\n  console.log(msg);\n  detailedLogs.push({ type: 'info', message: msg, timestamp: new Date().toISOString() });\n}\n\nfunction logError(msg) {\n  console.error(msg);\n  detailedLogs.push({ type: 'error', message: msg, timestamp: new Date().toISOString() });\n}\n\nfunction logRequest(method, url, headers, payload) {\n  detailedLogs.push({\n    type: 'request',\n    method,\n    url,\n    headers,\n    payload,\n    timestamp: new Date().toISOString()\n  });\n}\n\nfunction logResponse(status, data) {\n  detailedLogs.push({\n    type: 'response',\n    status,\n    data,\n    timestamp: new Date().toISOString()\n  });\n}\n\n// ------------------------------\n// Configurações Gerais\n// ------------------------------\nconst MIN_TOTAL_LENGTH = 150;               // Texto menor que 50 caracteres: enviar inteiro.\nconst MIN_SEGMENT_LENGTH = 75;             // Segmentos menores que 20 caracteres serão mesclados.\nconst DESIRED_TEXT_SEGMENT_SIZE = 200;       // Tamanho ideal para segmentos no modo \"text\".\nconst DESIRED_AUDIO_SEGMENT_SIZE = 450;      // Tamanho ideal para segmentos no modo \"audio\" (~30s).\nconst DELAY_FACTOR = 5000;                  // Delay: 200ms por 100 caracteres.\n\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// ------------------------------\n// Parâmetros obtidos dos nós\n// ------------------------------\nconst mapping = $('Mapping').first().json;\nconst chatwootData = mapping.chatwoot;\nconst accountId = chatwootData.account_id;\nconst conversationId = chatwootData.conversation_id;\nconst botToken = chatwootData.bot_token;\n\nconst system = mapping.system;\nconst outputFormat = system.output_format.toLowerCase(); // \"text\", \"audio\" ou \"smart\"\nconst elevenlabsKey = system.elevenlabs_key;\nconst elevenlabsVoice = system.elevenlabs_voice || \"JBFqnCBsd6RMkjVDRZzb\";\nconst elevenlabsModel = system.elevenlabs_model || \"eleven_multilingual_v2\";\nconst chatwootService = system.chatwoot_service; // Valor para a URL do Chatwoot\n\n// Texto original (ajustado para acessar o payload final corretamente)\nconst originalText = $('Execute Core').first().json.final.output;\nlogMessage(`[Main] Texto original possui ${originalText.length} caracteres.`);\nlogMessage(`[Main] Modo de saída: ${outputFormat}`);\n\n// Endpoint do Chatwoot (ajustado para usar chatwootService)\nconst chatwootUrl = `http://${chatwootService}:3000/api/v1/accounts/${encodeURIComponent(accountId)}/conversations/${encodeURIComponent(conversationId)}/messages`;\n// const chatwootUrl = `https://chatbit2.manualnegocioonline.com.br/api/v1/accounts/${encodeURIComponent(accountId)}/conversations/${encodeURIComponent(conversationId)}/messages`;\nlogMessage(`[Main] Chatwoot URL: ${chatwootUrl}`);\n\n// Log dos parâmetros de entrada\nlogMessage(`[Main] Parâmetros: accountId=${accountId}, conversationId=${conversationId}`);\nlogMessage(`[Main] Chatwoot Service: ${chatwootService}`);\nlogMessage(`[Main] Token (primeiros 5 caracteres): ${botToken.substring(0, 5)}...`);\n\n// ------------------------------\n// Função para enviar mensagem de texto\n// ------------------------------\nasync function sendTextMessage(content) {\n  const payload = { content, message_type: \"outgoing\" };\n  const headers = {\n    \"api_access_token\": botToken,\n    \"Content-Type\": \"application/json\"\n  };\n  \n  logMessage(`[sendTextMessage] Enviando mensagem de texto.`);\n  logMessage(`[sendTextMessage] URL: ${chatwootUrl}`);\n  logMessage(`[sendTextMessage] Payload: ${JSON.stringify(payload)}`);\n  logMessage(`[sendTextMessage] Headers: ${JSON.stringify(headers)}`);\n  \n  logRequest('POST', chatwootUrl, headers, payload);\n  \n  try {\n    const response = await axios.post(chatwootUrl, payload, { headers });\n    logMessage(`[sendTextMessage] Resposta do Chatwoot: status ${response.status}`);\n    logResponse(response.status, response.data);\n    return response.data;\n  } catch (error) {\n    logError(`[sendTextMessage] Erro ao enviar mensagem de texto: ${error.toString()}`);\n    \n    if (error.response) {\n      logError(`[sendTextMessage] Status: ${error.response.status}`);\n      logError(`[sendTextMessage] Headers: ${JSON.stringify(error.response.headers)}`);\n      logError(`[sendTextMessage] Erro Response: ${JSON.stringify(error.response.data)}`);\n      logResponse(error.response.status, error.response.data);\n    } else if (error.request) {\n      logError(`[sendTextMessage] Erro Request: ${error.request}`);\n    }\n    \n    throw error;\n  }\n}\n\n// ------------------------------\n// Função para enviar mensagem de áudio\n// ------------------------------\nasync function sendAudioMessage(audioBuffer) {\n  const form = new FormData();\n  form.append(\"attachments[]\", audioBuffer, { filename: \"audio.mp3\", contentType: \"audio/mpeg\" });\n  form.append(\"message_type\", \"outgoing\");\n  \n  const headers = {\n    \"api_access_token\": botToken,\n    ...form.getHeaders()\n  };\n  \n  logMessage(`[sendAudioMessage] Enviando mensagem de áudio.`);\n  logMessage(`[sendAudioMessage] URL: ${chatwootUrl}`);\n  logMessage(`[sendAudioMessage] Headers: ${JSON.stringify(headers)}`);\n  logMessage(`[sendAudioMessage] Tamanho do áudio: ${audioBuffer.length} bytes`);\n  \n  logRequest('POST', chatwootUrl, headers, \"Form Data com áudio\");\n  \n  try {\n    const response = await axios.post(chatwootUrl, form, { headers });\n    logMessage(`[sendAudioMessage] Resposta do Chatwoot: status ${response.status}`);\n    logResponse(response.status, response.data);\n    return response.data;\n  } catch (error) {\n    logError(`[sendAudioMessage] Erro ao enviar mensagem de áudio: ${error.toString()}`);\n    \n    if (error.response) {\n      logError(`[sendAudioMessage] Status: ${error.response.status}`);\n      logError(`[sendAudioMessage] Headers: ${JSON.stringify(error.response.headers)}`);\n      logError(`[sendAudioMessage] Erro Response: ${JSON.stringify(error.response.data)}`);\n      logResponse(error.response.status, error.response.data);\n    } else if (error.request) {\n      logError(`[sendAudioMessage] Erro Request: ${error.request}`);\n    }\n    \n    throw error;\n  }\n}\n\n// ------------------------------\n// Função para converter texto em áudio via Elevenlabs\n// ------------------------------\nasync function convertTextToSpeech(text) {\n  const url = `https://api.elevenlabs.io/v1/text-to-speech/${encodeURIComponent(elevenlabsVoice)}?output_format=mp3_44100_128`;\n  const headers = {\n    \"xi-api-key\": elevenlabsKey,\n    \"Content-Type\": \"application/json\"\n  };\n  const payload = {\n    text: text,\n    model_id: elevenlabsModel\n  };\n  \n  logMessage(`[convertTextToSpeech] Convertendo texto para áudio (primeiros 50 caracteres): \"${text.substring(0,50)}...\"`);\n  logMessage(`[convertTextToSpeech] URL da API Elevenlabs: ${url}`);\n  logMessage(`[convertTextToSpeech] Modelo utilizado: ${elevenlabsModel}`);\n  \n  logRequest('POST', url, headers, payload);\n  \n  try {\n    const response = await axios.post(url, payload, { headers, responseType: 'arraybuffer' });\n    logMessage(`[convertTextToSpeech] Conversão realizada com sucesso. Status: ${response.status}`);\n    logResponse(response.status, \"Binary Audio Data\");\n    return response.data;\n  } catch (error) {\n    logError(`[convertTextToSpeech] Erro ao converter texto para áudio: ${error.toString()}`);\n    \n    if (error.response) {\n      logError(`[convertTextToSpeech] Status: ${error.response.status}`);\n      logError(`[convertTextToSpeech] Headers: ${JSON.stringify(error.response.headers)}`);\n      // Para arraybuffer, precisamos converter para texto para ver o erro\n      if (error.response.data) {\n        try {\n          const errorText = Buffer.from(error.response.data).toString('utf8');\n          logError(`[convertTextToSpeech] Erro Response: ${errorText}`);\n          logResponse(error.response.status, errorText);\n        } catch (e) {\n          logError(`[convertTextToSpeech] Não foi possível converter resposta de erro: ${e.toString()}`);\n        }\n      }\n    } else if (error.request) {\n      logError(`[convertTextToSpeech] Erro Request: ${error.request}`);\n    }\n    \n    throw error;\n  }\n}\n\n// ------------------------------\n// Função para mesclar segmentos curtos (para modos text e audio)\n// ------------------------------\nfunction mergeShortSegments(segments, minLength) {\n  const merged = [];\n  let buffer = \"\";\n  for (const seg of segments) {\n    if ((buffer + \" \" + seg).trim().length < minLength) {\n      buffer = (buffer + \" \" + seg).trim();\n    } else {\n      if (buffer) {\n        merged.push(buffer);\n        buffer = \"\";\n      }\n      merged.push(seg);\n    }\n  }\n  if (buffer) {\n    if (merged.length > 0) {\n      merged[merged.length - 1] += \" \" + buffer;\n    } else {\n      merged.push(buffer);\n    }\n  }\n  return merged;\n}\n\n// ------------------------------\n// Função de segmentação genérica (evita quebrar palavras)\n// ------------------------------\n// 3.  função segmentTextGeneric\nfunction segmentTextGeneric(text, desiredMaxLength) {\n    if (text.length <= desiredMaxLength) return [text];\n    \n    let segments = [];\n    \n    // Escapa as abreviações e monta o padrão corretamente\n    const escapedAbbr = ABBREVIATIONS.map(abbr => escapeRegex(abbr));\n    const abbreviationPattern = `\\\\b(${escapedAbbr.join('|')})\\\\.`;\n    const sentenceSplitRegex = new RegExp(`(?<!${abbreviationPattern})(?<=[.?!])\\\\s+`, 'g');\n    \n    if (text.includes(\"\\n\\n\")) {\n        segments = text.split(/\\n\\s*\\n/).map(seg => seg.trim()).filter(seg => seg.length > 0);\n    }\n    \n    if (segments.length === 0) {\n        // Adicione um filtro para remover valores undefined/null\n        segments = text.split(sentenceSplitRegex)\n            .map(seg => seg ? seg.trim() : '') // Evita undefined\n            .filter(seg => seg.length > 0);\n    }  \n  // Mescla segmentos curtos\n  segments = mergeShortSegments(segments, MIN_SEGMENT_LENGTH);\n  \n  // Se algum segmento for muito longo, subdivide-o por espaços, sem quebrar palavras\n  const finalSegments = [];\n  segments.forEach(seg => {\n    if (seg.length > desiredMaxLength * 1.5) {\n      const words = seg.split(\" \");\n      let current = \"\";\n      for (const word of words) {\n        if ((current + \" \" + word).trim().length > desiredMaxLength) {\n          finalSegments.push(current.trim());\n          current = word;\n        } else {\n          current += \" \" + word;\n        }\n      }\n      if (current.trim()) finalSegments.push(current.trim());\n    } else {\n      finalSegments.push(seg);\n    }\n  });\n  \n  return finalSegments;\n}\n\n// ------------------------------\n// Funções de segmentação para cada modo\n// ------------------------------\nfunction segmentForText(text) {\n  return segmentTextGeneric(text, DESIRED_TEXT_SEGMENT_SIZE);\n}\n\nfunction segmentForAudio(text) {\n  return segmentTextGeneric(text, DESIRED_AUDIO_SEGMENT_SIZE);\n}\n\n/**\n * Função \"smartSegment\":\n * - Divide o texto em sentenças usando delimitadores finais.\n * - Para cada sentença, se ela contiver dígitos ou tiver menos de 80 ou mais de 600 caracteres,\n *   ela será marcada para envio como texto.\n * - Caso contrário, a sentença é considerada \"audio\".\n * - As sentenças marcadas para áudio são agrupadas até atingirem aproximadamente DESIRED_AUDIO_SEGMENT_SIZE.\n * - Após a segmentação, os segmentos do tipo \"text\" com menos que MIN_SEGMENT_LENGTH são mesclados.\n * \n * Retorna um array de objetos: { type: \"text\" | \"audio\", content: string }.\n */\nfunction smartSegment(text) {\n  const sentences = text.split(/(?<=[.?!])\\s+/).map(s => s.trim()).filter(s => s);\n  const segments = [];\n  let audioBuffer = \"\";\n  \n  for (const sentence of sentences) {\n    if (/\\d/.test(sentence) || sentence.length < 80 || sentence.length > 600) {\n      if (audioBuffer) {\n        segments.push({ type: \"audio\", content: audioBuffer.trim() });\n        audioBuffer = \"\";\n      }\n      segments.push({ type: \"text\", content: sentence });\n    } else {\n      if ((audioBuffer + \" \" + sentence).trim().length > DESIRED_AUDIO_SEGMENT_SIZE) {\n        segments.push({ type: \"audio\", content: audioBuffer.trim() });\n        audioBuffer = sentence;\n      } else {\n        audioBuffer = (audioBuffer + \" \" + sentence).trim();\n      }\n    }\n  }\n  if (audioBuffer) {\n    segments.push({ type: \"audio\", content: audioBuffer.trim() });\n  }\n  \n  const mergedSegments = [];\n  for (let i = 0; i < segments.length; i++) {\n    const seg = segments[i];\n    if (seg.type === \"text\" && seg.content.length < MIN_SEGMENT_LENGTH) {\n      if (mergedSegments.length > 0 && mergedSegments[mergedSegments.length - 1].type === \"text\") {\n        mergedSegments[mergedSegments.length - 1].content += \" \" + seg.content;\n      } else if (i < segments.length - 1 && segments[i+1].type === \"text\") {\n        segments[i+1].content = seg.content + \" \" + segments[i+1].content;\n      } else {\n        mergedSegments.push(seg);\n      }\n    } else {\n      mergedSegments.push(seg);\n    }\n  }\n  \n  return mergedSegments;\n}\n\n// ------------------------------\n// Função principal para segmentar e enviar a mensagem\n// ------------------------------\nasync function main() {\n  try {\n    logMessage(`[Main] Modo de saída selecionado: ${outputFormat}`);\n    \n    // Verificação inicial de parâmetros essenciais\n    if (!originalText || originalText.trim().length === 0) {\n      throw new Error(\"Texto original está vazio ou não foi encontrado\");\n    }\n    \n    if (!chatwootService) {\n      throw new Error(\"chatwoot_service não definido\");\n    }\n    \n    if (!accountId) {\n      throw new Error(\"account_id não definido\");\n    }\n    \n    if (!conversationId) {\n      throw new Error(\"conversation_id não definido\");\n    }\n    \n    if (!botToken) {\n      throw new Error(\"bot_token não definido\");\n    }\n    \n    // Adicionando um delay inicial para garantir que o Chatwoot esteja pronto\n    await delay(1000);\n  \n    if (outputFormat === \"audio\") {\n      if (!elevenlabsKey) {\n        throw new Error(\"ElevenLabs API key não definida para modo audio\");\n      }\n      \n      const segments = segmentForAudio(originalText);\n      logMessage(`[Main] Texto segmentado em ${segments.length} segmento(s) para áudio.`);\n      \n      for (const segment of segments) {\n        logMessage(`[Main] Processando segmento de áudio: \"${segment.substring(0,50)}...\"`);\n        const audioBuffer = await convertTextToSpeech(segment);\n        await sendAudioMessage(audioBuffer);\n        logMessage(`[Main] Segmento de áudio enviado: \"${segment.substring(0,50)}...\"`);\n        const delayTime = Math.ceil(segment.length / 100) * DELAY_FACTOR;\n        logMessage(`[Main] Aguardando ${delayTime}ms antes do próximo segmento de áudio.`);\n        await delay(delayTime);\n      }\n      \n      return { message: \"Mensagem de áudio enviada com sucesso.\", logs: detailedLogs };\n    } else if (outputFormat === \"smart\") {\n      if (!elevenlabsKey) {\n        throw new Error(\"ElevenLabs API key não definida para modo smart\");\n      }\n      \n      const segments = smartSegment(originalText);\n      logMessage(`[Main] Texto segmentado em ${segments.length} parte(s) (smart mode).`);\n      \n      for (const seg of segments) {\n        if (seg.type === \"audio\") {\n          logMessage(`[Main] Processando segmento de áudio smart: \"${seg.content.substring(0,50)}...\"`);\n          const audioBuffer = await convertTextToSpeech(seg.content);\n          await sendAudioMessage(audioBuffer);\n          logMessage(`[Main] Segmento de áudio enviado: \"${seg.content.substring(0,50)}...\"`);\n        } else {\n          logMessage(`[Main] Processando segmento de texto smart: \"${seg.content.substring(0,50)}...\"`);\n          await sendTextMessage(seg.content);\n          logMessage(`[Main] Segmento de texto enviado: \"${seg.content.substring(0,50)}...\"`);\n        }\n        \n        const delayTime = Math.ceil(seg.content.length / 100) * DELAY_FACTOR;\n        logMessage(`[Main] Aguardando ${delayTime}ms antes do próximo segmento.`);\n        await delay(delayTime);\n      }\n      \n      return { message: \"Mensagem smart enviada com sucesso.\", logs: detailedLogs };\n    } else {\n      // Modo padrão: text\n      const segments = segmentForText(originalText);\n      logMessage(`[Main] Texto segmentado em ${segments.length} segmento(s) para texto.`);\n      \n      for (const segment of segments) {\n        logMessage(`[Main] Processando segmento de texto: \"${segment.substring(0,50)}...\"`);\n        await sendTextMessage(segment);\n        logMessage(`[Main] Segmento de texto enviado: \"${segment.substring(0,50)}...\"`);\n        \n        const delayTime = Math.ceil(segment.length / 100) * DELAY_FACTOR;\n        logMessage(`[Main] Aguardando ${delayTime}ms antes do próximo segmento de texto.`);\n        await delay(delayTime);\n      }\n      \n      return { message: \"Mensagens de texto enviadas com sucesso.\", logs: detailedLogs };\n    }\n  } catch (error) {\n    logError(`[Main] Erro: ${error.toString()}`);\n    return { error: error.toString(), logs: detailedLogs };\n  }\n}\n\nreturn main().then(result => [{ json: result }]);"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3440,
        224
      ],
      "id": "f4010052-fc95-4ee1-997e-4a7dab86ba67",
      "name": "Chatwoot Output1"
    },
    {
      "parameters": {
        "amount": 2
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        208,
        112
      ],
      "id": "1a04d4b1-7c6a-41a9-9dc8-6a08e72206ef",
      "name": "Wait",
      "webhookId": "5c06d243-470b-424c-9bc2-3e18a4d6f76d"
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.toolThink",
      "typeVersion": 1,
      "position": [
        960,
        1984
      ],
      "id": "2eda829e-0fec-4dc5-b330-0d10b979261b",
      "name": "Think"
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\nconst FormData = require('form-data');\n\n// 1.função para escapar caracteres especiais de regex\nfunction escapeRegex(str) {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\n// 2. array de abreviações (note os pontos escapados)\nconst ABBREVIATIONS = [\n    'Dr', 'Dra', 'Sr', 'Sra', 'Srta', 'Sta', \n    'Exmo', 'Exma', 'Prof', 'Profa', 'Eng', \n    'etc', 'V\\\\.Exa', 'V\\\\.Sa', 'pg', 'pag'\n];\n\n// Array para armazenar logs detalhados\nconst detailedLogs = [];\n\n// Funções de log aprimoradas\nfunction logMessage(msg) {\n  console.log(msg);\n  detailedLogs.push({ type: 'info', message: msg, timestamp: new Date().toISOString() });\n}\n\nfunction logError(msg) {\n  console.error(msg);\n  detailedLogs.push({ type: 'error', message: msg, timestamp: new Date().toISOString() });\n}\n\nfunction logRequest(method, url, headers, payload) {\n  detailedLogs.push({\n    type: 'request',\n    method,\n    url,\n    headers,\n    payload,\n    timestamp: new Date().toISOString()\n  });\n}\n\nfunction logResponse(status, data) {\n  detailedLogs.push({\n    type: 'response',\n    status,\n    data,\n    timestamp: new Date().toISOString()\n  });\n}\n\n// ------------------------------\n// Configurações Gerais\n// ------------------------------\nconst MIN_TOTAL_LENGTH = 100;               // Texto menor que 50 caracteres: enviar inteiro.\nconst MIN_SEGMENT_LENGTH = 50;             // Segmentos menores que 20 caracteres serão mesclados.\nconst DESIRED_TEXT_SEGMENT_SIZE = 300;       // Tamanho ideal para segmentos no modo \"text\".\nconst DESIRED_AUDIO_SEGMENT_SIZE = 450;      // Tamanho ideal para segmentos no modo \"audio\" (~30s).\nconst DELAY_FACTOR = 5000;                  // Delay: 200ms por 100 caracteres.\n\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// ------------------------------\n// Parâmetros obtidos dos nós\n// ------------------------------\nconst mapping = $('Mapping').first().json;\nconst chatwootData = mapping.chatwoot;\nconst accountId = chatwootData.account_id;\nconst conversationId = chatwootData.conversation_id;\nconst botToken = chatwootData.bot_token;\n\nconst system = mapping.system;\nconst outputFormat = system.output_format.toLowerCase(); // \"text\", \"audio\" ou \"smart\"\nconst elevenlabsKey = system.elevenlabs_key;\nconst elevenlabsVoice = system.elevenlabs_voice || \"JBFqnCBsd6RMkjVDRZzb\";\nconst elevenlabsModel = system.elevenlabs_model || \"eleven_multilingual_v2\";\nconst chatwootService = system.chatwoot_service; // Valor para a URL do Chatwoot\n\n// Texto original (ajustado para acessar o payload final corretamente)\nconst originalText = $('Execute Core').first().json.final.output;\nlogMessage(`[Main] Texto original possui ${originalText.length} caracteres.`);\nlogMessage(`[Main] Modo de saída: ${outputFormat}`);\n\n// Endpoint do Chatwoot (ajustado para usar chatwootService)\nconst chatwootUrl = `http://${chatwootService}:3000/api/v1/accounts/${encodeURIComponent(accountId)}/conversations/${encodeURIComponent(conversationId)}/messages`;\n// const chatwootUrl = `https://chatbit2.manualnegocioonline.com.br/api/v1/accounts/${encodeURIComponent(accountId)}/conversations/${encodeURIComponent(conversationId)}/messages`;\nlogMessage(`[Main] Chatwoot URL: ${chatwootUrl}`);\n\n// Log dos parâmetros de entrada\nlogMessage(`[Main] Parâmetros: accountId=${accountId}, conversationId=${conversationId}`);\nlogMessage(`[Main] Chatwoot Service: ${chatwootService}`);\nlogMessage(`[Main] Token (primeiros 5 caracteres): ${botToken.substring(0, 5)}...`);\n\n// ------------------------------\n// Função para enviar mensagem de texto\n// ------------------------------\nasync function sendTextMessage(content) {\n  const payload = { content, message_type: \"outgoing\" };\n  const headers = {\n    \"api_access_token\": botToken,\n    \"Content-Type\": \"application/json\"\n  };\n  \n  logMessage(`[sendTextMessage] Enviando mensagem de texto.`);\n  logMessage(`[sendTextMessage] URL: ${chatwootUrl}`);\n  logMessage(`[sendTextMessage] Payload: ${JSON.stringify(payload)}`);\n  logMessage(`[sendTextMessage] Headers: ${JSON.stringify(headers)}`);\n  \n  logRequest('POST', chatwootUrl, headers, payload);\n  \n  try {\n    const response = await axios.post(chatwootUrl, payload, { headers });\n    logMessage(`[sendTextMessage] Resposta do Chatwoot: status ${response.status}`);\n    logResponse(response.status, response.data);\n    return response.data;\n  } catch (error) {\n    logError(`[sendTextMessage] Erro ao enviar mensagem de texto: ${error.toString()}`);\n    \n    if (error.response) {\n      logError(`[sendTextMessage] Status: ${error.response.status}`);\n      logError(`[sendTextMessage] Headers: ${JSON.stringify(error.response.headers)}`);\n      logError(`[sendTextMessage] Erro Response: ${JSON.stringify(error.response.data)}`);\n      logResponse(error.response.status, error.response.data);\n    } else if (error.request) {\n      logError(`[sendTextMessage] Erro Request: ${error.request}`);\n    }\n    \n    throw error;\n  }\n}\n\n// ------------------------------\n// Função para enviar mensagem de áudio\n// ------------------------------\nasync function sendAudioMessage(audioBuffer) {\n  const form = new FormData();\n  form.append(\"attachments[]\", audioBuffer, { filename: \"audio.mp3\", contentType: \"audio/mpeg\" });\n  form.append(\"message_type\", \"outgoing\");\n  \n  const headers = {\n    \"api_access_token\": botToken,\n    ...form.getHeaders()\n  };\n  \n  logMessage(`[sendAudioMessage] Enviando mensagem de áudio.`);\n  logMessage(`[sendAudioMessage] URL: ${chatwootUrl}`);\n  logMessage(`[sendAudioMessage] Headers: ${JSON.stringify(headers)}`);\n  logMessage(`[sendAudioMessage] Tamanho do áudio: ${audioBuffer.length} bytes`);\n  \n  logRequest('POST', chatwootUrl, headers, \"Form Data com áudio\");\n  \n  try {\n    const response = await axios.post(chatwootUrl, form, { headers });\n    logMessage(`[sendAudioMessage] Resposta do Chatwoot: status ${response.status}`);\n    logResponse(response.status, response.data);\n    return response.data;\n  } catch (error) {\n    logError(`[sendAudioMessage] Erro ao enviar mensagem de áudio: ${error.toString()}`);\n    \n    if (error.response) {\n      logError(`[sendAudioMessage] Status: ${error.response.status}`);\n      logError(`[sendAudioMessage] Headers: ${JSON.stringify(error.response.headers)}`);\n      logError(`[sendAudioMessage] Erro Response: ${JSON.stringify(error.response.data)}`);\n      logResponse(error.response.status, error.response.data);\n    } else if (error.request) {\n      logError(`[sendAudioMessage] Erro Request: ${error.request}`);\n    }\n    \n    throw error;\n  }\n}\n\n// ------------------------------\n// Função para converter texto em áudio via Elevenlabs\n// ------------------------------\nasync function convertTextToSpeech(text) {\n  const url = `https://api.elevenlabs.io/v1/text-to-speech/${encodeURIComponent(elevenlabsVoice)}?output_format=mp3_44100_128`;\n  const headers = {\n    \"xi-api-key\": elevenlabsKey,\n    \"Content-Type\": \"application/json\"\n  };\n  const payload = {\n    text: text,\n    model_id: elevenlabsModel\n  };\n  \n  logMessage(`[convertTextToSpeech] Convertendo texto para áudio (primeiros 50 caracteres): \"${text.substring(0,50)}...\"`);\n  logMessage(`[convertTextToSpeech] URL da API Elevenlabs: ${url}`);\n  logMessage(`[convertTextToSpeech] Modelo utilizado: ${elevenlabsModel}`);\n  \n  logRequest('POST', url, headers, payload);\n  \n  try {\n    const response = await axios.post(url, payload, { headers, responseType: 'arraybuffer' });\n    logMessage(`[convertTextToSpeech] Conversão realizada com sucesso. Status: ${response.status}`);\n    logResponse(response.status, \"Binary Audio Data\");\n    return response.data;\n  } catch (error) {\n    logError(`[convertTextToSpeech] Erro ao converter texto para áudio: ${error.toString()}`);\n    \n    if (error.response) {\n      logError(`[convertTextToSpeech] Status: ${error.response.status}`);\n      logError(`[convertTextToSpeech] Headers: ${JSON.stringify(error.response.headers)}`);\n      // Para arraybuffer, precisamos converter para texto para ver o erro\n      if (error.response.data) {\n        try {\n          const errorText = Buffer.from(error.response.data).toString('utf8');\n          logError(`[convertTextToSpeech] Erro Response: ${errorText}`);\n          logResponse(error.response.status, errorText);\n        } catch (e) {\n          logError(`[convertTextToSpeech] Não foi possível converter resposta de erro: ${e.toString()}`);\n        }\n      }\n    } else if (error.request) {\n      logError(`[convertTextToSpeech] Erro Request: ${error.request}`);\n    }\n    \n    throw error;\n  }\n}\n\n// ------------------------------\n// Função para mesclar segmentos curtos (para modos text e audio)\n// ------------------------------\nfunction mergeShortSegments(segments, minLength) {\n  const merged = [];\n  let buffer = \"\";\n  for (const seg of segments) {\n    if ((buffer + \" \" + seg).trim().length < minLength) {\n      buffer = (buffer + \" \" + seg).trim();\n    } else {\n      if (buffer) {\n        merged.push(buffer);\n        buffer = \"\";\n      }\n      merged.push(seg);\n    }\n  }\n  if (buffer) {\n    if (merged.length > 0) {\n      merged[merged.length - 1] += \" \" + buffer;\n    } else {\n      merged.push(buffer);\n    }\n  }\n  return merged;\n}\n\n// ------------------------------\n// Função de segmentação genérica (evita quebrar palavras)\n// ------------------------------\n// 3.  função segmentTextGeneric\nfunction segmentTextGeneric(text, desiredMaxLength) {\n    if (text.length <= desiredMaxLength) return [text];\n    \n    let segments = [];\n    \n    // Escapa as abreviações e monta o padrão corretamente\n    const escapedAbbr = ABBREVIATIONS.map(abbr => escapeRegex(abbr));\n    const abbreviationPattern = `\\\\b(${escapedAbbr.join('|')})\\\\.`;\n    const sentenceSplitRegex = new RegExp(`(?<!${abbreviationPattern})(?<=[.?!])\\\\s+`, 'g');\n    \n    if (text.includes(\"\\n\\n\")) {\n        segments = text.split(/\\n\\s*\\n/).map(seg => seg.trim()).filter(seg => seg.length > 0);\n    }\n    \n    if (segments.length === 0) {\n        // Adicione um filtro para remover valores undefined/null\n        segments = text.split(sentenceSplitRegex)\n            .map(seg => seg ? seg.trim() : '') // Evita undefined\n            .filter(seg => seg.length > 0);\n    }  \n  // Mescla segmentos curtos\n  segments = mergeShortSegments(segments, MIN_SEGMENT_LENGTH);\n  \n  // Se algum segmento for muito longo, subdivide-o por espaços, sem quebrar palavras\n  const finalSegments = [];\n  segments.forEach(seg => {\n    if (seg.length > desiredMaxLength * 1.5) {\n      const words = seg.split(\" \");\n      let current = \"\";\n      for (const word of words) {\n        if ((current + \" \" + word).trim().length > desiredMaxLength) {\n          finalSegments.push(current.trim());\n          current = word;\n        } else {\n          current += \" \" + word;\n        }\n      }\n      if (current.trim()) finalSegments.push(current.trim());\n    } else {\n      finalSegments.push(seg);\n    }\n  });\n  \n  return finalSegments;\n}\n\n// ------------------------------\n// Funções de segmentação para cada modo\n// ------------------------------\nfunction segmentForText(text) {\n  return segmentTextGeneric(text, DESIRED_TEXT_SEGMENT_SIZE);\n}\n\nfunction segmentForAudio(text) {\n  return segmentTextGeneric(text, DESIRED_AUDIO_SEGMENT_SIZE);\n}\n\n/**\n * Função \"smartSegment\":\n * - Divide o texto em sentenças usando delimitadores finais.\n * - Para cada sentença, se ela contiver dígitos ou tiver menos de 80 ou mais de 600 caracteres,\n *   ela será marcada para envio como texto.\n * - Caso contrário, a sentença é considerada \"audio\".\n * - As sentenças marcadas para áudio são agrupadas até atingirem aproximadamente DESIRED_AUDIO_SEGMENT_SIZE.\n * - Após a segmentação, os segmentos do tipo \"text\" com menos que MIN_SEGMENT_LENGTH são mesclados.\n * \n * Retorna um array de objetos: { type: \"text\" | \"audio\", content: string }.\n */\nfunction smartSegment(text) {\n  const sentences = text.split(/(?<=[.?!])\\s+/).map(s => s.trim()).filter(s => s);\n  const segments = [];\n  let audioBuffer = \"\";\n  \n  for (const sentence of sentences) {\n    if (/\\d/.test(sentence) || sentence.length < 80 || sentence.length > 600) {\n      if (audioBuffer) {\n        segments.push({ type: \"audio\", content: audioBuffer.trim() });\n        audioBuffer = \"\";\n      }\n      segments.push({ type: \"text\", content: sentence });\n    } else {\n      if ((audioBuffer + \" \" + sentence).trim().length > DESIRED_AUDIO_SEGMENT_SIZE) {\n        segments.push({ type: \"audio\", content: audioBuffer.trim() });\n        audioBuffer = sentence;\n      } else {\n        audioBuffer = (audioBuffer + \" \" + sentence).trim();\n      }\n    }\n  }\n  if (audioBuffer) {\n    segments.push({ type: \"audio\", content: audioBuffer.trim() });\n  }\n  \n  const mergedSegments = [];\n  for (let i = 0; i < segments.length; i++) {\n    const seg = segments[i];\n    if (seg.type === \"text\" && seg.content.length < MIN_SEGMENT_LENGTH) {\n      if (mergedSegments.length > 0 && mergedSegments[mergedSegments.length - 1].type === \"text\") {\n        mergedSegments[mergedSegments.length - 1].content += \" \" + seg.content;\n      } else if (i < segments.length - 1 && segments[i+1].type === \"text\") {\n        segments[i+1].content = seg.content + \" \" + segments[i+1].content;\n      } else {\n        mergedSegments.push(seg);\n      }\n    } else {\n      mergedSegments.push(seg);\n    }\n  }\n  \n  return mergedSegments;\n}\n\n// ------------------------------\n// Função principal para segmentar e enviar a mensagem\n// ------------------------------\nasync function main() {\n  try {\n    logMessage(`[Main] Modo de saída selecionado: ${outputFormat}`);\n    \n    // Verificação inicial de parâmetros essenciais\n    if (!originalText || originalText.trim().length === 0) {\n      throw new Error(\"Texto original está vazio ou não foi encontrado\");\n    }\n    \n    if (!chatwootService) {\n      throw new Error(\"chatwoot_service não definido\");\n    }\n    \n    if (!accountId) {\n      throw new Error(\"account_id não definido\");\n    }\n    \n    if (!conversationId) {\n      throw new Error(\"conversation_id não definido\");\n    }\n    \n    if (!botToken) {\n      throw new Error(\"bot_token não definido\");\n    }\n    \n    // Adicionando um delay inicial para garantir que o Chatwoot esteja pronto\n    await delay(1000);\n  \n    if (outputFormat === \"audio\") {\n      if (!elevenlabsKey) {\n        throw new Error(\"ElevenLabs API key não definida para modo audio\");\n      }\n      \n      const segments = segmentForAudio(originalText);\n      logMessage(`[Main] Texto segmentado em ${segments.length} segmento(s) para áudio.`);\n      \n      for (const segment of segments) {\n        logMessage(`[Main] Processando segmento de áudio: \"${segment.substring(0,50)}...\"`);\n        const audioBuffer = await convertTextToSpeech(segment);\n        await sendAudioMessage(audioBuffer);\n        logMessage(`[Main] Segmento de áudio enviado: \"${segment.substring(0,50)}...\"`);\n        const delayTime = Math.ceil(segment.length / 100) * DELAY_FACTOR;\n        logMessage(`[Main] Aguardando ${delayTime}ms antes do próximo segmento de áudio.`);\n        await delay(delayTime);\n      }\n      \n      return { message: \"Mensagem de áudio enviada com sucesso.\", logs: detailedLogs };\n    } else if (outputFormat === \"smart\") {\n      if (!elevenlabsKey) {\n        throw new Error(\"ElevenLabs API key não definida para modo smart\");\n      }\n      \n      const segments = smartSegment(originalText);\n      logMessage(`[Main] Texto segmentado em ${segments.length} parte(s) (smart mode).`);\n      \n      for (const seg of segments) {\n        if (seg.type === \"audio\") {\n          logMessage(`[Main] Processando segmento de áudio smart: \"${seg.content.substring(0,50)}...\"`);\n          const audioBuffer = await convertTextToSpeech(seg.content);\n          await sendAudioMessage(audioBuffer);\n          logMessage(`[Main] Segmento de áudio enviado: \"${seg.content.substring(0,50)}...\"`);\n        } else {\n          logMessage(`[Main] Processando segmento de texto smart: \"${seg.content.substring(0,50)}...\"`);\n          await sendTextMessage(seg.content);\n          logMessage(`[Main] Segmento de texto enviado: \"${seg.content.substring(0,50)}...\"`);\n        }\n        \n        const delayTime = Math.ceil(seg.content.length / 100) * DELAY_FACTOR;\n        logMessage(`[Main] Aguardando ${delayTime}ms antes do próximo segmento.`);\n        await delay(delayTime);\n      }\n      \n      return { message: \"Mensagem smart enviada com sucesso.\", logs: detailedLogs };\n    } else {\n      // Modo padrão: text\n      const segments = segmentForText(originalText);\n      logMessage(`[Main] Texto segmentado em ${segments.length} segmento(s) para texto.`);\n      \n      for (const segment of segments) {\n        logMessage(`[Main] Processando segmento de texto: \"${segment.substring(0,50)}...\"`);\n        await sendTextMessage(segment);\n        logMessage(`[Main] Segmento de texto enviado: \"${segment.substring(0,50)}...\"`);\n        \n        const delayTime = Math.ceil(segment.length / 100) * DELAY_FACTOR;\n        logMessage(`[Main] Aguardando ${delayTime}ms antes do próximo segmento de texto.`);\n        await delay(delayTime);\n      }\n      \n      return { message: \"Mensagens de texto enviadas com sucesso.\", logs: detailedLogs };\n    }\n  } catch (error) {\n    logError(`[Main] Erro: ${error.toString()}`);\n    return { error: error.toString(), logs: detailedLogs };\n  }\n}\n\nreturn main().then(result => [{ json: result }]);"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3232,
        224
      ],
      "id": "ef3ac02d-6875-456a-87ff-423f14b4b5a6",
      "name": "Chatwoot Output2"
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\nconst FormData = require('form-data');\n\n// 1.função para escapar caracteres especiais de regex\nfunction escapeRegex(str) {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\n// 2. array de abreviações (note os pontos escapados)\nconst ABBREVIATIONS = [\n    'Dr', 'Dra', 'Sr', 'Sra', 'Srta', 'Sta', \n    'Exmo', 'Exma', 'Prof', 'Profa', 'Eng', \n    'etc', 'V\\\\.Exa', 'V\\\\.Sa', 'pg', 'pag'\n];\n\n// Array para armazenar logs detalhados\nconst detailedLogs = [];\n\n// Funções de log aprimoradas\nfunction logMessage(msg) {\n  console.log(msg);\n  detailedLogs.push({ type: 'info', message: msg, timestamp: new Date().toISOString() });\n}\n\nfunction logError(msg) {\n  console.error(msg);\n  detailedLogs.push({ type: 'error', message: msg, timestamp: new Date().toISOString() });\n}\n\nfunction logRequest(method, url, headers, payload) {\n  detailedLogs.push({\n    type: 'request',\n    method,\n    url,\n    headers,\n    payload,\n    timestamp: new Date().toISOString()\n  });\n}\n\nfunction logResponse(status, data) {\n  detailedLogs.push({\n    type: 'response',\n    status,\n    data,\n    timestamp: new Date().toISOString()\n  });\n}\n\n// ------------------------------\n// Configurações Gerais\n// ------------------------------\nconst MIN_TOTAL_LENGTH = 100;               // Texto menor que 100 caracteres: enviar inteiro.\nconst MIN_SEGMENT_LENGTH = 50;              // Segmentos menores que 50 caracteres serão mesclados.\nconst DESIRED_TEXT_SEGMENT_SIZE = 300;      // Tamanho ideal para segmentos no modo \"text\".\nconst DESIRED_AUDIO_SEGMENT_SIZE = 450;     // Tamanho ideal para segmentos no modo \"audio\" (~30s).\nconst DELAY_FACTOR = 5000;                  // Delay: 5000ms por 100 caracteres.\n\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// ------------------------------\n// Parâmetros obtidos dos nós\n// ------------------------------\nconst mapping = $('Mapping').first().json;\nconst chatwootData = mapping.chatwoot;\nconst accountId = chatwootData.account_id;\nconst conversationId = chatwootData.conversation_id;\nconst botToken = chatwootData.bot_token;\n\nconst system = mapping.system;\nconst outputFormat = system.output_format.toLowerCase(); // \"text\", \"audio\" ou \"smart\"\nconst elevenlabsKey = system.elevenlabs_key;\nconst elevenlabsVoice = system.elevenlabs_voice || \"JBFqnCBsd6RMkjVDRZzb\";\nconst elevenlabsModel = system.elevenlabs_model || \"eleven_multilingual_v2\";\nconst chatwootService = system.chatwoot_service; // Valor para a URL do Chatwoot\n\n// Texto original (ajustado para acessar o payload final corretamente)\nconst originalText = $('Execute Core').first().json.final.output;\nlogMessage(`[Main] Texto original possui ${originalText.length} caracteres.`);\nlogMessage(`[Main] Modo de saída: ${outputFormat}`);\n\n// Endpoint do Chatwoot (ajustado para usar chatwootService)\nconst chatwootUrl = `http://${chatwootService}:3000/api/v1/accounts/${encodeURIComponent(accountId)}/conversations/${encodeURIComponent(conversationId)}/messages`;\n// const chatwootUrl = `https://chatbit2.manualnegocioonline.com.br/api/v1/accounts/${encodeURIComponent(accountId)}/conversations/${encodeURIComponent(conversationId)}/messages`;\nlogMessage(`[Main] Chatwoot URL: ${chatwootUrl}`);\n\n// Log dos parâmetros de entrada\nlogMessage(`[Main] Parâmetros: accountId=${accountId}, conversationId=${conversationId}`);\nlogMessage(`[Main] Chatwoot Service: ${chatwootService}`);\nlogMessage(`[Main] Token (primeiros 5 caracteres): ${botToken.substring(0, 5)}...`);\n\n// ------------------------------\n// Função para enviar mensagem de texto\n// ------------------------------\nasync function sendTextMessage(content) {\n  // Preserva exatamente o conteúdo original, incluindo quebras de linha\n  const payload = { content, message_type: \"outgoing\" };\n  const headers = {\n    \"api_access_token\": botToken,\n    \"Content-Type\": \"application/json\"\n  };\n  \n  logMessage(`[sendTextMessage] Enviando mensagem de texto.`);\n  logMessage(`[sendTextMessage] URL: ${chatwootUrl}`);\n  logMessage(`[sendTextMessage] Payload: ${JSON.stringify(payload)}`);\n  logMessage(`[sendTextMessage] Headers: ${JSON.stringify(headers)}`);\n  \n  logRequest('POST', chatwootUrl, headers, payload);\n  \n  try {\n    const response = await axios.post(chatwootUrl, payload, { headers });\n    logMessage(`[sendTextMessage] Resposta do Chatwoot: status ${response.status}`);\n    logResponse(response.status, response.data);\n    return response.data;\n  } catch (error) {\n    logError(`[sendTextMessage] Erro ao enviar mensagem de texto: ${error.toString()}`);\n    \n    if (error.response) {\n      logError(`[sendTextMessage] Status: ${error.response.status}`);\n      logError(`[sendTextMessage] Headers: ${JSON.stringify(error.response.headers)}`);\n      logError(`[sendTextMessage] Erro Response: ${JSON.stringify(error.response.data)}`);\n      logResponse(error.response.status, error.response.data);\n    } else if (error.request) {\n      logError(`[sendTextMessage] Erro Request: ${error.request}`);\n    }\n    \n    throw error;\n  }\n}\n\n// ------------------------------\n// Função para enviar mensagem de áudio\n// ------------------------------\nasync function sendAudioMessage(audioBuffer) {\n  const form = new FormData();\n  form.append(\"attachments[]\", audioBuffer, { filename: \"audio.mp3\", contentType: \"audio/mpeg\" });\n  form.append(\"message_type\", \"outgoing\");\n  \n  const headers = {\n    \"api_access_token\": botToken,\n    ...form.getHeaders()\n  };\n  \n  logMessage(`[sendAudioMessage] Enviando mensagem de áudio.`);\n  logMessage(`[sendAudioMessage] URL: ${chatwootUrl}`);\n  logMessage(`[sendAudioMessage] Headers: ${JSON.stringify(headers)}`);\n  logMessage(`[sendAudioMessage] Tamanho do áudio: ${audioBuffer.length} bytes`);\n  \n  logRequest('POST', chatwootUrl, headers, \"Form Data com áudio\");\n  \n  try {\n    const response = await axios.post(chatwootUrl, form, { headers });\n    logMessage(`[sendAudioMessage] Resposta do Chatwoot: status ${response.status}`);\n    logResponse(response.status, response.data);\n    return response.data;\n  } catch (error) {\n    logError(`[sendAudioMessage] Erro ao enviar mensagem de áudio: ${error.toString()}`);\n    \n    if (error.response) {\n      logError(`[sendAudioMessage] Status: ${error.response.status}`);\n      logError(`[sendAudioMessage] Headers: ${JSON.stringify(error.response.headers)}`);\n      logError(`[sendAudioMessage] Erro Response: ${JSON.stringify(error.response.data)}`);\n      logResponse(error.response.status, error.response.data);\n    } else if (error.request) {\n      logError(`[sendAudioMessage] Erro Request: ${error.request}`);\n    }\n    \n    throw error;\n  }\n}\n\n// ------------------------------\n// Função para converter texto em áudio via Elevenlabs\n// ------------------------------\nasync function convertTextToSpeech(text) {\n  const url = `https://api.elevenlabs.io/v1/text-to-speech/${encodeURIComponent(elevenlabsVoice)}?output_format=mp3_44100_128`;\n  const headers = {\n    \"xi-api-key\": elevenlabsKey,\n    \"Content-Type\": \"application/json\"\n  };\n  const payload = {\n    text: text,\n    model_id: elevenlabsModel\n  };\n  \n  logMessage(`[convertTextToSpeech] Convertendo texto para áudio (primeiros 50 caracteres): \"${text.substring(0,50)}...\"`);\n  logMessage(`[convertTextToSpeech] URL da API Elevenlabs: ${url}`);\n  logMessage(`[convertTextToSpeech] Modelo utilizado: ${elevenlabsModel}`);\n  \n  logRequest('POST', url, headers, payload);\n  \n  try {\n    const response = await axios.post(url, payload, { headers, responseType: 'arraybuffer' });\n    logMessage(`[convertTextToSpeech] Conversão realizada com sucesso. Status: ${response.status}`);\n    logResponse(response.status, \"Binary Audio Data\");\n    return response.data;\n  } catch (error) {\n    logError(`[convertTextToSpeech] Erro ao converter texto para áudio: ${error.toString()}`);\n    \n    if (error.response) {\n      logError(`[convertTextToSpeech] Status: ${error.response.status}`);\n      logError(`[convertTextToSpeech] Headers: ${JSON.stringify(error.response.headers)}`);\n      // Para arraybuffer, precisamos converter para texto para ver o erro\n      if (error.response.data) {\n        try {\n          const errorText = Buffer.from(error.response.data).toString('utf8');\n          logError(`[convertTextToSpeech] Erro Response: ${errorText}`);\n          logResponse(error.response.status, errorText);\n        } catch (e) {\n          logError(`[convertTextToSpeech] Não foi possível converter resposta de erro: ${e.toString()}`);\n        }\n      }\n    } else if (error.request) {\n      logError(`[convertTextToSpeech] Erro Request: ${error.request}`);\n    }\n    \n    throw error;\n  }\n}\n\n// ------------------------------\n// Função para mesclar segmentos curtos (para modos text e audio)\n// ------------------------------\nfunction mergeShortSegments(segments, minLength) {\n  const merged = [];\n  let buffer = \"\";\n  \n  for (const seg of segments) {\n    // Preservar segmentos que contêm quebras de linha, independente do tamanho\n    if (seg.includes('\\n')) {\n      if (buffer) {\n        merged.push(buffer);\n        buffer = \"\";\n      }\n      merged.push(seg);\n    }\n    // Para outros segmentos, manter a lógica original\n    else if ((buffer + \" \" + seg).trim().length < minLength) {\n      buffer = (buffer + \" \" + seg).trim();\n    } else {\n      if (buffer) {\n        merged.push(buffer);\n        buffer = \"\";\n      }\n      merged.push(seg);\n    }\n  }\n  \n  if (buffer) {\n    if (merged.length > 0 && !merged[merged.length - 1].includes('\\n')) {\n      merged[merged.length - 1] += \" \" + buffer;\n    } else {\n      merged.push(buffer);\n    }\n  }\n  \n  return merged;\n}\n\n// ------------------------------\n// Função de segmentação genérica (evita quebrar palavras)\n// ------------------------------\nfunction segmentTextGeneric(text, desiredMaxLength) {\n    if (text.length <= desiredMaxLength) return [text];\n    \n    let segments = [];\n    \n    // Escapa as abreviações e monta o padrão corretamente\n    const escapedAbbr = ABBREVIATIONS.map(abbr => escapeRegex(abbr));\n    const abbreviationPattern = `\\\\b(${escapedAbbr.join('|')})\\\\.`;\n    const sentenceSplitRegex = new RegExp(`(?<!${abbreviationPattern})(?<=[.?!])\\\\s+`, 'g');\n    \n    // Preserva quebras de linha durante a segmentação\n    if (text.includes(\"\\n\\n\")) {\n        // Use split com regex que preserva os delimitadores\n        const parts = text.split(/(\\n\\n)/);\n        segments = [];\n        \n        // Reagrupa os segmentos com seus delimitadores\n        for (let i = 0; i < parts.length; i++) {\n            if (parts[i] === \"\\n\\n\") {\n                // Se for um delimitador \\n\\n, adiciona ao segmento anterior\n                if (segments.length > 0) {\n                    segments[segments.length - 1] += \"\\n\\n\";\n                }\n            } else if (parts[i].trim()) {\n                // Se não for um delimitador e não estiver vazio, adiciona como novo segmento\n                segments.push(parts[i].trim());\n            }\n        }\n    } else if (segments.length === 0) {\n        // Se não houver parágrafos, divide por sentenças\n        segments = text.split(sentenceSplitRegex)\n            .map(seg => seg ? seg.trim() : '')\n            .filter(seg => seg.length > 0);\n    }\n  \n    // Mescla segmentos curtos, preservando quebras de linha\n    segments = mergeShortSegments(segments, MIN_SEGMENT_LENGTH);\n  \n    // Se algum segmento for muito longo, subdivide-o\n    const finalSegments = [];\n    segments.forEach(seg => {\n        // Se o segmento contém quebras de linha e é longo\n        if (seg.includes('\\n') && seg.length > desiredMaxLength * 1.5) {\n            // Divide por linhas para preservar a formatação\n            const lines = seg.split(/(\\n)/);\n            let current = \"\";\n            \n            for (let i = 0; i < lines.length; i++) {\n                const line = lines[i];\n                // Se for uma quebra de linha\n                if (line === '\\n') {\n                    // Adiciona a quebra ao segmento atual\n                    current += '\\n';\n                } else if (line.trim()) {\n                    // Se não for uma quebra e não estiver vazio\n                    if ((current + line).length > desiredMaxLength) {\n                        finalSegments.push(current);\n                        current = line;\n                    } else {\n                        current += line;\n                    }\n                }\n            }\n            \n            if (current) finalSegments.push(current);\n        }\n        // Se não tem quebras de linha mas é longo\n        else if (seg.length > desiredMaxLength * 1.5) {\n            const words = seg.split(\" \");\n            let current = \"\";\n            \n            for (const word of words) {\n                if ((current + \" \" + word).length > desiredMaxLength) {\n                    finalSegments.push(current.trim());\n                    current = word;\n                } else {\n                    current += (current ? \" \" : \"\") + word;\n                }\n            }\n            \n            if (current.trim()) finalSegments.push(current.trim());\n        } else {\n            finalSegments.push(seg);\n        }\n    });\n  \n    return finalSegments;\n}\n\n// ------------------------------\n// Funções de segmentação para cada modo\n// ------------------------------\nfunction segmentForText(text) {\n  return segmentTextGeneric(text, DESIRED_TEXT_SEGMENT_SIZE);\n}\n\nfunction segmentForAudio(text) {\n  return segmentTextGeneric(text, DESIRED_AUDIO_SEGMENT_SIZE);\n}\n\n// ------------------------------\n// Função de segmentação inteligente (smart)\n// ------------------------------\nfunction smartSegment(text) {\n  // Verificar se o texto contém a pergunta final específica\n  if (text.includes(\"\\n\\nOnde você prefere?\")) {\n    const parts = text.split(/(\\n\\nOnde você prefere\\?)/);\n    const segments = [];\n    \n    // Processa a parte principal, mantendo a formatação\n    if (parts[0].trim()) {\n      const mainSegments = segmentTextGeneric(parts[0], DESIRED_TEXT_SEGMENT_SIZE);\n      mainSegments.forEach(seg => segments.push({ type: \"text\", content: seg }));\n    }\n    \n    // Adiciona a pergunta final como um segmento separado\n    segments.push({ type: \"text\", content: \"\\n\\nOnde você prefere?\" });\n    \n    return segments;\n  }\n  \n  // Comportamento original caso não tenha a pergunta específica\n  const sentences = text.split(/(?<=[.?!])\\s+/).map(s => s.trim()).filter(s => s);\n  const segments = [];\n  let audioBuffer = \"\";\n  \n  for (const sentence of sentences) {\n    // Preservar sentenças com quebras de linha como texto\n    if (sentence.includes('\\n') || /\\d/.test(sentence) || sentence.length < 80 || sentence.length > 600) {\n      if (audioBuffer) {\n        segments.push({ type: \"audio\", content: audioBuffer.trim() });\n        audioBuffer = \"\";\n      }\n      segments.push({ type: \"text\", content: sentence });\n    } else {\n      if ((audioBuffer + \" \" + sentence).trim().length > DESIRED_AUDIO_SEGMENT_SIZE) {\n        segments.push({ type: \"audio\", content: audioBuffer.trim() });\n        audioBuffer = sentence;\n      } else {\n        audioBuffer = (audioBuffer + \" \" + sentence).trim();\n      }\n    }\n  }\n  \n  if (audioBuffer) {\n    segments.push({ type: \"audio\", content: audioBuffer.trim() });\n  }\n  \n  // Mescla segmentos de texto curtos, preservando aqueles com quebras de linha\n  const mergedSegments = [];\n  \n  for (let i = 0; i < segments.length; i++) {\n    const seg = segments[i];\n    // Nunca mesclar segmentos que contêm quebras de linha\n    if (seg.type === \"text\" && !seg.content.includes('\\n') && seg.content.length < MIN_SEGMENT_LENGTH) {\n      if (mergedSegments.length > 0 && mergedSegments[mergedSegments.length - 1].type === \"text\" \n          && !mergedSegments[mergedSegments.length - 1].content.includes('\\n')) {\n        mergedSegments[mergedSegments.length - 1].content += \" \" + seg.content;\n      } else if (i < segments.length - 1 && segments[i+1].type === \"text\" \n                && !segments[i+1].content.includes('\\n')) {\n        segments[i+1].content = seg.content + \" \" + segments[i+1].content;\n      } else {\n        mergedSegments.push(seg);\n      }\n    } else {\n      mergedSegments.push(seg);\n    }\n  }\n  \n  return mergedSegments;\n}\n\n// ------------------------------\n// Função principal para segmentar e enviar a mensagem\n// ------------------------------\nasync function main() {\n  try {\n    logMessage(`[Main] Modo de saída selecionado: ${outputFormat}`);\n    \n    // Verificação inicial de parâmetros essenciais\n    if (!originalText || originalText.trim().length === 0) {\n      throw new Error(\"Texto original está vazio ou não foi encontrado\");\n    }\n    \n    if (!chatwootService) {\n      throw new Error(\"chatwoot_service não definido\");\n    }\n    \n    if (!accountId) {\n      throw new Error(\"account_id não definido\");\n    }\n    \n    if (!conversationId) {\n      throw new Error(\"conversation_id não definido\");\n    }\n    \n    if (!botToken) {\n      throw new Error(\"bot_token não definido\");\n    }\n    \n    // Adicionando um delay inicial para garantir que o Chatwoot esteja pronto\n    await delay(1000);\n  \n    if (outputFormat === \"audio\") {\n      if (!elevenlabsKey) {\n        throw new Error(\"ElevenLabs API key não definida para modo audio\");\n      }\n      \n      const segments = segmentForAudio(originalText);\n      logMessage(`[Main] Texto segmentado em ${segments.length} segmento(s) para áudio.`);\n      \n      for (const segment of segments) {\n        logMessage(`[Main] Processando segmento de áudio: \"${segment.substring(0,50)}...\"`);\n        const audioBuffer = await convertTextToSpeech(segment);\n        await sendAudioMessage(audioBuffer);\n        logMessage(`[Main] Segmento de áudio enviado: \"${segment.substring(0,50)}...\"`);\n        const delayTime = Math.ceil(segment.length / 100) * DELAY_FACTOR;\n        logMessage(`[Main] Aguardando ${delayTime}ms antes do próximo segmento de áudio.`);\n        await delay(delayTime);\n      }\n      \n      return { message: \"Mensagem de áudio enviada com sucesso.\", logs: detailedLogs };\n    } else if (outputFormat === \"smart\") {\n      if (!elevenlabsKey) {\n        throw new Error(\"ElevenLabs API key não definida para modo smart\");\n      }\n      \n      const segments = smartSegment(originalText);\n      logMessage(`[Main] Texto segmentado em ${segments.length} parte(s) (smart mode).`);\n      \n      for (const seg of segments) {\n        if (seg.type === \"audio\") {\n          logMessage(`[Main] Processando segmento de áudio smart: \"${seg.content.substring(0,50)}...\"`);\n          const audioBuffer = await convertTextToSpeech(seg.content);\n          await sendAudioMessage(audioBuffer);\n          logMessage(`[Main] Segmento de áudio enviado: \"${seg.content.substring(0,50)}...\"`);\n        } else {\n          logMessage(`[Main] Processando segmento de texto smart: \"${seg.content.substring(0,50)}...\"`);\n          await sendTextMessage(seg.content);\n          logMessage(`[Main] Segmento de texto enviado: \"${seg.content.substring(0,50)}...\"`);\n        }\n        \n        const delayTime = Math.ceil(seg.content.length / 100) * DELAY_FACTOR;\n        logMessage(`[Main] Aguardando ${delayTime}ms antes do próximo segmento.`);\n        await delay(delayTime);\n      }\n      \n      return { message: \"Mensagem smart enviada com sucesso.\", logs: detailedLogs };\n    } else {\n      // Modo padrão: text\n      // Se o texto contém a pergunta final específica, trate como um caso especial\n      if (originalText.includes(\"\\n\\nOnde você prefere?\")) {\n        const parts = originalText.split(/(\\n\\nOnde você prefere\\?)/);\n        \n        // Envia a parte principal, se existir\n        if (parts[0].trim()) {\n          const mainSegments = segmentForText(parts[0]);\n          for (const segment of mainSegments) {\n            await sendTextMessage(segment);\n            const delayTime = Math.ceil(segment.length / 100) * DELAY_FACTOR;\n            await delay(delayTime);\n          }\n        }\n        \n        // Envia a pergunta final separadamente para preservar a quebra de linha\n        await sendTextMessage(\"\\n\\nOnde você prefere?\");\n        \n        return { message: \"Mensagens de texto enviadas com sucesso.\", logs: detailedLogs };\n      } else {\n        // Comportamento normal para outros casos\n        const segments = segmentForText(originalText);\n        logMessage(`[Main] Texto segmentado em ${segments.length} segmento(s) para texto.`);\n        \n        for (const segment of segments) {\n          logMessage(`[Main] Processando segmento de texto: \"${segment.substring(0,50)}...\"`);\n          await sendTextMessage(segment);\n          logMessage(`[Main] Segmento de texto enviado: \"${segment.substring(0,50)}...\"`);\n          \n          const delayTime = Math.ceil(segment.length / 100) * DELAY_FACTOR;\n          logMessage(`[Main] Aguardando ${delayTime}ms antes do próximo segmento de texto.`);\n          await delay(delayTime);\n        }\n        \n        return { message: \"Mensagens de texto enviadas com sucesso.\", logs: detailedLogs };\n      }\n    }\n  } catch (error) {\n    logError(`[Main] Erro: ${error.toString()}`);\n    return { error: error.toString(), logs: detailedLogs };\n  }\n}\n\nreturn main().then(result => [{ json: result }]);\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3232,
        1424
      ],
      "id": "310d208b-91f2-49da-a7dc-98d9318d3c61",
      "name": "Chatwoot Output3"
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\nconst FormData = require('form-data');\n\n// 1.função para escapar caracteres especiais de regex\nfunction escapeRegex(str) {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\n// 2. array de abreviações (note os pontos escapados)\nconst ABBREVIATIONS = [\n    'Dr', 'Dra', 'Sr', 'Sra', 'Srta', 'Sta', \n    'Exmo', 'Exma', 'Prof', 'Profa', 'Eng', \n    'etc', 'V\\\\.Exa', 'V\\\\.Sa', 'pg', 'pag'\n];\n\n// Array para armazenar logs detalhados\nconst detailedLogs = [];\n\n// Funções de log aprimoradas\nfunction logMessage(msg) {\n  console.log(msg);\n  detailedLogs.push({ type: 'info', message: msg, timestamp: new Date().toISOString() });\n}\n\nfunction logError(msg) {\n  console.error(msg);\n  detailedLogs.push({ type: 'error', message: msg, timestamp: new Date().toISOString() });\n}\n\nfunction logRequest(method, url, headers, payload) {\n  detailedLogs.push({\n    type: 'request',\n    method,\n    url,\n    headers,\n    payload,\n    timestamp: new Date().toISOString()\n  });\n}\n\nfunction logResponse(status, data) {\n  detailedLogs.push({\n    type: 'response',\n    status,\n    data,\n    timestamp: new Date().toISOString()\n  });\n}\n\n// ------------------------------\n// Configurações Gerais\n// ------------------------------\nconst MIN_TOTAL_LENGTH = 100;               // Texto menor que 100 caracteres: enviar inteiro.\nconst MIN_SEGMENT_LENGTH = 50;              // Segmentos menores que 50 caracteres serão mesclados.\nconst DESIRED_TEXT_SEGMENT_SIZE = 300;      // Tamanho ideal para segmentos no modo \"text\".\nconst DESIRED_AUDIO_SEGMENT_SIZE = 450;     // Tamanho ideal para segmentos no modo \"audio\" (~30s).\nconst DELAY_FACTOR = 5000;                  // Delay: 5000ms por 100 caracteres.\n\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// ------------------------------\n// Função para normalizar texto (nova função)\n// ------------------------------\nfunction normalizeText(text) {\n  // Remove espaços extras no final de cada linha antes de quebras de linha\n  text = text.replace(/\\s+\\n/g, '\\n');\n  \n  // Remove múltiplos espaços consecutivos e substitui por um único espaço\n  text = text.replace(/[ \\t]+/g, ' ');\n  \n  // Preserva \\n\\nOnde você prefere? mas normaliza outros padrões\n  if (text.includes(\"Onde você prefere?\")) {\n    const parts = text.split(/(Onde você prefere\\?)/);\n    if (parts.length >= 2) {\n      // Preserva a estrutura da pergunta final\n      const indexOfQuestion = parts.indexOf(\"Onde você prefere?\");\n      if (indexOfQuestion > 0) {\n        // Garante exatamente duas quebras de linha antes da pergunta\n        parts[indexOfQuestion-1] = parts[indexOfQuestion-1].replace(/\\n*$/, '\\n\\n');\n      }\n      // Reconstrói o texto\n      return parts.join('');\n    }\n  }\n  \n  // Normaliza \\n\\n\\n+ para \\n\\n (preserva parágrafos, mas elimina extras)\n  return text.replace(/\\n{3,}/g, '\\n\\n');\n}\n\n// ------------------------------\n// Função para processar o texto de clínicas (nova função)\n// ------------------------------\nfunction processClinicText(text) {\n  // Normaliza o texto para remover espaços extras\n  text = normalizeText(text);\n  \n  // Identifica o padrão específico do texto da clínica\n  if (text.includes(\"unidades\") && text.includes(\"Dra.\") && text.includes(\"Onde você prefere?\")) {\n    // Divide o texto em partes principais\n    const segments = [];\n    \n    // Extrai a introdução (até o primeiro \\n\\n)\n    const introEnd = text.indexOf(\"\\n\\n\");\n    if (introEnd > 0) {\n      segments.push(text.substring(0, introEnd));\n      text = text.substring(introEnd + 2); // Remove a introdução do texto restante\n    }\n    \n    // Processa o conteúdo principal (unidades)\n    const mainEnd = text.indexOf(\"\\n\\nOnde você prefere?\");\n    if (mainEnd > 0) {\n      const mainText = text.substring(0, mainEnd);\n      // Limpa espaços extras nas linhas\n      const cleanedMainText = mainText.replace(/\\s+\\n/g, '\\n')\n                                    .replace(/\\n\\s+/g, '\\n');\n      segments.push(cleanedMainText);\n      \n      // Adiciona a pergunta final\n      segments.push(\"\\n\\nOnde você prefere?\");\n    } else {\n      // Se não encontrar a pergunta final, adiciona o resto do texto\n      segments.push(text);\n    }\n    \n    return segments.filter(p => p.trim().length > 0);\n  }\n  \n  // Se não for o padrão específico, retorna o texto normalizado inteiro\n  return [text];\n}\n\n// ------------------------------\n// Parâmetros obtidos dos nós\n// ------------------------------\nconst mapping = $('Mapping').first().json;\nconst chatwootData = mapping.chatwoot;\nconst accountId = chatwootData.account_id;\nconst conversationId = chatwootData.conversation_id;\nconst botToken = chatwootData.bot_token;\n\nconst system = mapping.system;\nconst outputFormat = system.output_format.toLowerCase(); // \"text\", \"audio\" ou \"smart\"\nconst elevenlabsKey = system.elevenlabs_key;\nconst elevenlabsVoice = system.elevenlabs_voice || \"JBFqnCBsd6RMkjVDRZzb\";\nconst elevenlabsModel = system.elevenlabs_model || \"eleven_multilingual_v2\";\nconst chatwootService = system.chatwoot_service; // Valor para a URL do Chatwoot\n\n// Texto original (ajustado para acessar o payload final corretamente)\nconst originalText = $('Execute Core').first().json.final.output;\nlogMessage(`[Main] Texto original possui ${originalText.length} caracteres.`);\nlogMessage(`[Main] Modo de saída: ${outputFormat}`);\n\n// Endpoint do Chatwoot (ajustado para usar chatwootService)\nconst chatwootUrl = `http://${chatwootService}:3000/api/v1/accounts/${encodeURIComponent(accountId)}/conversations/${encodeURIComponent(conversationId)}/messages`;\n// const chatwootUrl = `https://chatbit2.manualnegocioonline.com.br/api/v1/accounts/${encodeURIComponent(accountId)}/conversations/${encodeURIComponent(conversationId)}/messages`;\nlogMessage(`[Main] Chatwoot URL: ${chatwootUrl}`);\n\n// Log dos parâmetros de entrada\nlogMessage(`[Main] Parâmetros: accountId=${accountId}, conversationId=${conversationId}`);\nlogMessage(`[Main] Chatwoot Service: ${chatwootService}`);\nlogMessage(`[Main] Token (primeiros 5 caracteres): ${botToken.substring(0, 5)}...`);\n\n// ------------------------------\n// Função para enviar mensagem de texto\n// ------------------------------\nasync function sendTextMessage(content) {\n  // Normaliza o texto antes de enviar\n  const normalizedContent = normalizeText(content);\n  \n  const payload = { content: normalizedContent, message_type: \"outgoing\" };\n  const headers = {\n    \"api_access_token\": botToken,\n    \"Content-Type\": \"application/json\"\n  };\n  \n  logMessage(`[sendTextMessage] Enviando mensagem de texto.`);\n  logMessage(`[sendTextMessage] URL: ${chatwootUrl}`);\n  logMessage(`[sendTextMessage] Payload: ${JSON.stringify(payload)}`);\n  logMessage(`[sendTextMessage] Headers: ${JSON.stringify(headers)}`);\n  \n  logRequest('POST', chatwootUrl, headers, payload);\n  \n  try {\n    const response = await axios.post(chatwootUrl, payload, { headers });\n    logMessage(`[sendTextMessage] Resposta do Chatwoot: status ${response.status}`);\n    logResponse(response.status, response.data);\n    return response.data;\n  } catch (error) {\n    logError(`[sendTextMessage] Erro ao enviar mensagem de texto: ${error.toString()}`);\n    \n    if (error.response) {\n      logError(`[sendTextMessage] Status: ${error.response.status}`);\n      logError(`[sendTextMessage] Headers: ${JSON.stringify(error.response.headers)}`);\n      logError(`[sendTextMessage] Erro Response: ${JSON.stringify(error.response.data)}`);\n      logResponse(error.response.status, error.response.data);\n    } else if (error.request) {\n      logError(`[sendTextMessage] Erro Request: ${error.request}`);\n    }\n    \n    throw error;\n  }\n}\n\n// ------------------------------\n// Função para enviar mensagem de áudio\n// ------------------------------\nasync function sendAudioMessage(audioBuffer) {\n  const form = new FormData();\n  form.append(\"attachments[]\", audioBuffer, { filename: \"audio.mp3\", contentType: \"audio/mpeg\" });\n  form.append(\"message_type\", \"outgoing\");\n  \n  const headers = {\n    \"api_access_token\": botToken,\n    ...form.getHeaders()\n  };\n  \n  logMessage(`[sendAudioMessage] Enviando mensagem de áudio.`);\n  logMessage(`[sendAudioMessage] URL: ${chatwootUrl}`);\n  logMessage(`[sendAudioMessage] Headers: ${JSON.stringify(headers)}`);\n  logMessage(`[sendAudioMessage] Tamanho do áudio: ${audioBuffer.length} bytes`);\n  \n  logRequest('POST', chatwootUrl, headers, \"Form Data com áudio\");\n  \n  try {\n    const response = await axios.post(chatwootUrl, form, { headers });\n    logMessage(`[sendAudioMessage] Resposta do Chatwoot: status ${response.status}`);\n    logResponse(response.status, response.data);\n    return response.data;\n  } catch (error) {\n    logError(`[sendAudioMessage] Erro ao enviar mensagem de áudio: ${error.toString()}`);\n    \n    if (error.response) {\n      logError(`[sendAudioMessage] Status: ${error.response.status}`);\n      logError(`[sendAudioMessage] Headers: ${JSON.stringify(error.response.headers)}`);\n      logError(`[sendAudioMessage] Erro Response: ${JSON.stringify(error.response.data)}`);\n      logResponse(error.response.status, error.response.data);\n    } else if (error.request) {\n      logError(`[sendAudioMessage] Erro Request: ${error.request}`);\n    }\n    \n    throw error;\n  }\n}\n\n// ------------------------------\n// Função para converter texto em áudio via Elevenlabs\n// ------------------------------\nasync function convertTextToSpeech(text) {\n  const url = `https://api.elevenlabs.io/v1/text-to-speech/${encodeURIComponent(elevenlabsVoice)}?output_format=mp3_44100_128`;\n  const headers = {\n    \"xi-api-key\": elevenlabsKey,\n    \"Content-Type\": \"application/json\"\n  };\n  const payload = {\n    text: text,\n    model_id: elevenlabsModel\n  };\n  \n  logMessage(`[convertTextToSpeech] Convertendo texto para áudio (primeiros 50 caracteres): \"${text.substring(0,50)}...\"`);\n  logMessage(`[convertTextToSpeech] URL da API Elevenlabs: ${url}`);\n  logMessage(`[convertTextToSpeech] Modelo utilizado: ${elevenlabsModel}`);\n  \n  logRequest('POST', url, headers, payload);\n  \n  try {\n    const response = await axios.post(url, payload, { headers, responseType: 'arraybuffer' });\n    logMessage(`[convertTextToSpeech] Conversão realizada com sucesso. Status: ${response.status}`);\n    logResponse(response.status, \"Binary Audio Data\");\n    return response.data;\n  } catch (error) {\n    logError(`[convertTextToSpeech] Erro ao converter texto para áudio: ${error.toString()}`);\n    \n    if (error.response) {\n      logError(`[convertTextToSpeech] Status: ${error.response.status}`);\n      logError(`[convertTextToSpeech] Headers: ${JSON.stringify(error.response.headers)}`);\n      // Para arraybuffer, precisamos converter para texto para ver o erro\n      if (error.response.data) {\n        try {\n          const errorText = Buffer.from(error.response.data).toString('utf8');\n          logError(`[convertTextToSpeech] Erro Response: ${errorText}`);\n          logResponse(error.response.status, errorText);\n        } catch (e) {\n          logError(`[convertTextToSpeech] Não foi possível converter resposta de erro: ${e.toString()}`);\n        }\n      }\n    } else if (error.request) {\n      logError(`[convertTextToSpeech] Erro Request: ${error.request}`);\n    }\n    \n    throw error;\n  }\n}\n\n// ------------------------------\n// Função para mesclar segmentos curtos (para modos text e audio)\n// ------------------------------\nfunction mergeShortSegments(segments, minLength) {\n  const merged = [];\n  let buffer = \"\";\n  \n  for (const seg of segments) {\n    // Preservar segmentos que contêm quebras de linha, independente do tamanho\n    if (seg.includes('\\n')) {\n      if (buffer) {\n        merged.push(buffer);\n        buffer = \"\";\n      }\n      merged.push(seg);\n    }\n    // Para outros segmentos, manter a lógica original\n    else if ((buffer + \" \" + seg).trim().length < minLength) {\n      buffer = (buffer + \" \" + seg).trim();\n    } else {\n      if (buffer) {\n        merged.push(buffer);\n        buffer = \"\";\n      }\n      merged.push(seg);\n    }\n  }\n  \n  if (buffer) {\n    if (merged.length > 0 && !merged[merged.length - 1].includes('\\n')) {\n      merged[merged.length - 1] += \" \" + buffer;\n    } else {\n      merged.push(buffer);\n    }\n  }\n  \n  return merged;\n}\n\n// ------------------------------\n// Função de segmentação genérica (evita quebrar palavras)\n// ------------------------------\nfunction segmentTextGeneric(text, desiredMaxLength) {\n    // Primeiro, verifica se é um texto de clínica\n    if (text.includes(\"unidades\") && text.includes(\"Dra.\") && text.includes(\"Onde você prefere?\")) {\n      return processClinicText(text);\n    }\n    \n    // Normaliza o texto para remover espaços extras\n    text = normalizeText(text);\n    \n    if (text.length <= desiredMaxLength) return [text];\n    \n    let segments = [];\n    \n    // Escapa as abreviações e monta o padrão corretamente\n    const escapedAbbr = ABBREVIATIONS.map(abbr => escapeRegex(abbr));\n    const abbreviationPattern = `\\\\b(${escapedAbbr.join('|')})\\\\.`;\n    const sentenceSplitRegex = new RegExp(`(?<!${abbreviationPattern})(?<=[.?!])\\\\s+`, 'g');\n    \n    // Tratamento especial para a pergunta final \"Onde você prefere?\"\n    if (text.includes(\"Onde você prefere?\")) {\n        const questionIndex = text.lastIndexOf(\"Onde você prefere?\");\n        const beforeQuestion = text.substring(0, questionIndex);\n        \n        // Verifica se a pergunta está em um parágrafo separado\n        const hasNewlineBefore = beforeQuestion.endsWith(\"\\n\\n\");\n        \n        // Processa a parte principal\n        if (beforeQuestion.trim()) {\n            // Divide por parágrafos se existirem\n            if (beforeQuestion.includes(\"\\n\\n\")) {\n                const mainSegments = beforeQuestion.split(/\\n\\n+/)\n                                     .map(seg => seg.trim())\n                                     .filter(seg => seg.length > 0);\n                segments = [...mainSegments];\n            } else {\n                // Se não tem parágrafos, divide por sentenças\n                const mainSegments = beforeQuestion.split(sentenceSplitRegex)\n                                     .map(seg => seg ? seg.trim() : '')\n                                     .filter(seg => seg.length > 0);\n                segments = [...mainSegments];\n            }\n        }\n        \n        // Adiciona a pergunta final como um segmento separado\n        // preservando a formatação original\n        if (hasNewlineBefore) {\n            segments.push(\"\\n\\nOnde você prefere?\");\n        } else {\n            segments.push(\"Onde você prefere?\");\n        }\n    } else if (text.includes(\"\\n\\n\")) {\n        // Se tem parágrafos mas não tem a pergunta final específica\n        segments = text.split(/\\n\\n+/)\n                      .map(seg => seg.trim())\n                      .filter(seg => seg.length > 0);\n    } else {\n        // Se não tem parágrafos, divide por sentenças\n        segments = text.split(sentenceSplitRegex)\n                      .map(seg => seg ? seg.trim() : '')\n                      .filter(seg => seg.length > 0);\n    }\n    \n    // Mescla segmentos curtos, preservando aqueles com quebras de linha\n    segments = mergeShortSegments(segments, MIN_SEGMENT_LENGTH);\n    \n    // Se algum segmento for muito longo, subdivide-o\n    const finalSegments = [];\n    segments.forEach(seg => {\n        // Se o segmento contém quebras de linha e é longo\n        if (seg.includes('\\n') && seg.length > desiredMaxLength * 1.5) {\n            // Divide por linhas para preservar a formatação\n            const lines = seg.split(/(\\n)/);\n            let current = \"\";\n            \n            for (let i = 0; i < lines.length; i++) {\n                const line = lines[i];\n                // Se for uma quebra de linha\n                if (line === '\\n') {\n                    current += '\\n';\n                } else if (line.trim()) {\n                    // Se não for uma quebra e não estiver vazio\n                    if ((current + line).length > desiredMaxLength) {\n                        finalSegments.push(current);\n                        current = line;\n                    } else {\n                        current += line;\n                    }\n                }\n            }\n            \n            if (current) finalSegments.push(current);\n        }\n        // Se não tem quebras de linha mas é longo\n        else if (seg.length > desiredMaxLength * 1.5) {\n            const words = seg.split(\" \");\n            let current = \"\";\n            \n            for (const word of words) {\n                if ((current + \" \" + word).length > desiredMaxLength) {\n                    finalSegments.push(current.trim());\n                    current = word;\n                } else {\n                    current += (current ? \" \" : \"\") + word;\n                }\n            }\n            \n            if (current.trim()) finalSegments.push(current.trim());\n        } else {\n            finalSegments.push(seg);\n        }\n    });\n    \n    return finalSegments;\n}\n\n// ------------------------------\n// Funções de segmentação para cada modo\n// ------------------------------\nfunction segmentForText(text) {\n  return segmentTextGeneric(text, DESIRED_TEXT_SEGMENT_SIZE);\n}\n\nfunction segmentForAudio(text) {\n  return segmentTextGeneric(text, DESIRED_AUDIO_SEGMENT_SIZE);\n}\n\n// ------------------------------\n// Função de segmentação inteligente (smart)\n// ------------------------------\nfunction smartSegment(text) {\n  // Verifica se é um texto de clínica\n  if (text.includes(\"unidades\") && text.includes(\"Dra.\") && text.includes(\"Onde você prefere?\")) {\n    const parts = processClinicText(text);\n    return parts.map(part => ({ type: \"text\", content: part }));\n  }\n  \n  // Comportamento original\n  const sentences = text.split(/(?<=[.?!])\\s+/).map(s => s.trim()).filter(s => s);\n  const segments = [];\n  let audioBuffer = \"\";\n  \n  for (const sentence of sentences) {\n    // Preservar sentenças com quebras de linha como texto\n    if (sentence.includes('\\n') || /\\d/.test(sentence) || sentence.length < 80 || sentence.length > 600) {\n      if (audioBuffer) {\n        segments.push({ type: \"audio\", content: audioBuffer.trim() });\n        audioBuffer = \"\";\n      }\n      segments.push({ type: \"text\", content: sentence });\n    } else {\n      if ((audioBuffer + \" \" + sentence).trim().length > DESIRED_AUDIO_SEGMENT_SIZE) {\n        segments.push({ type: \"audio\", content: audioBuffer.trim() });\n        audioBuffer = sentence;\n      } else {\n        audioBuffer = (audioBuffer + \" \" + sentence).trim();\n      }\n    }\n  }\n  \n  if (audioBuffer) {\n    segments.push({ type: \"audio\", content: audioBuffer.trim() });\n  }\n  \n  // Mescla segmentos de texto curtos, preservando aqueles com quebras de linha\n  const mergedSegments = [];\n  \n  for (let i = 0; i < segments.length; i++) {\n    const seg = segments[i];\n    // Nunca mesclar segmentos que contêm quebras de linha\n    if (seg.type === \"text\" && !seg.content.includes('\\n') && seg.content.length < MIN_SEGMENT_LENGTH) {\n      if (mergedSegments.length > 0 && mergedSegments[mergedSegments.length - 1].type === \"text\" \n          && !mergedSegments[mergedSegments.length - 1].content.includes('\\n')) {\n        mergedSegments[mergedSegments.length - 1].content += \" \" + seg.content;\n      } else if (i < segments.length - 1 && segments[i+1].type === \"text\" \n                && !segments[i+1].content.includes('\\n')) {\n        segments[i+1].content = seg.content + \" \" + segments[i+1].content;\n      } else {\n        mergedSegments.push(seg);\n      }\n    } else {\n      mergedSegments.push(seg);\n    }\n  }\n  \n  return mergedSegments;\n}\n\n// ------------------------------\n// Função principal para segmentar e enviar a mensagem\n// ------------------------------\nasync function main() {\n  try {\n    logMessage(`[Main] Modo de saída selecionado: ${outputFormat}`);\n    \n    // Verificação inicial de parâmetros essenciais\n    if (!originalText || originalText.trim().length === 0) {\n      throw new Error(\"Texto original está vazio ou não foi encontrado\");\n    }\n    \n    if (!chatwootService) {\n      throw new Error(\"chatwoot_service não definido\");\n    }\n    \n    if (!accountId) {\n      throw new Error(\"account_id não definido\");\n    }\n    \n    if (!conversationId) {\n      throw new Error(\"conversation_id não definido\");\n    }\n    \n    if (!botToken) {\n      throw new Error(\"bot_token não definido\");\n    }\n    \n    // Adicionando um delay inicial para garantir que o Chatwoot esteja pronto\n    await delay(1000);\n  \n    if (outputFormat === \"audio\") {\n      if (!elevenlabsKey) {\n        throw new Error(\"ElevenLabs API key não definida para modo audio\");\n      }\n      \n      const segments = segmentForAudio(originalText);\n      logMessage(`[Main] Texto segmentado em ${segments.length} segmento(s) para áudio.`);\n      \n      for (const segment of segments) {\n        logMessage(`[Main] Processando segmento de áudio: \"${segment.substring(0,50)}...\"`);\n        const audioBuffer = await convertTextToSpeech(segment);\n        await sendAudioMessage(audioBuffer);\n        logMessage(`[Main] Segmento de áudio enviado: \"${segment.substring(0,50)}...\"`);\n        const delayTime = Math.ceil(segment.length / 100) * DELAY_FACTOR;\n        logMessage(`[Main] Aguardando ${delayTime}ms antes do próximo segmento de áudio.`);\n        await delay(delayTime);\n      }\n      \n      return { message: \"Mensagem de áudio enviada com sucesso.\", logs: detailedLogs };\n    } else if (outputFormat === \"smart\") {\n      if (!elevenlabsKey) {\n        throw new Error(\"ElevenLabs API key não definida para modo smart\");\n      }\n      \n      const segments = smartSegment(originalText);\n      logMessage(`[Main] Texto segmentado em ${segments.length} parte(s) (smart mode).`);\n      \n      for (const seg of segments) {\n        if (seg.type === \"audio\") {\n          logMessage(`[Main] Processando segmento de áudio smart: \"${seg.content.substring(0,50)}...\"`);\n          const audioBuffer = await convertTextToSpeech(seg.content);\n          await sendAudioMessage(audioBuffer);\n          logMessage(`[Main] Segmento de áudio enviado: \"${seg.content.substring(0,50)}...\"`);\n        } else {\n          logMessage(`[Main] Processando segmento de texto smart: \"${seg.content.substring(0,50)}...\"`);\n          await sendTextMessage(seg.content);\n          logMessage(`[Main] Segmento de texto enviado: \"${seg.content.substring(0,50)}...\"`);\n        }\n        \n        const delayTime = Math.ceil(seg.content.length / 100) * DELAY_FACTOR;\n        logMessage(`[Main] Aguardando ${delayTime}ms antes do próximo segmento.`);\n        await delay(delayTime);\n      }\n      \n      return { message: \"Mensagem smart enviada com sucesso.\", logs: detailedLogs };\n    } else {\n      // Modo padrão: text\n      // Verifica se é um texto da clínica para tratamento especial\n      if (originalText.includes(\"unidades\") && (originalText.includes(\"Dra.\") || originalText.includes(\"Dr.\")) && originalText.includes(\"Onde você prefere?\")) {\n        const segments = processClinicText(originalText);\n        logMessage(`[Main] Texto de clínica segmentado em ${segments.length} parte(s).`);\n        \n        for (const segment of segments) {\n          logMessage(`[Main] Processando segmento de clínica: \"${segment.substring(0,50)}...\"`);\n          await sendTextMessage(segment);\n          logMessage(`[Main] Segmento de clínica enviado: \"${segment.substring(0,50)}...\"`);\n          \n          const delayTime = Math.ceil(segment.length / 100) * DELAY_FACTOR;\n          logMessage(`[Main] Aguardando ${delayTime}ms antes do próximo segmento.`);\n          await delay(delayTime);\n        }\n        \n        return { message: \"Mensagens de texto da clínica enviadas com sucesso.\", logs: detailedLogs };\n      } else {\n        // Comportamento normal para outros casos\n        const segments = segmentForText(originalText);\n        logMessage(`[Main] Texto segmentado em ${segments.length} segmento(s) para texto.`);\n        \n        for (const segment of segments) {\n          logMessage(`[Main] Processando segmento de texto: \"${segment.substring(0,50)}...\"`);\n          await sendTextMessage(segment);\n          logMessage(`[Main] Segmento de texto enviado: \"${segment.substring(0,50)}...\"`);\n          \n          const delayTime = Math.ceil(segment.length / 100) * DELAY_FACTOR;\n          logMessage(`[Main] Aguardando ${delayTime}ms antes do próximo segmento de texto.`);\n          await delay(delayTime);\n        }\n        \n        return { message: \"Mensagens de texto enviadas com sucesso.\", logs: detailedLogs };\n      }\n    }\n  } catch (error) {\n    logError(`[Main] Erro: ${error.toString()}`);\n    return { error: error.toString(), logs: detailedLogs };\n  }\n}\n\nreturn main().then(result => [{ json: result }]);\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3008,
        224
      ],
      "id": "f5f3eaca-6aef-4aba-9e64-178a1a27b981",
      "name": "Chatwoot Output4"
    },
    {
      "parameters": {
        "name": "retriever",
        "description": "=Invoque essa tool para buscar informações no banco vetorial e fornecer respostas relevantes com base nos conhecimentos disponíveis. Use-a quando necessário para complementar o contexto.",
        "jsCode": "const axios = require('axios');\n\nasync function runTool() {\n  let logs = \"\";\n  \n  try {\n    // Obter parâmetros de entrada\n    logs += \"Obtendo parâmetros de entrada...\\n\";\n    const searchQuery = query.query;\n    const knowledgeId = query.knowledge_id;\n    logs += `searchQuery: ${searchQuery}\\nknowledgeId: ${knowledgeId}\\n`;\n    \n    // Obter mapping a partir do nó \"RAG Input\"\n    let mappingInput = $('RAG Input').first().json.body.mapping;\n    if (typeof mappingInput === 'string') {\n      try {\n        mappingInput = JSON.parse(mappingInput);\n        logs += \"Mapping Input convertido de string para objeto.\\n\";\n      } catch (e) {\n        throw new Error(\"Falha ao converter mapping para objeto.\");\n      }\n    }\n    logs += \"Mapping Input obtido.\\n\";\n    \n    if (!mappingInput.system) {\n      throw new Error(\"mappingInput.system está indefinido.\");\n    }\n    \n    // Gerar embeddings usando a API do OpenAI\n    logs += \"Chamando endpoint de embeddings da OpenAI...\\n\";\n    const openaiKey = mappingInput.system.openai_key;\n    const embeddingResponse = await axios.post(\n      'https://api.openai.com/v1/embeddings',\n      {\n        input: searchQuery,\n        model: \"text-embedding-3-small\"\n      },\n      {\n        headers: {\n          \"Authorization\": `Bearer ${openaiKey}`,\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n    logs += \"Embeddings obtidos com sucesso.\\n\";\n    const embedding = embeddingResponse.data.data[0].embedding;\n    logs += `Embedding (primeiros 6 valores): ${embedding.slice(0,5).join(\", \")}...\\n`;\n    \n    // Obter pinecone_host e namespace do histórico\n    logs += \"Obtendo pinecone_host e namespace a partir do histórico...\\n\";\n    const historyKnowledge = $('Get History').first().json.knowledge;\n    const knowledgeItem = historyKnowledge.find(item => item.id === knowledgeId);\n    if (!knowledgeItem) {\n      throw new Error(`Conhecimento com id ${knowledgeId} não encontrado.`);\n    }\n    const pineconeHostRaw = knowledgeItem.pinecone_host;\n    const namespace = knowledgeItem.namespace;\n    logs += `pineconeHostRaw: ${pineconeHostRaw}, namespace: ${namespace}\\n`;\n    \n    // Garantir que pinecone_host comece com \"https://\"\n    let pineconeHost = pineconeHostRaw.startsWith(\"http\") ? pineconeHostRaw : `http://${pineconeHostRaw}`;\n    logs += `pineconeHost final: ${pineconeHost}\\n`;\n    \n    // Requisição para a API do Qdrant\n    logs += \"Chamando API do Qdrant...\\n\";\n    const pineconeKey = mappingInput.system.pinecone_key; // Opcional (se usar autenticação)\n    const qdrantQueryUrl = `${pineconeHost}/collections/${namespace}/points/search`;\n    \n    const qdrantResponse = await axios.post(\n      qdrantQueryUrl,\n      {\n        vector: embedding,\n        limit: 6, // Ajuste conforme necessário\n        with_payload: true, // Certifique-se de incluir os metadados\n        with_vector: false\n      },\n      {\n        headers: {\n          \"Content-Type\": \"application/json\",\n          ...(pineconeKey && { \"Authorization\": `Bearer ${pineconeKey}` }) // Opcional\n        }\n      }\n    );\n\n    logs += \"Resposta do Qdrant obtida com sucesso.\\n\";\n    \n    // Processar resposta do Qdrant\n    const matches = qdrantResponse.data.result; // Certifique-se de que 'result' contém os vetores e payloads\n    matches.forEach((m, idx) => {\n      logs += `Match ${idx + 1}: id=${m.id}, score=${m.score}, payload=${JSON.stringify(m.payload)}\\n`;\n    });\n    \n    // Filtrar e formatar resultados\n    const filteredMatches = matches.filter(item => item.score >= 0.0)\n      .map(item => ({\n        vector: item.id,\n        score: item.score,\n        answer: item.payload?.answer || null, // Certifique-se de acessar os campos corretos\n        question: item.payload?.question || null,\n        context: item.payload?.content || null // Adicione outros campos conforme necessário\n      }));\n    \n    logs += `Matches filtrados: ${JSON.stringify(filteredMatches)}\\n`;\n    \n    const resultString = `Os vetores retornados foram: ${JSON.stringify(filteredMatches)}`;\n    \n    console.log(\"Logs:\", logs);\n    \n    return resultString;\n  } catch (error) {\n    logs += `Erro: ${error.message}\\n`;\n    console.error(\"Erro:\", error.message, \"Logs:\", logs);\n    \n    return `Erro: ${error.message}`;\n  }\n}\n\nreturn runTool();\n",
        "specifyInputSchema": true,
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"knowledge_id\": {\n      \"type\": \"integer\",\n      \"description\": \"O ID do conhecimento específico no qual a busca será realizada.\"\n    },\n    \"query\": {\n      \"type\": \"string\",\n      \"description\": \"A pergunta ou consulta que será usada para realizar a busca no banco vetorial.\"\n    }\n  }\n}"
      },
      "id": "1936a579-d160-4092-aab1-416029eb846f",
      "name": "Retriever2",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        832,
        1984
      ]
    },
    {
      "parameters": {
        "name": "retriever",
        "description": "=Invoque essa tool para buscar informações no banco vetorial e fornecer respostas relevantes com base nos conhecimentos disponíveis. Use-a quando necessário para complementar o contexto.",
        "jsCode": "const axios = require('axios');\n\nasync function runTool() {\n  let logs = \"\";\n  \n  try {\n    // Obter parâmetros de entrada\n    logs += \"Obtendo parâmetros de entrada...\\n\";\n    const searchQuery = query.query;\n    const knowledgeId = query.knowledge_id;\n    logs += `searchQuery: ${searchQuery}\\nknowledgeId: ${knowledgeId}\\n`;\n    \n    // Configurações avançadas para busca vetorial\n    const SCORE_THRESHOLD = 0.4;  // Limiar de similaridade para filtrar resultados irrelevantes\n    const LIMIT_RESULTS = 5;       // Número máximo de resultados a retornar\n    const EMBEDDING_MODEL = \"text-embedding-3-small\";  // Modelo de embedding da OpenAI\n    \n    // Obter mapping a partir do nó \"RAG Input\"\n    let mappingInput = $('RAG Input').first().json.body.mapping;\n    if (typeof mappingInput === 'string') {\n      try {\n        mappingInput = JSON.parse(mappingInput);\n        logs += \"Mapping Input convertido de string para objeto.\\n\";\n      } catch (e) {\n        throw new Error(\"Falha ao converter mapping para objeto.\");\n      }\n    }\n    logs += \"Mapping Input obtido.\\n\";\n    \n    if (!mappingInput.system) {\n      throw new Error(\"mappingInput.system está indefinido.\");\n    }\n    \n    // Gerar embeddings usando a API do OpenAI\n    logs += `Chamando endpoint de embeddings da OpenAI usando modelo ${EMBEDDING_MODEL}...\\n`;\n    const openaiKey = mappingInput.system.openai_key;\n    const embeddingResponse = await axios.post(\n      'https://api.openai.com/v1/embeddings',\n      {\n        input: searchQuery,\n        model: EMBEDDING_MODEL\n      },\n      {\n        headers: {\n          \"Authorization\": `Bearer ${openaiKey}`,\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n    logs += \"Embeddings obtidos com sucesso.\\n\";\n    const embedding = embeddingResponse.data.data[0].embedding;\n    logs += `Embedding (primeiros 5 valores): ${embedding.slice(0,5).join(\", \")}...\\n`;\n    \n    // Obter pinecone_host e namespace do histórico\n    logs += \"Obtendo pinecone_host e namespace a partir do histórico...\\n\";\n    const historyKnowledge = $('Get History').first().json.knowledge;\n    const knowledgeItem = historyKnowledge.find(item => item.id === knowledgeId);\n    if (!knowledgeItem) {\n      throw new Error(`Conhecimento com id ${knowledgeId} não encontrado.`);\n    }\n    const pineconeHostRaw = knowledgeItem.pinecone_host;\n    const namespace = knowledgeItem.namespace;\n    logs += `pineconeHostRaw: ${pineconeHostRaw}, namespace: ${namespace}\\n`;\n    \n    // Garantir que pinecone_host comece com \"https://\"\n    let pineconeHost = pineconeHostRaw.startsWith(\"http\") ? pineconeHostRaw : `https://${pineconeHostRaw}`;\n    logs += `pineconeHost final: ${pineconeHost}\\n`;\n    \n    // Requisição para a API do Qdrant com parâmetros otimizados\n    logs += \"Chamando API do Qdrant com parâmetros otimizados...\\n\";\n    const pineconeKey = mappingInput.system.pinecone_key; // Opcional (se usar autenticação)\n    const qdrantQueryUrl = `${pineconeHost}/collections/${namespace}/points/search`;\n    \n    // Construir payload avançado para busca\n    const searchPayload = {\n      vector: embedding,\n      limit: LIMIT_RESULTS,\n      with_payload: true,\n      with_vector: false,\n      score_threshold: SCORE_THRESHOLD, // Filtrar resultados com baixa similaridade\n      params: {\n        hnsw_ef: 128,  // Aumenta a precisão da busca HNSW\n        exact: false   // Use true para busca exata quando precisão for crítica\n      }\n    };\n    \n    // Adicionar filtros se disponíveis nos metadados (exemplo comentado)\n    /*\n    if (query.filters) {\n      searchPayload.filter = {\n        must: []\n      };\n      \n      // Exemplo: filtrar por categoria\n      if (query.filters.categoria) {\n        searchPayload.filter.must.push({\n          key: \"categoria\",\n          match: { value: query.filters.categoria }\n        });\n      }\n      \n      // Exemplo: filtrar por data\n      if (query.filters.data_inicio && query.filters.data_fim) {\n        searchPayload.filter.must.push({\n          key: \"data\",\n          range: { \n            gte: query.filters.data_inicio,\n            lte: query.filters.data_fim\n          }\n        });\n      }\n    }\n    */\n    \n    logs += `Payload de busca: ${JSON.stringify(searchPayload)}\\n`;\n    \n    const qdrantResponse = await axios.post(\n      qdrantQueryUrl,\n      searchPayload,\n      {\n        headers: {\n          \"Content-Type\": \"application/json\",\n          ...(pineconeKey && { \"Authorization\": `Bearer ${pineconeKey}` })\n        }\n      }\n    );\n\n    logs += \"Resposta do Qdrant obtida com sucesso.\\n\";\n    \n    // Processar resposta do Qdrant\n    const matches = qdrantResponse.data.result; // Certifique-se de que 'result' contém os vetores e payloads\n    logs += `Total de matches retornados: ${matches.length}\\n`;\n    \n    matches.forEach((m, idx) => {\n      logs += `Match ${idx + 1}: id=${m.id}, score=${m.score.toFixed(4)}, payload=${JSON.stringify(m.payload)}\\n`;\n    });\n    \n    // Filtrar e formatar resultados com score mínimo\n    const filteredMatches = matches\n      .filter(item => item.score >= SCORE_THRESHOLD)\n      .map(item => ({\n        vector: item.id,\n        score: item.score,\n        answer: item.payload?.answer || null,\n        question: item.payload?.question || null,\n        context: item.payload?.content || null,\n        // Adicionar metadados relevantes\n        metadata: {\n          source: item.payload?.source || null,\n          date: item.payload?.date || null,\n          category: item.payload?.category || null\n        }\n      }));\n    \n    logs += `Matches filtrados: ${filteredMatches.length}\\n`;\n    \n    if (filteredMatches.length === 0) {\n      logs += \"ATENÇÃO: Nenhum resultado passou pelo limiar de score. Considere ajustar o SCORE_THRESHOLD para um valor menor.\\n\";\n    }\n    \n    // Classificar resultados pelo score (do maior para o menor)\n    filteredMatches.sort((a, b) => b.score - a.score);\n    \n    // Adicionar informações de diagnóstico\n    const searchDiagnostics = {\n      queryLength: searchQuery.length,\n      totalResults: matches.length,\n      filteredResults: filteredMatches.length,\n      averageScore: filteredMatches.length > 0 \n        ? filteredMatches.reduce((sum, item) => sum + item.score, 0) / filteredMatches.length \n        : 0,\n      scoreThreshold: SCORE_THRESHOLD,\n      embeddingModel: EMBEDDING_MODEL\n    };\n    \n    const result = {\n      matches: filteredMatches,\n      diagnostics: searchDiagnostics\n    };\n    \n    console.log(\"Logs:\", logs);\n    \n    return JSON.stringify(result, null, 2);\n  } catch (error) {\n    logs += `Erro: ${error.message}\\n`;\n    if (error.response) {\n      logs += `Resposta de erro: ${JSON.stringify(error.response.data)}\\n`;\n    }\n    console.error(\"Erro:\", error.message, \"Logs:\", logs);\n    \n    return {\n      error: error.message,\n      details: error.response?.data || null\n    };\n  }\n}\n\nreturn runTool();\n",
        "specifyInputSchema": true,
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"knowledge_id\": {\n      \"type\": \"integer\",\n      \"description\": \"O ID do conhecimento específico no qual a busca será realizada.\"\n    },\n    \"query\": {\n      \"type\": \"string\",\n      \"description\": \"A pergunta ou consulta que será usada para realizar a busca no banco vetorial.\"\n    }\n  }\n}"
      },
      "id": "20c4edab-4c02-456f-adf2-eb0ce891acb4",
      "name": "Retriever ajustado 06-05",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        960,
        2240
      ]
    }
  ],
  "connections": {
    "Memory": {
      "ai_memory": [
        [
          {
            "node": "Main Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Main Agent": {
      "main": [
        [
          {
            "node": "No Operation 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add to List": {
      "main": [
        [
          {
            "node": "Get List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get List": {
      "main": [
        [
          {
            "node": "Switch 1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse JSON": {
      "main": [
        [
          {
            "node": "Split Itens",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop": {
      "main": [
        [
          {
            "node": "Execute Core",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Switch 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Itens": {
      "main": [
        [
          {
            "node": "Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download Media": {
      "main": [
        [
          {
            "node": "Switch 02",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch 02": {
      "main": [
        [
          {
            "node": "Transcription",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Operation 0",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Convert PDF",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reset List": {
      "main": [
        [
          {
            "node": "Chatwoot Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Final List 2": {
      "main": [
        [
          {
            "node": "Switch 3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Final List 1": {
      "main": [
        [
          {
            "node": "Parse JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cooldown": {
      "main": [
        [
          {
            "node": "Get List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Consumer": {
      "main": [
        [
          {
            "node": "Wait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch 3": {
      "main": [
        [
          {
            "node": "No Operation ",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Reset List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Core Input": {
      "main": [
        [
          {
            "node": "Main Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter": {
      "ai_languageModel": [
        [
          {
            "node": "Main Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Get Vars": {
      "main": [
        [
          {
            "node": "Downtime",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert PDF": {
      "main": [
        [
          {
            "node": "No Operation 0",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Transcription": {
      "main": [
        [
          {
            "node": "No Operation 0",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Core": {
      "main": [
        [
          {
            "node": "Get Final List 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clear History": {
      "main": [
        [
          {
            "node": "Parse JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restart History": {
      "ai_tool": [
        [
          {
            "node": "Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Switch 2": {
      "main": [
        [
          {
            "node": "Download Media",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Keep Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch 1": {
      "main": [
        [
          {
            "node": "No Operation",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Final List 1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Cooldown",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch 0": {
      "main": [
        [
          {
            "node": "Update History",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Add to List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Keep Loop": {
      "main": [
        [
          {
            "node": "Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update History": {
      "main": [
        [
          {
            "node": "Open Conversation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chatwoot Output": {
      "main": [
        [
          {
            "node": "Add Register",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Timer": {
      "ai_tool": [
        [
          {
            "node": "Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Knowledge Trigger": {
      "main": [
        [
          {
            "node": "Get Global Vars",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Global Vars": {
      "main": [
        [
          {
            "node": "Process Docs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Vector Trigger": {
      "main": [
        [
          {
            "node": "Parse JSON 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse JSON 2": {
      "main": [
        [
          {
            "node": "Split Vectors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Vectors": {
      "main": [
        [
          {
            "node": "Embeddings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings": {
      "main": [
        [
          {
            "node": "Add Vectors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RAG Input": {
      "main": [
        [
          {
            "node": "Get History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get History": {
      "main": [
        [
          {
            "node": "RAG Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mapping": {
      "main": [
        [
          {
            "node": "Switch 0",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Operation ": {
      "main": [
        [
          {
            "node": "Clear History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Downtime": {
      "main": [
        [
          {
            "node": "Mapping",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Operation 0": {
      "main": [
        [
          {
            "node": "Keep Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Postgres Trigger": {
      "main": [
        [
          {
            "node": "Get Dimensions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Dimensions": {
      "main": [
        [
          {
            "node": "Update Vectors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RAG Agent": {
      "main": [
        [
          {
            "node": "No Operation 3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GoogleCalendarManager": {
      "ai_tool": [
        [
          {
            "node": "Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "RAG Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Wait": {
      "main": [
        [
          {
            "node": "Get Vars",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Retriever2": {
      "ai_tool": [
        [
          {
            "node": "RAG Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "timezone": "America/Sao_Paulo",
    "callerPolicy": "workflowsFromSameOwner",
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": null,
  "pinData": {},
  "versionId": "eff50d40-3e68-49de-ae7c-fa57deb35986",
  "triggerCount": 6,
  "tags": []
}