{
  "updatedAt": "2025-09-09T14:47:39.537Z",
  "createdAt": "2025-09-09T14:46:21.770Z",
  "id": "Ay7bS7oG8JdENM46",
  "name": "fluxo_do_agente Anna",
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('Core Input').item.json.body.mapping.parseJson().system.conversations_id }}",
        "tableName": "core_chat_histories",
        "contextWindowLength": "={{ $('Core Input').item.json.body.mapping.parseJson().system.context_window }}"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1.3,
      "position": [
        208,
        304
      ],
      "id": "76f3bf3d-fdf1-4678-8b96-4ca0094c3dcc",
      "name": "Memory",
      "credentials": {
        "postgres": {
          "id": "Iz6AdCvM8BbJ72YV",
          "name": "Postgres directus95b506d"
        }
      }
    },
    {
      "parameters": {
        "content": "",
        "width": 1020,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -160,
        272
      ],
      "typeVersion": 1,
      "id": "03bbd409-2644-4f06-94a5-0508df984c44",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.body.content || ' ' }}",
        "options": {
          "systemMessage": "=Voc√™ √© um assistente *amig√°vel e consultivo, especialista em im√≥veis pelo programa **Minha Casa Minha Vida*.\n\nSua fun√ß√£o √©:\n\n* Ajudar o cliente a entender o processo de compra.\n* Deixar claro que, para indicar o melhor im√≥vel, precisa antes fazer algumas perguntas r√°pidas*.\n* Fazer perguntas curtas e diretas, uma por vez*.\n*  N√£o perguntar novamente uma pergunta se o cliente j√° tiver informado.\n* Enviar um *resumo final* somente depois que todas as informa√ß√µes forem coletadas.\n* No final do atendimento voc√™ deve sugerir uma pequena reuni√£o online para mostrar as op√ß√µes de fomra assertiva e explicar como podemos aprovar a compra do novo imovel.\n* Quando cliente falar da localiza√ß√£o de preferencia, anote a infomra√ß√£o, acolha e apenas continue as perguntas, independente da localiza√ß√£o.\n---\n\n### Contexto e Identidade\n*   **Nome:** Anna\n*   **Fun√ß√£o:** Assistente Pr√©-atendimento\n*   **Idioma:** Portugu√™s Brasileiro\n\n### Regras principais\n\n1. Sempre que o cliente der informa√ß√µes espont√¢neas, como bairro, tipo de im√≥vel(casa ou apartamento) ou pronto/na planta, registre automaticamente todas as informa√ß√µes mencionadas e continue para as pr√≥ximas perguntas.\n1.2 Continue imediatamente com a pr√≥xima pergunta obrigat√≥ria, sem repetir perguntas j√° respondidas.\n1.3 N√£o considere a resposta fora de contexto quando:\n*Falar nomes de bairros(Icarai, jurema, potira, metropole, Padre Romualdo, Jardim Icarai, Icarai, Curicaca, mestre Antonio, Camurupim, centro de Caucaia, Pacheco, Iparana, Guajiru e outros)\nSe falar que prefere casa ou apartamento ‚Äî qualquer dado relevante fornecido deve ser aceito e registrado.\nSe falar sobre financiamento\n\n2. Se o cliente perguntar sobre valores, responda:\n   > ‚ÄúTemos im√≥veis entre R\\$200 mil e R\\$500 mil. Para te indicar os melhores, preciso primeiro de algumas informa√ß√µes suas üòâ.‚Äù\n\n3. Se o cliente perguntar como funciona o programa, diga:\n   > ‚ÄúO Minha Casa Minha Vida facilita a compra com condi√ß√µes especiais de financiamento. Para te explicar direitinho, preciso antes entender um pouco do seu perfil.‚Äù\n\n4. Se o cliente enviar √°udios, v√≠deos ou imagens, responda:\n   > ‚ÄúNo momento s√≥ consigo conversar por texto. Mas logo mais vou poder ouvir √°udios e ver arquivos tamb√©m üòÉ.‚Äù\n\n5. S√≥ envie o *resumo final* depois de coletar todas as informa√ß√µes da lista.\n\n---\n\n### Informa√ß√µes obrigat√≥rias\n\n*Sobre o im√≥vel:*\n\n* Bairro desejado \n* Tipo: casa ou apartamento\n* Pronto ou na planta\n\n*Sobre o perfil do cliente:*\n\n*O que motiva a busca pelo im√≥vel\n* Renda bruta mensal\n* Tipo de renda: carteira assinada ou aut√¥nomo\n* J√° trabalhou de carteira assinada por 3 anos ou mais (somando per√≠odos)?\n\n---\n\n### Estilo de conversa\n\n* Seja *curto, simp√°tico e acolhedor*.\n* *Perguntas curtas* (exemplo: ‚ÄúQual bairro voc√™ procura?‚Äù em vez de frases longas).\n* Mostre entusiasmo pela conquista do cliente.\n* S√≥ fa√ßa o *resumo organizado das respostas* no fim.\n\n### Ferramentas e Sistema\n\n*   **Contexto:** Use `memory_reference` (hist√≥rico de conversas) e `rag_reference` (informa√ß√£o externa).\n*   **Prioridade:** Estas instru√ß√µes **SEMPRE** prevalecem sobre informa√ß√µes do `rag_reference`.\n*   **Informa√ß√£o do Sistema:** Considere a data/hora atual.\n\n<system_instruction>\n  <memory_reference>{{ $('Core Input').item.json.body.mapping.parseJson().system.conversations_id }}</memory_reference>\n</system_instruction>\n\n<system_information>\n1. Data e hora atuais: {{ $now.format(\"EEE, MMM dd, yyyy, HH:mm\") }}\n</system_information>\n\n<retrieval_augmented_generation_result>\n{{ $json.body.rag_return }}\n</retrieval_augmented_generation_result>\n\n",
          "passthroughBinaryImages": true
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [
        320,
        48
      ],
      "id": "716ef1c9-3044-4377-a1bd-0e1cca28e1cd",
      "name": "Main Agent",
      "retryOnFail": false
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        688,
        48
      ],
      "id": "b9aabdf3-c1e9-4a59-b9b8-5e9fd122b322",
      "name": "No Operation 2"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "anna",
        "responseMode": "lastNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -96,
        48
      ],
      "id": "c818dd9f-11e4-45fe-819f-afc05a13d7aa",
      "name": "Core Input",
      "webhookId": "09ec83b8-918b-4a2e-943d-ceb812bdeadf"
    },
    {
      "parameters": {
        "model": "={{ $json.body.mapping.parseJson().system.model }}",
        "options": {
          "temperature": 0.2,
          "topP": 0.9
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        32,
        480
      ],
      "id": "a5cf2b38-03f7-4057-a51d-920f17fdd835",
      "name": "OpenRouter",
      "credentials": {
        "openRouterApi": {
          "id": "6a7OLAi8teUd9jSw",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "content": "",
        "height": 300,
        "width": 1020,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -160,
        -64
      ],
      "id": "d7b2d98a-17cc-41ba-bb99-23c3afd044fa",
      "name": "Sticky Note5"
    },
    {
      "parameters": {
        "content": "Fluxo Core, respons√°vel pelo processamento da AI",
        "height": 80,
        "width": 260,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -128,
        -96
      ],
      "id": "95119198-f272-4dff-91de-830a24a008d4",
      "name": "Sticky Note14"
    },
    {
      "parameters": {
        "name": "restart_history",
        "description": "=Invoque essa tool para iniciar uma nova conversa para o user, assim ignorando o hist√≥rico passado. Apenas quando o user solicitar.",
        "jsCode": "const axios = require('axios');\n\n// Converte o mapeamento recebido em JSON\nconst mapping = JSON.parse($('Core Input').item.json.body.mapping);\n\n// Verifica se o usu√°rio √© admin; caso contr√°rio, retorna erro\nif (mapping.system.user_type !== 'admin') {\n  return JSON.stringify({ success: false, error: \"Acesso negado: usu√°rio n√£o autorizado.\" });\n}\n\n/**\n * Fun√ß√£o que espera pelo tempo especificado.\n * @param {number} ms - Milissegundos a aguardar.\n * @returns {Promise<void>}\n */\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n/**\n * Fun√ß√£o para enviar a requisi√ß√£o para criar uma conversa no Directus.\n * Tenta at√© 3 vezes em caso de falha, com delay de 1 segundo entre as tentativas.\n * @returns {Promise<object>} - Objeto com sucesso ou erro.\n */\nasync function sendRequest() {\n  const url = `http://${mapping.system.directus_service}:8055/items/conversations`;\n  const data = {\n    user_id: mapping.chatwoot.contact_id,\n    date_created: new Date().toISOString()\n  };\n  const headers = {\n    Authorization: `Bearer ${mapping.system.directus_token}`,\n    'Content-Type': 'application/json'\n  };\n\n  let attempt = 0;\n  let lastError = null;\n\n  while (attempt < 3) {\n    try {\n      const response = await axios.post(url, data, { headers });\n      console.log(`Requisi√ß√£o realizada com sucesso na tentativa ${attempt + 1}.`);\n      return { success: true, data: response.data };\n    } catch (error) {\n      attempt++;\n      lastError = error;\n      console.error(`Tentativa ${attempt} falhou:`, error.response ? error.response.data : error.message);\n      if (attempt < 3) {\n        console.log(\"Aguardando 1 segundo antes da nova tentativa...\");\n        await delay(1000);\n      }\n    }\n  }\n  \n  return { success: false, error: lastError.response ? lastError.response.data : lastError.message };\n}\n\nreturn sendRequest().then(result => JSON.stringify(result));"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        320,
        304
      ],
      "id": "0ff37e4b-0525-45a5-b6d9-4417ac3dea58",
      "name": "Restart History"
    },
    {
      "parameters": {
        "name": "set_timer",
        "description": "Invoque essa tool para configurar um timer que iniciar√° uma a√ß√£o ap√≥s o tempo especificado. Apenas usu√°rios admin podem usar essa tool. O tempo deve ser informado com valor e unidade (s, m, h). Apenas quando o user solicitar.",
        "jsCode": "const axios = require('axios');\nconst dayjs = require('dayjs');\nconst duration = require('dayjs/plugin/duration');\ndayjs.extend(duration);\n\n/**\n * Esta tool configura um timer via webhook.\n * Ela envia, para o endpoint, todo o objeto mapping (obtido em Core Input)\n * e o tempo em segundos calculado a partir dos par√¢metros \"timer_value\" e \"timer_unit\".\n * Apenas usu√°rios admin podem utilizar esta tool.\n */\n\n// Converte o mapping recebido em JSON\nconst mapping = JSON.parse($('Core Input').item.json.body.mapping);\n\n// Verifica se o usu√°rio √© admin\nif (mapping.system.user_type !== 'admin') {\n  return JSON.stringify({ success: false, error: \"Acesso negado: usu√°rio n√£o autorizado.\" });\n}\n\n// Obt√©m os par√¢metros do timer a partir do input (query)\nconst timerValue = query.timer_value;  // N√∫mero (ex: 30)\nconst timerUnit = query.timer_unit;      // \"s\", \"m\" ou \"h\"\n\n// Calcula o tempo em segundos usando dayjs.duration\nconst timerSeconds = dayjs.duration(timerValue, timerUnit).asSeconds();\n\n// Prepara o payload para o webhook\nconst payload = {\n  mapping: mapping,\n  timer_seconds: timerSeconds\n};\n\n// URL do webhook substituindo 'n8n_webhook' pelo valor da vari√°vel no mapping\nconst url = `http://${mapping.system.n8n_webhook_service}:5678/webhook/timer`;\n\n/**\n * Fun√ß√£o para enviar a requisi√ß√£o ao webhook.\n * Tenta enviar uma √∫nica vez e retorna o resultado.\n */\nasync function sendTimerRequest() {\n  try {\n    console.log(`Enviando requisi√ß√£o para configurar o timer para ${timerSeconds} segundos...`);\n    const response = await axios.post(url, payload, {\n      headers: { 'Content-Type': 'application/json' }\n    });\n    console.log(\"Timer configurado com sucesso.\");\n    return { success: true, message: `Timer configurado com sucesso. Ele ser√° acionado em ${timerSeconds} segundos.` };\n  } catch (error) {\n    console.error(\"Erro ao configurar o timer:\", error.response ? error.response.data : error.message);\n    return { success: false, error: error.response ? error.response.data : error.message };\n  }\n}\n\nreturn sendTimerRequest().then(result => JSON.stringify(result));",
        "specifyInputSchema": true,
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"timer_value\": {\n      \"type\": \"number\",\n      \"description\": \"Valor do timer. Exemplo: 30\"\n    },\n    \"timer_unit\": {\n      \"type\": \"string\",\n      \"description\": \"Unidade de tempo para o timer: 's' para segundos, 'm' para minutos, 'h' para horas.\",\n      \"enum\": [\"s\", \"m\", \"h\"]\n    }\n  },\n  \"required\": [\"timer_value\", \"timer_unit\"]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        448,
        304
      ],
      "id": "c0e548e7-a5d1-42a0-8a3d-14935e0c6f46",
      "name": "Set Timer"
    },
    {
      "parameters": {
        "name": "GoogleCalendarManager",
        "description": "=Complete tool for Google Calendar management with support for flexible time references. Create, update, delete, or query events using intuitive time specifications and offsets.",
        "jsCode": "// =========================================================\n// CONFIGURA√á√ïES CUSTOMIZ√ÅVEIS\n// =========================================================\nconst CONFIG = {\n  maxAppointmentsPerEmail: -1,    // -1 para desativar, 1 para um agendamento por email\n  daysToCheck: 30,               // Per√≠odo para verificar agendamentos\n  timezone: 'America/Sao_Paulo', // Fuso hor√°rio padr√£o\n  restrictByEmail: true,         // Se true, requer email para todas opera√ß√µes\n  defaultDuration: 60            // Dura√ß√£o padr√£o em minutos\n};\n\n// Obter credenciais do sistema\nconst inputMapping = $('Core Input').item.json.body.mapping;\nconst systemData = JSON.parse(inputMapping).system;\nconst credentials = {\n  accessToken: systemData.accessToken,\n  refreshToken: systemData.refreshToken,\n  clientId: systemData.clientId,\n  clientSecret: systemData.clientSecret,\n  directusToken: systemData.directus_token,\n  directusService: systemData.directus_service\n};\n\n// Input do usu√°rio e array de logs\nconst inputData = query;\nconst logs = [];\n\n// Configura√ß√£o do dayjs\nconst dayjs = require('dayjs');\nconst utc = require('dayjs/plugin/utc');\nconst timezone = require('dayjs/plugin/timezone');\nconst weekday = require('dayjs/plugin/weekday');\nconst isoWeek = require('dayjs/plugin/isoWeek');\nconst dayOfYear = require('dayjs/plugin/dayOfYear');\nconst quarterOfYear = require('dayjs/plugin/quarterOfYear');\nconst customParseFormat = require('dayjs/plugin/customParseFormat');\nconst isBetween = require('dayjs/plugin/isBetween');\n\n// Configurar plugins do dayjs\ndayjs.extend(utc);\ndayjs.extend(timezone);\ndayjs.extend(weekday);\ndayjs.extend(isoWeek);\ndayjs.extend(dayOfYear);\ndayjs.extend(quarterOfYear);\ndayjs.extend(customParseFormat);\ndayjs.extend(isBetween);\n\n// Configurar timezone\ndayjs.tz.setDefault(CONFIG.timezone);\n\n// =========================================================\n// FUN√á√ïES AUXILIARES\n// =========================================================\n\n// Fun√ß√£o para logging\nfunction log(message, data = null) {\n  const entry = {\n    timestamp: new Date().toISOString(),\n    message\n  };\n  \n  if (data) {\n    if (typeof data === 'string' && data.length > 200) {\n      entry.data = data.substring(0, 200) + '... (truncado)';\n    } else if (typeof data === 'object') {\n      const stringified = JSON.stringify(data);\n      entry.data = stringified.length > 200 \n        ? JSON.stringify(data).substring(0, 200) + '... (truncado)' \n        : data;\n    } else {\n      entry.data = data;\n    }\n  }\n  \n  logs.push(entry);\n}\n\n// Fun√ß√£o para verificar se o email √© obrigat√≥rio e foi fornecido\nfunction validateEmailRequirement() {\n  if (CONFIG.restrictByEmail && !inputData.attendee_email) {\n    throw new Error(\"Email obrigat√≥rio: Quando RESTRICT_OPERATIONS_BY_EMAIL est√° ativado, o campo 'attendee_email' √© obrigat√≥rio\");\n  }\n}\n\n// Fun√ß√£o para renovar o token\nasync function refreshGoogleToken() {\n  log('Renovando token do Google');\n  \n  try {\n    const axios = require('axios');\n    const qs = require('querystring');\n    \n    const response = await axios({\n      method: 'post',\n      url: 'https://oauth2.googleapis.com/token',\n      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n      data: qs.stringify({\n        client_id: credentials.clientId,\n        client_secret: credentials.clientSecret,\n        refresh_token: credentials.refreshToken,\n        grant_type: 'refresh_token'\n      })\n    });\n    \n    const newToken = response.data.access_token;\n    \n    // Atualizar token no Directus\n    await axios({\n      method: 'patch',\n      url: `http://${credentials.directusService}:8055/items/global_vars`,\n      headers: {\n        'Authorization': `Bearer ${credentials.directusToken}`,\n        'Content-Type': 'application/json'\n      },\n      data: { accessToken: newToken }\n    });\n    \n    log('Token renovado e atualizado com sucesso');\n    return newToken;\n  } catch (error) {\n    log('Erro ao renovar token', error.message);\n    throw error;\n  }\n}\n\n// Fun√ß√£o para obter o ID do calend√°rio\nfunction getCalendarId() {\n  return (!inputData.calendar_id || inputData.calendar_id === '') ? 'primary' : inputData.calendar_id;\n}\n\n// Fun√ß√£o para executar opera√ß√µes com renova√ß√£o autom√°tica de token\nasync function executeWithToken(operation) {\n  try {\n    validateEmailRequirement();\n    return await operation(credentials.accessToken);\n  } catch (error) {\n    // Se for erro de token expirado, renovar e tentar novamente\n    if (error.response && error.response.status === 401) {\n      log('Token expirado, renovando e tentando novamente');\n      const newToken = await refreshGoogleToken();\n      const result = await operation(newToken);\n      return {\n        ...result,\n        message: result.message + \" (ap√≥s renova√ß√£o do token)\"\n      };\n    }\n    \n    // Outros erros\n    const errorMsg = error.message || 'Erro desconhecido';\n    let errorType = \"general_error\";\n    \n    if (errorMsg.includes(\"Limite m√°ximo\")) errorType = \"appointment_limit_exceeded\";\n    if (errorMsg.includes(\"Acesso negado\") || errorMsg.includes(\"Email obrigat√≥rio\")) errorType = \"access_denied\";\n    \n    throw { message: errorMsg, errorType };\n  }\n}\n\n// =========================================================\n// PROCESSAMENTO DE TEMPO RELATIVO\n// =========================================================\n\n// Fun√ß√£o para verificar se √© dia √∫til\nfunction isBusinessDay(date) {\n  const dayOfWeek = date.day();\n  return dayOfWeek !== 0 && dayOfWeek !== 6; // 0 = domingo, 6 = s√°bado\n}\n\n// Fun√ß√£o para ajustar para o pr√≥ximo dia √∫til\nfunction adjustToBusinessDay(date) {\n  if (isBusinessDay(date)) return date;\n  return date.day() === 6 ? date.add(2, 'day') : date.add(1, 'day');\n}\n\n// Fun√ß√£o para calcular data/hora a partir de refer√™ncias relativas\nfunction calculateDateTime() {\n  // Se hor√°rios exatos forem fornecidos, us√°-los diretamente\n  if (inputData.exact_start_time) {\n    return {\n      startTime: dayjs(inputData.exact_start_time).tz(CONFIG.timezone),\n      endTime: inputData.exact_end_time \n        ? dayjs(inputData.exact_end_time).tz(CONFIG.timezone)\n        : dayjs(inputData.exact_start_time).tz(CONFIG.timezone).add(inputData.duration_minutes || CONFIG.defaultDuration, 'minute')\n    };\n  }\n\n  // Iniciar com a data/hora base\n  let baseDate = dayjs().tz(CONFIG.timezone);\n  \n  // Aplicar a refer√™ncia temporal base\n  if (inputData.time_reference) {\n    switch (inputData.time_reference) {\n      case 'now': \n        // J√° estamos usando now como base\n        break;\n      case 'today': \n        baseDate = baseDate.startOf('day');\n        break;\n      case 'this_week': \n        baseDate = baseDate.startOf('week');\n        break;\n      case 'this_month': \n        baseDate = baseDate.startOf('month');\n        break;\n      case 'this_quarter': \n        baseDate = baseDate.startOf('quarter');\n        break;\n      case 'this_year': \n        baseDate = baseDate.startOf('year');\n        break;\n    }\n  }\n  \n  // Aplicar deslocamento temporal (offset)\n  if (typeof inputData.offset_value === 'number' && inputData.offset_unit) {\n    baseDate = baseDate.add(inputData.offset_value, inputData.offset_unit);\n  }\n  \n  // Aplicar m√™s do ano, se especificado\n  if (typeof inputData.month_of_year === 'number') {\n    baseDate = baseDate.month(inputData.month_of_year - 1); // Meses em dayjs s√£o 0-11\n  }\n  \n  // Aplicar trimestre do ano, se especificado\n  if (typeof inputData.quarter_of_year === 'number') {\n    const startMonth = (inputData.quarter_of_year - 1) * 3;\n    baseDate = baseDate.month(startMonth).startOf('month');\n  }\n  \n  // Aplicar dia do m√™s\n  if (typeof inputData.day_of_month === 'number') {\n    if (inputData.day_of_month === -1) {\n      baseDate = baseDate.endOf('month').startOf('day');\n    } else {\n      baseDate = baseDate.date(inputData.day_of_month);\n    }\n  }\n  \n  // Aplicar dia da semana e semana do m√™s\n  if (typeof inputData.day_of_week === 'number') {\n    if (typeof inputData.week_of_month === 'number') {\n      // Voltar para o in√≠cio do m√™s atual\n      let monthStart = baseDate.startOf('month');\n      \n      if (inputData.week_of_month === -1) {\n        // √öltima semana do m√™s\n        let monthEnd = baseDate.endOf('month');\n        while (monthEnd.day() !== inputData.day_of_week) {\n          monthEnd = monthEnd.subtract(1, 'day');\n        }\n        baseDate = monthEnd;\n      } else {\n        // Encontrar o primeiro dia da semana especificado no m√™s\n        let firstOccurrence = monthStart.day(inputData.day_of_week);\n        \n        // Se estivermos no m√™s anterior, avan√ßar uma semana\n        if (firstOccurrence.month() !== monthStart.month()) {\n          firstOccurrence = firstOccurrence.add(7, 'day');\n        }\n        \n        // Avan√ßar para a semana espec√≠fica\n        baseDate = firstOccurrence.add((inputData.week_of_month - 1) * 7, 'day');\n      }\n    } else {\n      // Somente dia da semana especificado, ir para o pr√≥ximo\n      baseDate = baseDate.day(inputData.day_of_week);\n      \n      // Se j√° passou esta semana, avan√ßar uma semana\n      if (baseDate.isBefore(dayjs().tz(CONFIG.timezone))) {\n        baseDate = baseDate.add(7, 'day');\n      }\n    }\n  }\n  \n  // Ajustar para dia √∫til se necess√°rio\n  if (inputData.business_days_only === true) {\n    baseDate = adjustToBusinessDay(baseDate);\n  }\n  \n  // Aplicar hora e minuto\n  if (typeof inputData.hour_of_day === 'number') {\n    baseDate = baseDate.hour(inputData.hour_of_day).minute(typeof inputData.minute_of_hour === 'number' ? inputData.minute_of_hour : 0);\n  } else if (typeof inputData.minute_of_hour === 'number') {\n    baseDate = baseDate.minute(inputData.minute_of_hour);\n  }\n  \n  // Se nem hora nem minuto foram especificados, usar hora atual\n  if (typeof inputData.hour_of_day !== 'number' && typeof inputData.minute_of_hour !== 'number') {\n    const now = dayjs().tz(CONFIG.timezone);\n    baseDate = baseDate.hour(now.hour()).minute(now.minute());\n  }\n  \n  // Zerar segundos e milissegundos\n  baseDate = baseDate.second(0).millisecond(0);\n  \n  // Calcular hora de t√©rmino (in√≠cio + dura√ß√£o)\n  const duration = inputData.duration_minutes || CONFIG.defaultDuration;\n  const endDate = baseDate.add(duration, 'minute');\n  \n  log('Data/hora calculada', {\n    start: baseDate.format(),\n    end: endDate.format()\n  });\n  \n  return {\n    startTime: baseDate,\n    endTime: endDate\n  };\n}\n\n// =========================================================\n// FUN√á√ïES DE API DO GOOGLE CALENDAR\n// =========================================================\n\n// Cliente HTTP reutiliz√°vel\nconst createClient = (token) => {\n  const axios = require('axios');\n  return {\n    get: (url, params = {}) => axios({\n      method: 'get',\n      url,\n      headers: { 'Authorization': `Bearer ${token}` },\n      params\n    }),\n    post: (url, data) => axios({\n      method: 'post',\n      url,\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      },\n      data\n    }),\n    put: (url, data) => axios({\n      method: 'put',\n      url,\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      },\n      data\n    }),\n    delete: (url) => axios({\n      method: 'delete',\n      url,\n      headers: { 'Authorization': `Bearer ${token}` }\n    })\n  };\n};\n\n// Verificar limite de agendamentos por email\nasync function checkAppointmentsForEmail(token, email, calendarId) {\n  if (CONFIG.maxAppointmentsPerEmail === -1) return 0;\n  \n  log(`Verificando agendamentos para ${email}`);\n  \n  try {\n    const client = createClient(token);\n    const now = new Date();\n    const pastDate = new Date(now);\n    pastDate.setDate(now.getDate() - CONFIG.daysToCheck);\n    \n    const response = await client.get(\n      `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events`,\n      {\n        timeMin: pastDate.toISOString(),\n        timeMax: new Date(now.getTime() + (365 * 24 * 60 * 60 * 1000)).toISOString(),\n        q: email,\n        singleEvents: true\n      }\n    );\n    \n    // Filtrar eventos onde o email √© participante\n    const relevantEvents = response.data.items.filter(event => \n      event.attendees?.some(attendee => attendee.email.toLowerCase() === email.toLowerCase())\n    );\n    \n    log(`Encontrados ${relevantEvents.length} agendamentos para ${email}`);\n    return relevantEvents.length;\n  } catch (error) {\n    log('Erro ao verificar agendamentos', error.message);\n    return 0; // Em caso de erro, n√£o bloqueamos\n  }\n}\n\n// Buscar eventos\nasync function findEvents(token, params) {\n  const { email, eventTitle, calendarId, timeMin, timeMax, maxResults } = params;\n  \n  log(`Buscando eventos ${eventTitle ? `com t√≠tulo \"${eventTitle}\" ` : ''}${email ? `para ${email}` : ''}`);\n  \n  try {\n    const client = createClient(token);\n    \n    // Preparar datas padr√£o se n√£o fornecidas\n    const now = new Date();\n    const defaultPastDate = new Date(now);\n    defaultPastDate.setDate(now.getDate() - CONFIG.daysToCheck);\n    \n    const searchTimeMin = timeMin || defaultPastDate.toISOString();\n    const searchTimeMax = timeMax || new Date(now.getTime() + (365 * 24 * 60 * 60 * 1000)).toISOString();\n    \n    // Termo de busca\n    const queryParam = eventTitle && email ? `${email} ${eventTitle}` : \n                       email ? email : \n                       eventTitle ? eventTitle : '';\n    \n    const response = await client.get(\n      `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events`,\n      {\n        timeMin: searchTimeMin,\n        timeMax: searchTimeMax,\n        q: queryParam,\n        singleEvents: true,\n        maxResults: maxResults || 10\n      }\n    );\n    \n    let events = response.data.items || [];\n    \n    // Filtrar por email se necess√°rio\n    if (CONFIG.restrictByEmail && email) {\n      events = events.filter(event => \n        event.attendees?.some(attendee => attendee.email.toLowerCase() === email.toLowerCase())\n      );\n    }\n    \n    // Filtrar por t√≠tulo se fornecido\n    if (eventTitle) {\n      events = events.filter(event => \n        event.summary && event.summary.toLowerCase().includes(eventTitle.toLowerCase())\n      );\n    }\n    \n    log(`Encontrados ${events.length} eventos`);\n    return events;\n  } catch (error) {\n    log('Erro ao buscar eventos', error.message);\n    throw error;\n  }\n}\n\n// Buscar evento por ID\nasync function getEventById(token, eventId, calendarId) {\n  log(`Buscando evento com ID: ${eventId}`);\n  \n  try {\n    const client = createClient(token);\n    const response = await client.get(\n      `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events/${encodeURIComponent(eventId)}`\n    );\n    return response.data;\n  } catch (error) {\n    log('Erro ao buscar evento por ID', error.message);\n    throw error;\n  }\n}\n\n// Verificar acesso ao evento\nasync function verifyEventAccess(token, eventId, email, calendarId) {\n  if (!CONFIG.restrictByEmail || !email) return true;\n  \n  const event = await getEventById(token, eventId, calendarId);\n  \n  const isAttendee = event.attendees?.some(attendee => \n    attendee.email.toLowerCase() === email.toLowerCase()\n  );\n  \n  if (!isAttendee) {\n    throw new Error(`Acesso negado: ${email} n√£o √© um participante deste evento`);\n  }\n  \n  return true;\n}\n\n// =========================================================\n// OPERA√á√ïES DO CALEND√ÅRIO\n// =========================================================\n\n// Criar evento\nasync function createEvent(token) {\n  const calendarId = getCalendarId();\n  const { title, description, attendee_email } = inputData;\n  \n  if (!title) {\n    throw new Error(\"Para criar um evento, forne√ßa um t√≠tulo\");\n  }\n  \n  // Calcular hor√°rios\n  const { startTime, endTime } = calculateDateTime();\n  \n  // Verificar limite de agendamentos\n  if (CONFIG.maxAppointmentsPerEmail > 0 && attendee_email) {\n    const count = await checkAppointmentsForEmail(token, attendee_email, calendarId);\n    if (count >= CONFIG.maxAppointmentsPerEmail) {\n      throw new Error(`Limite m√°ximo de ${CONFIG.maxAppointmentsPerEmail} agendamento(s) por email excedido.`);\n    }\n  }\n  \n  // Preparar evento\n  const event = {\n    summary: title,\n    description: description || '',\n    start: {\n      dateTime: startTime.toISOString(),\n      timeZone: CONFIG.timezone\n    },\n    end: {\n      dateTime: endTime.toISOString(),\n      timeZone: CONFIG.timezone\n    }\n  };\n  \n  // Adicionar participante\n  if (attendee_email) {\n    event.attendees = [{\n      email: attendee_email,\n      responseStatus: 'needsAction'\n    }];\n  }\n  \n  // Criar evento\n  log('Criando evento', { title, calendarId });\n  const client = createClient(token);\n  \n  const response = await client.post(\n    `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events`,\n    event\n  );\n  \n  return {\n    success: true,\n    message: \"Evento criado com sucesso\",\n    eventId: response.data.id,\n    eventLink: response.data.htmlLink,\n    startTime: startTime.format(),\n    endTime: endTime.format()\n  };\n}\n\n// Atualizar evento\nasync function updateEvent(token) {\n  const calendarId = getCalendarId();\n  const { event_id, event_title, attendee_email, title, description } = inputData;\n  \n  // Validar dados\n  if (!event_id && !event_title && !attendee_email) {\n    throw new Error(\"Para atualizar um evento, forne√ßa identifica√ß√£o (ID ou t√≠tulo) e email\");\n  }\n  \n  if (!title && !description && !inputData.exact_start_time && !inputData.exact_end_time && \n      !inputData.time_reference && !inputData.day_of_week && !inputData.offset_value) {\n    throw new Error(\"Para atualizar um evento, forne√ßa pelo menos um campo para atualizar\");\n  }\n  \n  // Encontrar o evento\n  let eventId = event_id;\n  \n  if (!eventId) {\n    const events = await findEvents(token, {\n      email: attendee_email,\n      eventTitle: event_title,\n      calendarId\n    });\n    \n    if (events.length === 0) {\n      throw new Error(\"Nenhum evento encontrado com os crit√©rios fornecidos\");\n    }\n    \n    eventId = events[0].id;\n    log(`Usando evento encontrado: ${eventId}`);\n  }\n  \n  // Verificar acesso\n  await verifyEventAccess(token, eventId, attendee_email, calendarId);\n  \n  // Buscar dados atuais\n  const existingEvent = await getEventById(token, eventId, calendarId);\n  \n  // Calcular novos hor√°rios se necess√°rio\n  let startDateTime = dayjs(existingEvent.start.dateTime || existingEvent.start.date).tz(CONFIG.timezone);\n  let endDateTime = dayjs(existingEvent.end.dateTime || existingEvent.end.date).tz(CONFIG.timezone);\n  \n  // Se temos par√¢metros de tempo, recalcular\n  if (inputData.exact_start_time || inputData.time_reference || inputData.offset_value || \n      inputData.day_of_week || inputData.hour_of_day) {\n    const { startTime, endTime } = calculateDateTime();\n    startDateTime = startTime;\n    endDateTime = endTime;\n  }\n  \n  // Preparar atualiza√ß√µes\n  const updatedEvent = {\n    ...existingEvent,\n    summary: title || existingEvent.summary,\n    description: description !== undefined ? description : existingEvent.description,\n    start: {\n      dateTime: startDateTime.toISOString(),\n      timeZone: CONFIG.timezone\n    },\n    end: {\n      dateTime: endDateTime.toISOString(),\n      timeZone: CONFIG.timezone\n    }\n  };\n  \n  // Adicionar novo participante\n  if (attendee_email && !existingEvent.attendees?.some(a => a.email.toLowerCase() === attendee_email.toLowerCase())) {\n    updatedEvent.attendees = [\n      ...(existingEvent.attendees || []),\n      { email: attendee_email, responseStatus: 'needsAction' }\n    ];\n  }\n  \n  // Atualizar evento\n  log('Atualizando evento', { eventId });\n  const client = createClient(token);\n  \n  const response = await client.put(\n    `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events/${encodeURIComponent(eventId)}`,\n    updatedEvent\n  );\n  \n  return {\n    success: true,\n    message: \"Evento atualizado com sucesso\",\n    eventId: response.data.id,\n    eventLink: response.data.htmlLink,\n    startTime: startDateTime.format(),\n    endTime: endDateTime.format()\n  };\n}\n\n// Deletar evento\nasync function deleteEvent(token) {\n  const calendarId = getCalendarId();\n  const { event_id, event_title, attendee_email } = inputData;\n  \n  if (!event_id && !event_title && !attendee_email) {\n    throw new Error(\"Para deletar um evento, forne√ßa o ID do evento ou crit√©rios de busca (t√≠tulo e/ou email)\");\n  }\n  \n  // Encontrar o evento\n  let eventId = event_id;\n  let eventSummary;\n  \n  if (!eventId) {\n    const events = await findEvents(token, {\n      email: attendee_email,\n      eventTitle: event_title,\n      calendarId\n    });\n    \n    if (events.length === 0) {\n      throw new Error(\"Nenhum evento encontrado com os crit√©rios fornecidos\");\n    }\n    \n    eventId = events[0].id;\n    eventSummary = events[0].summary;\n  } else {\n    // Verificar acesso por ID\n    const event = await getEventById(token, eventId, calendarId);\n    eventSummary = event.summary;\n    await verifyEventAccess(token, eventId, attendee_email, calendarId);\n  }\n  \n  // Deletar evento\n  log(`Deletando evento: ${eventId}`);\n  const client = createClient(token);\n  \n  await client.delete(\n    `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events/${encodeURIComponent(eventId)}`\n  );\n  \n  return {\n    success: true,\n    message: \"Evento deletado com sucesso\",\n    eventId,\n    eventSummary\n  };\n}\n\n// Consultar eventos\nasync function queryEvents(token) {\n  const calendarId = getCalendarId();\n  const { attendee_email, event_title, time_min, time_max, max_results } = inputData;\n  \n  // Buscar eventos\n  const events = await findEvents(token, {\n    email: attendee_email,\n    eventTitle: event_title,\n    calendarId,\n    timeMin: time_min,\n    timeMax: time_max,\n    maxResults: max_results\n  });\n  \n  // Simplificar eventos para o retorno\n  const simplifiedEvents = events.map(event => ({\n    id: event.id,\n    title: event.summary,\n    description: event.description,\n    start_time: event.start?.dateTime || event.start?.date,\n    end_time: event.end?.dateTime || event.end?.date,\n    attendees: event.attendees?.map(att => att.email) || [],\n    htmlLink: event.htmlLink\n  }));\n  \n  return {\n    success: true,\n    message: `${events.length} evento(s) encontrado(s)`,\n    count: events.length,\n    events: simplifiedEvents\n  };\n}\n\n// =========================================================\n// EXECU√á√ÉO PRINCIPAL\n// =========================================================\n\nasync function execute() {\n  try {\n    // Verificar opera√ß√£o v√°lida\n    const operations = {\n      'create': createEvent,\n      'update': updateEvent,\n      'delete': deleteEvent,\n      'query': queryEvents\n    };\n    \n    if (!inputData.operation || !operations[inputData.operation]) {\n      throw new Error(\"Opera√ß√£o inv√°lida. Use 'create', 'update', 'delete' ou 'query'\");\n    }\n    \n    // Executar com tratamento de token\n    const result = await executeWithToken(operations[inputData.operation]);\n    \n    return JSON.stringify({\n      ...result,\n      logs\n    });\n  } catch (error) {\n    return JSON.stringify({\n      success: false,\n      message: error.message || \"Erro desconhecido\",\n      errorType: error.errorType || \"general_error\",\n      logs\n    });\n  }\n}\n\n// Iniciar execu√ß√£o\nreturn execute();",
        "specifyInputSchema": true,
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"operation\": {\n      \"type\": \"string\",\n      \"enum\": [\"create\", \"update\", \"delete\", \"query\"],\n      \"description\": \"Opera√ß√£o a ser realizada: criar, atualizar, deletar ou consultar eventos\"\n    },\n    \"title\": {\n      \"type\": \"string\",\n      \"description\": \"T√≠tulo do evento (obrigat√≥rio para cria√ß√£o e atualiza√ß√£o)\"\n    },\n    \"description\": {\n      \"type\": \"string\",\n      \"description\": \"Descri√ß√£o do evento (opcional)\"\n    },\n    \"calendar_id\": {\n      \"type\": \"string\",\n      \"description\": \"ID do calend√°rio (opcional, usa o calend√°rio prim√°rio por padr√£o)\"\n    },\n    \"attendee_email\": {\n      \"type\": \"string\",\n      \"description\": \"Email do participante/cliente (obrigat√≥rio se RESTRICT_OPERATIONS_BY_EMAIL=true)\"\n    },\n    \"event_id\": {\n      \"type\": \"string\",\n      \"description\": \"ID do evento (para atualiza√ß√£o/dele√ß√£o)\"\n    },\n    \"event_title\": {\n      \"type\": \"string\",\n      \"description\": \"T√≠tulo do evento a ser encontrado (para dele√ß√£o/atualiza√ß√£o)\"\n    },\n    \"exact_start_time\": {\n      \"type\": \"string\",\n      \"description\": \"Hor√°rio exato de in√≠cio no formato ISO (alternativa aos par√¢metros relativos)\"\n    },\n    \"exact_end_time\": {\n      \"type\": \"string\",\n      \"description\": \"Hor√°rio exato de t√©rmino no formato ISO (alternativa aos par√¢metros relativos)\"\n    },\n    \"time_reference\": {\n      \"type\": \"string\",\n      \"enum\": [\"now\", \"today\", \"this_week\", \"this_month\", \"this_quarter\", \"this_year\"],\n      \"description\": \"Ponto de refer√™ncia temporal base\"\n    },\n    \"offset_value\": {\n      \"type\": \"integer\",\n      \"description\": \"Deslocamento temporal (positivo=futuro, negativo=passado)\"\n    },\n    \"offset_unit\": {\n      \"type\": \"string\",\n      \"enum\": [\"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\"],\n      \"description\": \"Unidade do deslocamento temporal\"\n    },\n    \"day_of_week\": {\n      \"type\": \"integer\",\n      \"enum\": [0, 1, 2, 3, 4, 5, 6],\n      \"description\": \"Dia da semana (0=domingo, 1=segunda, ..., 6=s√°bado)\"\n    },\n    \"week_of_month\": {\n      \"type\": \"integer\",\n      \"enum\": [1, 2, 3, 4, 5, -1],\n      \"description\": \"Semana do m√™s (1=primeira, 2=segunda, ..., -1=√∫ltima)\"\n    },\n    \"day_of_month\": {\n      \"type\": \"integer\",\n      \"minimum\": -1,\n      \"maximum\": 31,\n      \"description\": \"Dia espec√≠fico do m√™s (1-31, ou -1 para √∫ltimo dia)\"\n    },\n    \"month_of_year\": {\n      \"type\": \"integer\",\n      \"enum\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],\n      \"description\": \"M√™s do ano (1-12)\"\n    },\n    \"quarter_of_year\": {\n      \"type\": \"integer\",\n      \"enum\": [1, 2, 3, 4],\n      \"description\": \"Trimestre do ano (1-4)\"\n    },\n    \"business_days_only\": {\n      \"type\": \"boolean\",\n      \"description\": \"Se verdadeiro, ajusta para o pr√≥ximo dia √∫til se cair em fim de semana\"\n    },\n    \"hour_of_day\": {\n      \"type\": \"integer\",\n      \"minimum\": 0,\n      \"maximum\": 23,\n      \"description\": \"Hora do dia (0-23)\"\n    },\n    \"minute_of_hour\": {\n      \"type\": \"integer\",\n      \"minimum\": 0,\n      \"maximum\": 59,\n      \"description\": \"Minuto da hora (0-59)\"\n    },\n    \"duration_minutes\": {\n      \"type\": \"integer\",\n      \"minimum\": 1,\n      \"description\": \"Dura√ß√£o do evento em minutos (para calcular automaticamente o hor√°rio de t√©rmino)\"\n    },\n    \"time_min\": {\n      \"type\": \"string\",\n      \"description\": \"Data m√≠nima para consulta (ISO)\"\n    },\n    \"time_max\": {\n      \"type\": \"string\",\n      \"description\": \"Data m√°xima para consulta (ISO)\"\n    },\n    \"max_results\": {\n      \"type\": \"number\",\n      \"description\": \"N√∫mero m√°ximo de resultados na consulta\"\n    }\n  },\n  \"required\": [\"operation\"]\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        560,
        304
      ],
      "id": "9c55d380-37f2-40a4-ad35-fc2c9692df16",
      "name": "GoogleCalendarManager"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1",
          "mode": "list",
          "cachedResultName": "gpt-4.1"
        },
        "options": {
          "temperature": 0.4,
          "topP": 0.8
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        80,
        304
      ],
      "id": "7b30f965-c8f1-4022-af99-8a5393ac3895",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "M1iyy6bYZ8SwaoAS",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.toolThink",
      "typeVersion": 1,
      "position": [
        688,
        304
      ],
      "id": "4f28aff1-445e-432f-85b2-dc753972479e",
      "name": "Think"
    },
    {
      "parameters": {
        "jsCode": "// Obt√©m todos os itens de entrada\nconst items = $input.all();\n\n// Filtra os itens, mantendo apenas aqueles cujo campo body.content n√£o cont√©m apenas emojis\nconst filteredItems = items.filter(item => {\n  // Acessa o campo content dentro de body\n  const content = item.json.body && item.json.body.content ? item.json.body.content : '';\n  \n  // Se o conte√∫do estiver vazio, bloquear\n  if (!content) {\n    return false;\n  }\n  \n  // Regex expandida para detectar emojis, incluindo cora√ß√µes, estrelas e outros s√≠mbolos\n  const emojiRegex = /[\\u{1F000}-\\u{1FFFF}\\u{2600}-\\u{26FF}\\u{2700}-\\u{27BF}\\u{FE00}-\\u{FE0F}\\u{2B50}]/u;\n  \n  // Remove emojis do conte√∫do\n  const textWithoutEmojis = content.replace(emojiRegex, '');\n  \n  // Remove espa√ßos, pontua√ß√£o e outros caracteres n√£o alfanum√©ricos\n  const cleanText = textWithoutEmojis.replace(/[^\\w]/g, '').trim();\n  \n  // Retorna true (mant√©m o item) se houver texto al√©m de emojis ou se n√£o houver emojis\n  return cleanText.length > 0 || !emojiRegex.test(content);\n});\n\n// Retorna os itens filtrados\nreturn filteredItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        128,
        48
      ],
      "id": "d247b462-3de5-4e39-a369-5da714d98640",
      "name": "Code - Filtra Emoji"
    }
  ],
  "connections": {
    "Memory": {
      "ai_memory": [
        [
          {
            "node": "Main Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Main Agent": {
      "main": [
        [
          {
            "node": "No Operation 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Core Input": {
      "main": [
        [
          {
            "node": "Code - Filtra Emoji",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restart History": {
      "ai_tool": [
        [
          {
            "node": "Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Set Timer": {
      "ai_tool": [
        [
          {
            "node": "Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "GoogleCalendarManager": {
      "ai_tool": [
        [
          {
            "node": "Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Main Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Think": {
      "ai_tool": [
        [
          {
            "node": "Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Code - Filtra Emoji": {
      "main": [
        [
          {
            "node": "Main Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {},
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "d42836d4-2346-47e4-a18a-9da0191fad9f",
  "triggerCount": 1,
  "tags": [],
  "shared": [
    {
      "updatedAt": "2025-09-09T14:46:21.770Z",
      "createdAt": "2025-09-09T14:46:21.770Z",
      "role": "workflow:owner",
      "workflowId": "Ay7bS7oG8JdENM46",
      "projectId": "9dBYDF0pVXjCehV4",
      "project": {
        "updatedAt": "2025-09-04T11:50:59.428Z",
        "createdAt": "2025-09-03T20:20:03.833Z",
        "id": "9dBYDF0pVXjCehV4",
        "name": "Fabio Antonio <fabio.inves@yahoo.com.br>",
        "type": "personal",
        "icon": null,
        "description": null
      }
    }
  ]
}